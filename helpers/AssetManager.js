"use strict";

var fs = require("fs");
var shortId = require('shortid');
var multer = require("multer");

/**
 * AssetManager constructor.
 * @constructor
 */
module.exports = function(permissionManager, clientManager, documentManager, db) {
	var module = {};

	module.UPLOAD_DEST = `${APP_PATH}/uploads/`;

	// Upload function generated by Multer.
	var upload = multer({
		dest: module.UPLOAD_DEST,
		limits: { fileSize: 1024 * 1024 * 20 }, // 20 MB
		fileFilter: fileFilter
	}).any();

	/**
	 * Handles file uploading.
	 * @param  {obj} req Express request object.
	 * @param  {obj} res Express response object.
	 * @public
	 */
	module.assetUploadHandler = function(req, res) {
		upload(req, res, function(err) {
			if (err) {
				console.error(err);
				return res.status(409).send(String(err));
			}

			var source = `${req.user.userId} (${req.remoteAddr})`;

			var uploadPromises = [];
			req.files.forEach(function(asset) {
				uploadPromises.push(new Promise(function(accept, reject) {
					addAsset(req.webstrateId, asset, source, function(err, assetRecord) {
						if (err) return reject(err);
						accept(assetRecord);
					});
				}));
			});

			Promise.all(uploadPromises).then(function(assetRecords) {
				res.json(assetRecords.length === 1 ? assetRecords[0] : assetRecords);
			}).catch(function(err) {
				console.error(err);
				res.status(409).send(String(err));
			});
		});
	};

	/**
	 * Get list of assets.
	 * @param  {string}   webstrateId WebstrateId.
	 * @param  {Function} next        Callback.
	 * @return {array}                (async) List of assets.
	 * @public
	 */
	module.getAssets = function(webstrateId, next) {
		return db.assets.find({ webstrateId }, { _id: 0, webstrateId: 0 })
		.toArray(function(err, assets) {
			if (err) return next && next(err);
			assets.forEach(function(asset) {
				asset.identifier = asset.fileName;
				asset.fileName = asset.originalFileName;
				delete asset.originalFileName;
			});
			return next && next(null, assets);
		});
	};

	module.getCurrentAssets = function(webstrateId, next) {
		return db.assets.find({ webstrateId }, { _id: 0, webstrateId: 0 })
		.toArray(function(err, assets) {
			if (err) return next && next(err);
			assets = filterNewestAssets(assets);
			return next(null, assets);
		});
	};

	/**
	 * Get information on specific asset.
	 * @param  {string}   options.webstrateId WebstrateId.
	 * @param  {string}   options.assetName   Asset name.
	 * @param  {int}      options.version     Version.
	 * @param  {Function} next                Callback.
	 * @return {obj}                          (async) Asset object.
	 * @public
	 */
	module.getAsset = function({ webstrateId, assetName, version }, next) {
		var query = { webstrateId, originalFileName: assetName, v: { $lte: version } };
		db.assets.find(query).sort({"v": -1}).limit(1).toArray(function(err, assets) {
			next(err, assets[0]);
		});
	};

	/**
	 * Delete asset from database. This is useful if, for some reason, an asset no longer exists in
	 * the file system, but still lingers in the database. Also ensures that the file doesn't exist in
	 * the database to avoid lingering files in the file system as well.
	 * @param  {string} fileName Name of the file in the file system. This is not the original file
	 *                           name used when uploading the file, but rather the 'identifier'.
	 * @public
	 */
	module.deleteAssetFromDatabase = function(fileName) {
		if (!fileName || fs.existsSync(`${module.UPLOAD_DEST}${fileName}`)) return;
		db.assets.deleteOne({ fileName: fileName });
	};

	/**
	 * Copy assets from before a certain version of one webstrate to another.
	 * When copying a webstrate we want to copy all the assets over as well. The assets are only
	 * duplicated in the database, not in the file system.
	 * @param  {[type]}   options.fromWebstrateId WebstrateId of source Webstrate copy assets from.
	 * @param  {[type]}   options.toWebstrate     WebstrateId of target Webstrate to copy to.
	 * @param  {[type]}   options.version         Copy all assets up to this version. When prototyping
	 *                                            off version n, we don't want assets from versions
	 *                                            newer than n.
	 * @param  {Function} next                    Callback.
	 * @public
	 */
	module.copyAssets = function({ fromWebstrateId, toWebstrateId, version }, next) {
		var query = { webstrateId: fromWebstrateId, v: { $lte: version } };
		db.assets.find(query, { _id: 0 }).toArray(function(err, assets) {
			if (err) return next && next(err);
			assets = filterNewestAssets(assets);

			// If there are no assets, we can terminate.
			if (assets.length === 0) return next();

			// When prototyping a new document, we always start from version 0, so we are going to reset
			// all asset versions to version 0 as well. Also, we need to replace the prototype webstrateId
			// (fromWebstrateId) with target webstrateId (toWebstrateId).
			assets.forEach(function(asset) {
				asset.v = 0;
				asset.webstrateId = toWebstrateId;
			});
			db.assets.insertMany(assets, next);
		});
	};

	/**
	 * Restore assets from an older version of a webstrate to a new version.
	 * When requesting an asset without a specific version or tag defined, the newest version is
	 * always being served. To prevent newer versions from be served with restored webstrates, we
	 * therefore copy the assets and bump their versions, so the the old assets now will be newer
	 * than the new assets. Yes, that's a good sentence.
	 * @param  {string}   options.webstrateId WebstrateId.
	 * @param  {int}      options.version     Version to restore from.
	 * @param  {string}   options.tag         Tag to deduce version from if no version is provided.
	 * @param  {int}      options.newVersion  Version to bump assets to.
	 * @param  {Function} next                Callback.
	 * @public
	 */
	module.restoreAssets = function({ webstrateId, version, tag, newVersion }, next) {
		// We need the version, so if it's not defined, we fetch it, and then call ourselves again,
		// this time with the version paramter set.
		if (!version) {
			return documentManager.getVersionFromTag(webstrateId, tag, function(err, version) {
				if (err) return next && next(err);
				module.restoreAssets({ webstrateId, version, tag, newVersion }, next);
			});
		}

		var query = { webstrateId, v: { $lte: version } };
		db.assets.find(query, { _id: 0 }).toArray(function(err, assets) {

			// If there are no assets, we can terminate.
			if (assets.length === 0) return next();

			if (err) return next && next(err);
			assets = filterNewestAssets(assets);
			// Bump the version of all copied assets.
			assets.forEach(function(asset) {
				asset.v = newVersion;
			});
			db.assets.insertMany(assets, next);
		});
	};

	/**
	 * Delete all assets from a webstrate. If the webstrate has been prototyped/copied, the assets may
	 * not be deleted from the file system.
	 * @param  {string}   webstrateId WebstrateId to delete assets from.
	 * @param  {Function} next        [description]
	 * @return {[type]}               [description]
	 */
	module.deleteAssets = function(webstrateId, next) {
		db.assets.find({ webstrateId }, { _id: 0, fileName: 1 }).toArray(function(err, assets) {
			if (err) return next && next(err);
			// Transform array of objects into primitive array.
			assets.forEach(function(asset, index) {
				assets[index] = asset.fileName;
			});

			// Find all files that are being used by other documents.
			db.assets.distinct('fileName', {
				fileName: { $in: assets },
				webstrateId: { $ne: webstrateId }
			}, function(err, assetsBeingUsed) {
				// Don't delete assets being used by other webstrates.
				var assetsToBeDeleted = assets.filter(function(asset) {
					return !assetsBeingUsed.includes(asset);
				});

				var promises = [];
				// Run through the files and delete them.
				assetsToBeDeleted.forEach(function(asset) {
					promises.push(new Promise(function(resolve, reject) {
						fs.unlink(`${module.UPLOAD_DEST}${asset}`, function(err) {
							// We print out errors, but we don't stop execution. If a file fails to delete, we
							// probably still want to get rid of the remaining files.
							if (err) {
								console.error(err);
							}
							resolve();
						});
					}));
				});

				// Once every file has been deleted from the file system, we delete them from the database.
				Promise.all(promises).then(function() {
					db.assets.deleteMany({ webstrateId }, next);
				});
			});
		});
	};

	/**
	 * Filter assets to only keep the newest version of each.
	 * When copying or restoring an asset, we only want the assets with the newest version, e.g. if
	 * cow.jpg exists both at version 2 and 3, we only want to save the one from version 3, as that's
	 * the one that'd be active in the version we're prototyping from.
	 * @param  {array} assets List of assets.
	 * @return {array}        Filtered list of assets.
	 */
	function filterNewestAssets(assets) {
		var filteredAssets = {};
		assets.forEach(function(asset) {
			if (!filteredAssets[asset.originalFileName] ||
				filteredAssets[asset.originalFileName].v < asset.v) {
				filteredAssets[asset.originalFileName] = asset;
			}
		});
		return Object.keys(filteredAssets).map(function(key) {
			return filteredAssets[key];
		});
	}

	/**
	 * Add asset uploaded to the database.
	 * This is called when a file is uploaded by the AssetManager, and is therefore private. If an
	 * asset name already exists with the specific name at the current version, a random string is
	 * added to the file name.
	 * @param {string}   webstrateId WebstrateId.
	 * @param {obj}      asset       Asset information.
	 * @param {Function} next        Callback.
	 * @private
	 */
	function addAsset(webstrateId, asset, source, next) {
		return documentManager.sendNoOp(webstrateId, "assetAdded", source, function() {
			return documentManager.getDocumentVersion(webstrateId, function(err, version) {
				db.assets.insert({
					webstrateId,
					v: version,
					fileName: asset.filename,
					originalFileName: asset.originalname,
					fileSize: asset.size,
					mimeType: asset.mimetype
				}, function(err) {
					if (err) return next && next(err);

					asset = {
						v: version,
						fileName: asset.originalname,
						fileSize: asset.size,
						mimeType: asset.mimetype,
						identifier: asset.filename
					};

					// Inform all clients of the newly added asset.
					clientManager.sendToClients(webstrateId, {
						wa: "asset",
						d: webstrateId,
						asset: asset
					});

					return next && next(null, asset);
				});
			});
		});
	};

	/**
	 * Filter Multer file uploads to ensure that the webstrate exists and that the user has the
	 * appropriate permissions.
	 * @param  {obj}      req  Express Request object.
	 * @param  {obj}      file Multer file object.
	 * @param  {Function} next Callback.
	 * @return {bool}          (async) Whether the file is permitted to be uploaded or not.
	 * @private
	 */
	function fileFilter(req, file, next) {
		return documentManager.getDocument({ webstrateId: req.webstrateId }, function(err, snapshot) {
			if (err) {
				return next(err);
			}

			if (!snapshot.type) {
				return next(new Error("Document doesn't exist."));
			}

			var permissions = permissionManager.getUserPermissionsFromSnapshot(req.user.username,
				req.user.provider, snapshot);

			if (!permissions.includes("w")) {
				return next(new Error("Insufficient permissions."));
			}

			return next(null, true);
		});
	};

	return module;
};