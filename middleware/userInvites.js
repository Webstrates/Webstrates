'use strict';
/* Middleware for inviting users to your webstrate */

const db = require(APP_PATH + '/helpers/database.js');
const crypto = require('crypto');
const permissionManager = require(APP_PATH + '/helpers/PermissionManager.js');

exports.onmessage = async (ws, req, data, next) => {
	const adminAPI = {
		/**
		 * Creates a new invite key for the given webstrateId with the given permissions and
		 * maximum lifetime of the invite.
		 * 
		 * @returns An object containing the key
		 */
		createInvite: async ()=>{
			const inviteKey = crypto.randomBytes(32).toString('hex'); // Generate a random hex key
			const expiresAt = new Date();
			const ageLimit = 3600 * 24 * 30; // One month limit
			const maxAge = Math.min(data.options.maxAge, ageLimit);
			const invitePermissions = data.options.permissions;
			expiresAt.setSeconds(expiresAt.getSeconds() + maxAge); // Set expiration X days from now
			
			const inviteDocument = {
				key: inviteKey,
				webstrateId: webstrateId,
				permissions: invitePermissions,
				expiresAt: expiresAt,
				createdAt: new Date(),
				createdBy: {username: req.user.username, provider: req.user.provider}
			};
			
			await db.invites.insertOne(inviteDocument);
			return inviteDocument;			
		},
		/**
		 * Get the currently active invites generated by the logged in user for the given webstrateId.
		 * 
		 * @returns A list of objects describing the keys
		 */
		getInvites: async ()=>{
			return await db.invites.find({
				webstrateId: webstrateId,
				'createdBy.username': req.user.username,
				'createdBy.provider': req.user.provider,
			}).toArray();
		},
		/**
		 * Delete an invite by key for the given webstrateId. The invite must have been generated by
		 * the logged-in user.
		 */
		removeInvite: async ()=>{
			let result = await db.invites.deleteMany({
				webstrateId: webstrateId,
				key: data.options.key,
				'createdBy.username': req.user.username,
				'createdBy.provider': req.user.provider,
			});
			if (result.deletedCount!=1) throw new Error("Unable to delete invite");
			return result;
		}		
	}

	const inviteeAPI = {
		/**
		 * Validates if an invite key can be used by the currently logged-in user for the given
		 * webstrateId and key.
		 * 
		 * @returns An object with the invite information if still valid
		 */
		checkInvite: async ()=>{
			let invite = await db.invites.findOne({
				webstrateId: webstrateId,
				key: data.options.key,
			});
			if (!invite) throw new Error("Invalid invitation key");

			// Check inviting admin is still admin
			const inviterPermissions = await permissionManager.getUserPermissions(
				invite.createdBy.username, invite.createdBy.provider, webstrateId);
			if (!inviterPermissions.includes('a')) throw new Error("Inviter is no longer admin on the webstrate, invitation invalid");

			return invite;
		},
		/**
		 * Activates the invitation, adding the logged-in user to the given webstrateId's list
		 * of authorized users with the permissions from the invite.
		 * 
		 * @returns 
		 */
		acceptInvite: async ()=>{
			// Check invite
			let invite = await inviteeAPI.checkInvite();

			// Update existing invitee permissions on webstrate by merging with the granted permissions
			let newPermissions = [...new Set(currentUserPermissions+invite.permissions)].join('');
			await permissionManager.setUserPermissions(req.user.username, req.user.provider,
				newPermissions, webstrateId, invite.createdBy.username+":"+invite.createdBy.provider);
			return newPermissions;
		}
	}

	// Check if request is for this module at all
	const fullAPI = Object.assign({}, adminAPI, inviteeAPI);
	if ((!data.wa)||!Object.keys(fullAPI).includes(data.wa)) return next();

	const webstrateId = data.d;
	const responseObj = {
		wa: 'reply',
		token: data.token
	}
	const currentUserPermissions = await permissionManager.getUserPermissions(req.user.username, req.user.provider,
		webstrateId);	

	// Expire all out-of-date invites before attempting to handle the request
	const deleteResult = await db.invites.deleteMany({
		expiresAt: {
			$lte: new Date()
		}
	});	

	// Create a reply
	try {
		// Require admin user or at least normal logged-in user depending on action
		if (!req.user.provider) throw new Error("Must be logged in to handle invites");
		if (Object.keys(adminAPI).includes(data.wa) && !currentUserPermissions.includes('a')){
			throw new Error('Need admin permissions to manage invites, '+req.user.userId+" only has "+currentUserPermissions+ " on "+webstrateId);
		};

		return ws.send(JSON.stringify({...responseObj, reply: await fullAPI[data.wa]()}));
	} catch (ex){
		return ws.send(JSON.stringify({...responseObj, error: ex.message}));
	}
};