{"version":3,"sources":["webpack:///webpack/bootstrap 38334a504b5cfa9c759e","webpack:///./client/webstrates/coreEvents.js","webpack:///./client/webstrates/coreUtils.js","webpack:///./client/webstrates/coreWebsocket.js","webpack:///./client/webstrates/globalObject.js","webpack:///./client/config.js","webpack:///./client/webstrates/loadedEvent.js","webpack:///./client/webstrates/coreDatabase.js","webpack:///./client/debug.js","webpack:///./client/webstrates/coreJsonML.js","webpack:///./client/webstrates/corePathTree.js","webpack:///./~/node-libs-browser/~/timers-browserify/main.js","webpack:///./client/webstrates/coreMutation.js","webpack:///./client/webstrates/corePopulator.js","webpack:///./client/webstrates/userObject.js","webpack:///./~/process/browser.js","webpack:///./client/webstrates/coreOpApplier.js","webpack:///./client/webstrates/coreOpCreator.js","webpack:///./client/webstrates/nodeObjects.js","webpack:///./client/webstrates/signaling.js","webpack:///./~/sharedb/lib/emitter.js","webpack:///./~/sharedb/lib/error.js","webpack:///./~/sharedb/lib/types.js","webpack:///./client/webstrates/assets.js","webpack:///./client/webstrates/clientManager.js","webpack:///./client/webstrates/connectionEvents.js","webpack:///./client/webstrates/cookies.js","webpack:///./client/webstrates/domEvents.js","webpack:///./client/webstrates/keepAlive.js","webpack:///./client/webstrates/permissions.js","webpack:///./client/webstrates/signalStream.js","webpack:///./client/webstrates/tagging.js","webpack:///./client/webstrates/transclusionEvent.js","webpack:///./~/ot-json0/lib/bootstrapTransform.js","webpack:///./~/sharedb/lib/client/doc.js","webpack:///./~/sharedb/lib/client/index.js","webpack:///./~/sharedb/lib/client/query.js","webpack:///./client/webstrates ^\\.\\/.*$","webpack:///./client/index.js","webpack:///./~/diff-match-patch/index.js","webpack:///./~/events/events.js","webpack:///./~/make-error/index.js","webpack:///./~/ot-json0/lib/index.js","webpack:///./~/ot-json0/lib/json0.js","webpack:///./~/ot-json0/lib/text0.js","webpack:///./~/setimmediate/setImmediate.js","webpack:///./~/sharedb/lib/client/connection.js","webpack:///./~/sharedb/lib/util.js","webpack:///(webpack)/buildin/global.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;2DChEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC,KAAK;AAC3C;AACA,CAAC;;AAED;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD;AACvD;AACA;AACA,2BAA2B,UAAU;AACrC;;AAEA;AACA;AACA,gEAAgE,oBAAoB;AACpF;AACA;AACA;;AAEA;AACA;AACA,mEAAmE,uBAAuB;AAC1F;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,UAAU;AACrC;;AAEA;AACA,uDAAuD,UAAU;AACjE;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,UAAU;AACrC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;AACF;;AAEA,kC;;;;;;;;ACnHA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,IAAI;AAChB,YAAY,KAAK;AACjB;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,IAAI;AAChB;AACA;AACA,uDAAuD;;AAEvD;AACA;AACA,YAAY,IAAI;AAChB,YAAY,IAAI;AAChB,YAAY,IAAI;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,8BAA8B;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;;AAEA,iC;;;;;;;6CCxQA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;AAC/B;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA,YAAY,SAAS;AACrB;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA,qC;;;;;;;;oDClLA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,wDAAwD,EAAE;AACvE;AACA,CAAC;;AAED;AACA;AACA;AACA,aAAa,mDAAmD,EAAE;AAClE;AACA,CAAC;;AAED;AACA;AACA,aAAa,iDAAiD,EAAE;AAChE;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAyD;AACzD;AACA,2BAA2B,UAAU;AACrC;;AAEA;AACA;AACA,gEAAgE,oBAAoB;AACpF;AACA;AACA;;AAEA;AACA;AACA,mEAAmE,uBAAuB;AAC1F;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA,CAAC,iCAAiC;;AAElC;AACA,oC;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,wCAAwC;AAC5C,IAAI;AACJ;AACA;AACA,E;;;;;;;2DClCA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAED,mC;;;;;;;;AC9DA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,cAAc,IAAI;AAClB,cAAc,KAAK;AACnB,yEAAyE;;AAEzE;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qDAAqD,gBAAgB;;AAErE;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,IAAI;;AAEJ;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA,GAAG,GAAG,oBAAoB;AAC1B,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA,oC;;;;;;AC/HA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,6B;;;;;;;;AC7BA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,OAAO,iBAAiB;AACxB;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,WAAW,SAAS;AACpB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;;AAEA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,eAAe,qBAAqB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,4B;;;;;;;8CCpVA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,WAAW,KAAK;AAChB;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA,4DAA4D,SAAS;AACrE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA,YAAY,WAAW;AACvB,YAAY,mCAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,0B;;;;;;;ACzRA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACpDA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;;AAEA;AACA,EAAE;AACF;;AAEA;AACA;AACA,kBAAkB,iBAAiB;AACnC,CAAC;;;AAGD;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA,8B;;;;;;;AC/HA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,YAAY;AAC/D;AACA,IAAI;AACJ;AACA;;AAEA;AACA,SAAS,0BAA0B,gDAAgD,EAAE;AACrF,SAAS,4BAA4B,cAAc,gBAAgB,IAAI;AACvE;AACA;;AAEA;AACA;AACA,uCAAuC,cAAc;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA,+B;;;;;;;AC9DA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA,wEAAwE;;AAExE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kC;;;;;;AC9BA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;8CCnLtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,mBAAmB;AAC9D,+CAA+C,mBAAmB;AAClE,2CAA2C,mBAAmB;AAC9D,0CAA0C,mBAAmB;AAC7D,qDAAqD,mBAAmB;AACxE,gDAAgD,mBAAmB;AACnE,oDAAoD,mBAAmB;AACvE,+CAA+C,mBAAmB;;AAElE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX,EAAE;AACF;;AAEA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,GAAG;AACf,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,EAAE;AACF;;AAEA;;;;;;;;;qDCrcA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,2CAA2C,mBAAmB;AAC9D,+CAA+C,mBAAmB;AAClE,2CAA2C,mBAAmB;AAC9D,0CAA0C,mBAAmB;AAC7D,qDAAqD,mBAAmB;AACxE,gDAAgD,mBAAmB;AACnE,oDAAoD,mBAAmB;AACvE,+CAA+C,mBAAmB;;AAElE;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,WAAW;AACvB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,IAAI;AAChB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA,eAAe,kCAAkC;AACjD;AACA;AACA;AACA;AACA,wDAAwD,KAAK;AAC7D;AACA,GAAG;AACH,EAAE;;AAEF;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;;AAEA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,0DAA0D;AAC1D;AACA,sDAAsD;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAA+D;AAChF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED,+B;;;;;;;;oDC5UA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,KAAK;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mDAAmD,EAAE;AACpE;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,UAAU,oBAAoB,KAAK;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA,6BAA6B,UAAU;AACvC;;AAEA;AACA;AACA,kEAAkE,oBAAoB;AACtF;AACA;AACA;;AAEA;AACA;AACA,qEAAqE,uBAAuB;AAC5F;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA,6BAA6B,UAAU,oBAAoB,KAAK;AAChE;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED,mC;;;;;;;;6CChKA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,sEAAsE;;AAEtE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED;;AAEA;;;;;;;;;AC3IA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;ACTA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;;;;;;ACRA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;ACVA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,wEAAwE;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB;AACA;AACA;;AAEA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA,4DAA4D;AAC5D;AACA;AACA;;AAEA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;;AAEF;AACA;;AAEA,8B;;;;;;;ACnEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wEAAwE;;AAExE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,8BAA8B;AAC/C,CAAC;;;AAGD,qC;;;;;;;AC3DA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,E;;;;;;;ACpCA;AACA;AACA;AACA;;AAEA;;AAEA,wEAAwE;;AAExE;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,cAAc;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA,+B;;;;;;;AClEA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA,CAAC,iC;;;;;;;8CCvGD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC,EAAE;AACF;;AAEA;AACA;AACA,E;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,wEAAwE;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED,mC;;;;;;;4DCrHA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA,KAAK;AACL,IAAI;AACJ;AACA,IAAI;;AAEJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA,MAAM;AACN,KAAK;AACL;AACA,KAAK;AACL,IAAI;AACJ;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;AAED,oC;;;;;;;;AC5RA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iCAAiC;;AAEjC,sEAAsE;;AAEtE;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,yCAAyC;AACvD,CAAC;;AAED;AACA;AACA,YAAY,IAAI;AAChB;AACA;AACA;;AAEA,+B;;;;;;;ACpMA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;;;;;;;ACnED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC7EA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,SAAS,IAAI;AACrC;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,iCAAiC,4BAA4B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC74BA;AACA;AACA;AACA;AACA;;;;;;;ACJA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mEAAmE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uB;;;;;;;8CClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uBAAuB,SAAS,IAAI,cAAc;;AAElD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA,iC;;;;;;;;AChDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,sBAAsB;AACrC;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA,WAAW,OAAO;AAClB,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,iBAAiB;AAChD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,oBAAoB;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;;;AAGA;AACA;AACA;AACA,WAAW,gCAAgC;AAC3C,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA,sBAAsB;AACtB,2BAA2B;AAC3B,aAAa,QAAQ;AACrB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA;AACA,sBAAsB;AACtB,2BAA2B;AAC3B,aAAa,QAAQ;AACrB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,gCAAgC;AAC3C;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,gCAAgC;AAC3C,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kBAAkB;AAC/B,sCAAsC;AACtC;AACA;AACA,sCAAsC;AACtC;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,gCAAgC;AAC3C,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC,yBAAyB;AACzB,2BAA2B;AAC3B,+CAA+C,4BAA4B;AAC3E,kCAAkC,gCAAgC;AAClE;AACA;AACA,kDAAkD;AAClD;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,gCAAgC;AAC3C,YAAY,OAAO;AACnB;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,gCAAgC;AAC3C,YAAY,OAAO;AACnB;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA,oCAAoC;AACpC;AACA,WAAW,gCAAgC;AAC3C,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,WAAW,gCAAgC;AAC3C,YAAY,OAAO;AACnB;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,gCAAgC;AAC5C,YAAY,OAAO;AACnB;AACA;AACA;AACA,sBAAsB;AACtB,kBAAkB;AAClB;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB;;AAEjB;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA,oBAAoB;AACpB;AACA,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;AACA;AACA,WAAW,4BAA4B;AACvC,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uCAAuC;AAClD;AACA,WAAW,uCAAuC;AAClD;AACA,WAAW,uCAAuC;AAClD;AACA,YAAY,qCAAqC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,uBAAuB,gCAAgC;AACvD;AACA,GAAG;AACH;AACA;AACA,uBAAuB,OAAO;AAC9B,uBAAuB,gCAAgC;AACvD,GAAG;AACH;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,uBAAuB,gCAAgC;AACvD,GAAG;AACH;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA,0BAA0B;AAC1B,sBAAsB;AACtB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA,WAAW,qCAAqC;AAChD,YAAY,qCAAqC;AACjD;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,qCAAqC;AAChD,WAAW,OAAO;AAClB,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,yBAAyB,6BAA6B;AACtD;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,qCAAqC;AAChD,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,kCAAkC;AAClC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,qCAAqC;AAChD;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,qCAAqC;AAChD,YAAY,OAAO;AACnB;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA;AACA;AACA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,qCAAqC;AACjD,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,aAAa,gCAAgC;AAC7C;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChpEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC7SA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;;AAE/B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;AC7IA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;ACNA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,iBAAiB,eAAe;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,+BAA+B;AAC/B,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,iBAAiB,gBAAgB;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,UAAU;AAC3B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kCAAkC,OAAO;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;ACvpBA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,eAAe;AACpB,KAAK,eAAe;AACpB;AACA;AACA;AACA;AACA;AACA,OAAO,aAAa;AACpB;AACA,OAAO,WAAW,GAAG,WAAW,GAAG,WAAW;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,iCAAiC;;AAEjC,KAAK;AACL;AACA,iCAAiC;;AAEjC,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,MAAM,eAAe;AACrB;AACA;AACA;AACA;;AAEA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB,0DAA0D;AAC5E,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,sBAAsB,oCAAoC;AAC1D;AACA;AACA;AACA,sBAAsB,+BAA+B;;AAErD,KAAK;AACL;AACA;AACA,sBAAsB,iCAAiC;AACvD;AACA;AACA;AACA;AACA,oBAAoB;;AAEpB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,0BAA0B,aAAa,IAAI;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;;AAEA;;;;;;;AC/PA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C,sBAAsB,EAAE;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;;;;;;ACzLD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA,mBAAmB;AACnB;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,KAAK;AACL;;AAEA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gCAAgC;AAC/C,GAAG;AACH,eAAe,uCAAuC;AACtD;AACA;AACA;AACA,eAAe,mDAAmD;AAClE,GAAG;AACH,eAAe,4CAA4C;AAC3D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E,2DAA2D;AAC3D;AACA;AACA;AACA,GAAG;AACH;AACA,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChkBA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;ACPA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C","file":"webstrates.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 37);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 38334a504b5cfa9c759e","'use strict';\nconst coreEventsModule = {};\n\n// Map from event names to a set of the actual listeners: string -> set of listeners.\nconst eventListeners = {};\n// Map from event names to actual listeners: string -> function.\nconst addEventListenerListeners = {};\n// Map from event names to actual listeners: string -> function.\nconst removeEventListenerListeners = {};\n\nconst priorities = {\n\tIMMEDIATE: 0,\n\tHIGH: 1,\n\tMEDIUM: 2,\n\tLOW: 3,\n\tLAST: 4\n};\n\ncoreEventsModule.PRIORITY = new Proxy(priorities, {\n\tget: (target, name) => {\n\t\tif (name in target) return target[name];\n\t\tthrow new Error(`Invalid priority ${name}`);\n\t}\n});\n\n/**\n * Create new event.\n * @param  {string}  eventName  Event name.\n * @param  {object} options     An object of options:\n *                              idempotent:      Whether we allow the same event to be created\n *                                               multiple times without throwing an error.\n *                              addListener:     A callback to be triggered when an eventListener\n *                                               gets added.\n *                              removeListener:  A callback to be triggered when an eventListener\n *                                               gets added.\n\n * @public\n */\ncoreEventsModule.createEvent = (eventName, options = {}) => {\n\tdebug.log('createEvent', eventName, options);\n\tif (typeof eventListeners[eventName] !== 'undefined' && !options.idempotent) {\n\t\tthrow new Error(`Event ${eventName} already exists.`);\n\t}\n\n\tif (typeof options.addListener !== 'undefined') {\n\t\tif (typeof options.addListener !== 'function') {\n\t\t\tthrow new Error(`addListener must be a function, received: ${options.addListener}.`);\n\t\t}\n\t\taddEventListenerListeners[eventName] = options.addListener;\n\t}\n\n\tif (typeof options.removeListener !== 'undefined') {\n\t\tif (typeof options.removeListener !== 'function') {\n\t\t\tthrow new Error(`removeListener must be a function, received: ${options.removeListener}.`);\n\t\t}\n\t\tremoveEventListenerListeners[eventName] = options.removeListener;\n\t}\n\n\teventListeners[eventName] = new Set();\n};\n\ncoreEventsModule.eventExists = (eventName) => eventListeners.hasOwnProperty(eventName);\n\ncoreEventsModule.addEventListener = (eventName, eventListener,\n\tpriority = coreEventsModule.PRIORITY.LOW) => {\n\tdebug.log('addEventListener', eventName, priority);\n\n\teventListener.priority = priority;\n\tif (typeof eventListeners[eventName] === 'undefined') {\n\t\tthrow new Error(`Event ${eventName} doesn't exist.`);\n\t}\n\n\tif (eventListeners[eventName].has(eventListener)) {\n\t\tthrow new Error(`EventListener already attacehd to ${eventName}.`);\n\t}\n\teventListeners[eventName].add(eventListener);\n\tif (addEventListenerListeners[eventName]) {\n\t\taddEventListenerListeners[eventName](eventListener);\n\t}\n\n};\n\ncoreEventsModule.removeEventListener = (eventName, eventListener) => {\n\tdebug.log('removeEventListener', eventName);\n\tif (typeof eventListeners[eventName] === 'undefined') {\n\t\tthrow new Error(`Event ${eventName} doesn't exist.`);\n\t}\n\teventListeners[eventName].delete(eventListener);\n\tif (removeEventListenerListeners[eventName]) {\n\t\tremoveEventListenerListeners[eventName](eventListener);\n\t}\n};\n\ncoreEventsModule.triggerEvent = (eventName, ...args) => {\n\tdebug.log('triggerEvent', eventName, args);\n\tif (typeof eventListeners[eventName] === 'undefined') {\n\t\tthrow new Error(`Event ${eventName} doesn't exist.`);\n\t}\n\n\t// Convert set of event listeners to array, so we can sort them.\n\tconst arrEventListeners = Array.from(eventListeners[eventName]);\n\n\t// Sort all events by priority\n\tarrEventListeners.sort((e, f) => e.priority - f.priority);\n\n\t// Execute events (in proper order)\n\tarrEventListeners.forEach(eventListener => {\n\t\tif (eventListener.priority === coreEventsModule.PRIORITY.IMMEDIATE) {\n\t\t\teventListener(...args);\n\t\t} else {\n\t\t\tsetImmediate(eventListener, ...args);\n\t\t}\n\t});\n};\n\nmodule.exports = coreEventsModule;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreEvents.js\n// module id = 0\n// module chunks = 0","'use strict';\nconst coreUtilsModule = {};\n\nlet locationObject;\n/**\n * Parses a query string and returns a more friendly object.\n * @param  {Location} location Location object.\n * @return {object}            Object with webstrateId, tagOrVersion and parameters.\n */\ncoreUtilsModule.getLocationObject = () => {\n\tif (locationObject) {\n\t\treturn locationObject;\n\t}\n\n\tconst pathRegex = /^\\/([A-Z0-9\\._-]+)\\/(?:([A-Z0-9_-]+)\\/)?/i.exec(window.location.pathname);\n\tconst [ , webstrateId, tagOrVersion] = pathRegex;\n\n\tconst parameters = {};\n\tconst queryRegex =  /([^&=]+)=?([^&]*)/g;\n\tconst query = window.location.search.substring(1);\n\n\tlet match;\n\twhile ((match = queryRegex.exec(query))) {\n\t\tconst [, key, value] = match;\n\t\tparameters[key] = decodeURIComponent(value);\n\t}\n\n\tlet tag, version;\n\tif (/^\\d/.test(tagOrVersion) && Number(tagOrVersion)) {\n\t\tversion = Number(tagOrVersion);\n\t} else {\n\t\ttag = tagOrVersion;\n\t}\n\n\tlocationObject = {\n\t\twebstrateId,\n\t\tstaticMode: !!tagOrVersion,\n\t\ttagOrVersion,\n\t\ttag, version, // Only one of tag/version will be set\n\t\tparameters\n\t};\n\n\treturn locationObject;\n};\n\n/**\n * Checks for literal equality of objects. This is a stupid way, but it works.\n * @param  {obj} a First object to compare.\n * @param  {obj} b Second object to compare.\n * @return {bool}  True if objects are equal.\n * @public\n */\ncoreUtilsModule.objectEquals = (a, b) => JSON.stringify(a) === JSON.stringify(b);\n\n/**\n * Shallow clones an object.\n * @param  {obj} obj Object to be copied.\n * @return {obj}     Shallow clone.\n * @public\n */\ncoreUtilsModule.objectClone = (obj) => Object.assign({}, obj);\n\n/**\n * Get random integer from interval [min, max). Unbiased and evenly distributed (or close to).\n * @param  {int} min Minimum number, inclusive.\n * @param  {int} max Maximum number, exclusive.\n * @return {int}     Random number in interval [min, max)\n * @public\n */\ncoreUtilsModule.random = (min, max) => {\n\treturn Math.floor(min + Math.random() * (max - min));\n};\n\n/**\n * Get random string of size.\n * @param  {int}    size     Expected length of string (optional).\n * @param  {string} alphabet List of characters to be used in string (optional).\n * @return {string}          Generated string.\n * @public\n */\ncoreUtilsModule.randomString = (size = 8,\n\t// Does not include 0, O, o, 1, I, l for readability.\n\talphabet = '23456789abcdefghijkmnpqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ') => {\n\tconst len = alphabet.length;\n\tlet str = '';\n\twhile (size--) {\n\t\tstr += alphabet[coreUtilsModule.random(0, len)];\n\t}\n\treturn str;\n};\n\n/**\n * Get child nodes of an element. If the element is a fragment, get the content's child nodes.\n * @param  {DOMElement} parentElement Element to get child nodes of.\n * @return {array}                    List of child nodes.\n */\ncoreUtilsModule.getChildNodes = function(parentElement) {\n\tif (parentElement.content && parentElement.content === document.DOCUMENT_FRAGMENT_NODE) {\n\t\tparentElement = parentElement.content;\n\t}\n\treturn parentElement.childNodes;\n};\n\n/**\n * Traverses a node tree and applies a callback to each node.\n * @param {DOMNode}  node     Node tree to traverse.\n * @param {DOMNode}  parent   Initial parent node.\n * @param {Function} callback Callback.\n * @public\n */\ncoreUtilsModule.recursiveForEach = function(node, callback, parent = null) {\n\tcallback(node, parent);\n\n\tArray.from(coreUtilsModule.getChildNodes(node)).forEach(child => {\n\t\tcoreUtilsModule.recursiveForEach(child, callback, node);\n\t});\n};\n\n/**\n * Append a DOM element childElement to another DOM element parentElement. If the DOM element to\n * be appended is a script, prevent the execution of the script. If the parentElement is a\n * <template>, add the child to the parentElement's documentFragment instead. If a referenceNode\n * is specified, the element is inserted before the referenceNode.\n * @param {DOMNode} parentElement Parent element.\n * @param {DOMNode} childElement  Child element.\n * @public\n */\ncoreUtilsModule.appendChildWithoutScriptExecution = (parentElement, childElement,\n\treferenceNode) => {\n\t// Remove all children, so we can later insert them. This way, we can prevent script execution.\n\tconst childElementsChildren = [];\n\twhile (childElement.firstChild) {\n\t\tchildElementsChildren.push(childElement.removeChild(childElement.firstChild));\n\t}\n\n\t// To prevent scripts from being executed when inserted, we use a little hack. Before inserting\n\t// the script, we replace the actual script with dummy content, causing that to be executed\n\t// instead of the actual script. If it's an inline script, we insert a script with dummy content\n\t// (\"// Execution prevention\"), and then replace the innerHTML afterwards. If the script is from\n\t// an external resource, set the src attribute \"about:blank\", and then set it to the actual src.\n\t// This way, only \"about:blank\" will be loaded.\n\t// To prevent issues with any other attributes (e.g. crossorigin and integrity), we also remove\n\t// all those attributes and insert them later.\n\tif (childElement instanceof HTMLScriptElement) {\n\t\t// Save all attributes and innerHTML.\n\t\tconst attrs = [];\n\t\tArray.from(childElement.attributes).forEach(function(attr) {\n\t\t\tattrs.push([ attr.nodeName, attr.nodeValue ]);\n\t\t\tchildElement.removeAttribute(attr.nodeName);\n\t\t});\n\n\t\tconst innerHTML = childElement.innerHTML;\n\t\tchildElement.innerHTML = '// Execution prevention';\n\n\t\t// Now insert a bare script (dummy content and empty src).\n\t\tparentElement.insertBefore(childElement, referenceNode || null);\n\n\t\t// And re-add attributes and real content.\n\t\tattrs.forEach(function(attr) {\n\t\t\tconst [nodeName, nodeValue] = attr;\n\t\t\tchildElement.setAttribute(nodeName, nodeValue);\n\t\t});\n\t\tchildElement.innerHTML = innerHTML;\n\t} else {\n\t\t// If parentElement.content exists, parentElement contains a documentFragment, and we should\n\t\t// be adding the content to this documentFragment instead. This happens when parentElement is\n\t\t// a <template>.\n\t\tif (parentElement.content &&\n\t\t\tparentElement.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {\n\t\t\tparentElement = parentElement.content;\n\t\t}\n\t\tparentElement.insertBefore(childElement, referenceNode || null);\n\t}\n\n\tlet childElemensChild;\n\twhile ((childElemensChild = childElementsChildren.shift())) {\n\t\tcoreUtilsModule.appendChildWithoutScriptExecution(childElement, childElemensChild);\n\t}\n};\n\n/**\n * Reinsert and execute an array of scripts in order.\n * @param {array}    scripts  Array of script DOM elements.\n * @param {Function} callback Function to call once all scripts have been executed.\n * @public\n */\ncoreUtilsModule.executeScripts = (scripts, callback) => {\n\tvar script = scripts.shift();\n\tif (!script) {\n\t\treturn callback();\n\t}\n\n\tvar executeImmediately = !script.src;\n\tvar newScript = document.createElementNS(script.namespaceURI, 'script');\n\tif (!executeImmediately) {\n\t\tnewScript.onload = newScript.onerror = function() {\n\t\t\tcoreUtilsModule.executeScripts(scripts, callback);\n\t\t};\n\t}\n\n\t// Copy over all attribtues.\n\tfor (var i = 0; i < script.attributes.length; i++) {\n\t\tvar attr = script.attributes[i];\n\t\tnewScript.setAttribute(attr.nodeName, attr.nodeValue);\n\t}\n\n\t// Copy over all other properties.\n\tObject.assign(newScript, script);\n\n\t// We're defining the wid with defineProperty to make it non-modifiable, but assign will just copy\n\t// over the value, leaving it modifiable otherwise.\n\tcoreUtilsModule.setWidOnElement(newScript, script.__wid);\n\n\tnewScript.innerHTML = script.innerHTML;\n\n\tscript.parentElement.insertBefore(newScript, script);\n\tscript.remove();\n\n\tif (executeImmediately) {\n\t\tcoreUtilsModule.executeScripts(scripts, callback);\n\t}\n};\n\n/**\n * Removes characters that are illegal in attributes and tag names.\n * @param  {string} tagName Unsanitized string.\n * @return {string}         Sanitized string.\n * @public\n */\ncoreUtilsModule.sanitizeString = (string) => {\n\t// See https://www.w3.org/TR/html5/syntax.html#syntax-tag-name and\n\t// https://www.w3.org/TR/html5/syntax.html#syntax-attribute-name\n\tvar NAME_START_CHAR_REGEX = /\\:|[A-Z]|\\_|[a-z]/;\n\tvar NAME_CHAR_REGEX = /\\-|\\.|[0-9]/;\n\n\treturn string.split('').map(function(char, index) {\n\t\tif (NAME_START_CHAR_REGEX.test(char) || (index > 0 && NAME_CHAR_REGEX.test(char))) {\n\t\t\treturn char;\n\t\t}\n\t\treturn '_';\n\t}).join('');\n};\n\nconst widMap = new Map();\n/**\n * Add a wid to a node and make it (easily) non-modifiable.\n * @param  {DOMNode} node Node to set wid on.\n * @param  {string} wid  wid.\n * @public\n */\ncoreUtilsModule.setWidOnElement = (node, wid) => {\n\twidMap.set(wid, node);\n\tObject.defineProperty(node, '__wid', {\n\t\tvalue: wid,\n\t\twritable: false, // No overwriting\n\t\tenumerable: true, // Let iterators and Object.assign see the wid.\n\t\tconfigurable: true // Allow us to redefine it in rare race condition scenarios.\n\t});\n};\n\ncoreUtilsModule.getElementByWid = (wid) => {\n\treturn widMap.get(wid);\n};\n\nmodule.exports = coreUtilsModule;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreUtils.js\n// module id = 1\n// module chunks = 0","'use strict';\nconst coreUtils = require('./coreUtils');\n\nconst coreWebsocketModule = {};\n\nlet url, protocols, websocket, forceClose, reconnectAttempts;\nconst copies = [];\n\n// If somebody tries to send a message with websocket.sendWhenReady while we're not connected, we\n// queue the message to be sent once connected. This is that queue. Once a queue has been drained,\n// we reinitialize it to a new list, so we can't use const.\nlet queue = [];\n\n// A map from tokens to callback functions: str -> fn.\nconst callbacks = new Map();\n\n/**\n * Calculates increasing reconnection delay based on number of reconnection attempts:\n * Starting with: 1s, 1.5s, 2.3s, 3.4s, 5.0s, 7.6s, 11.4s, 17.0s, 25.6s, 38.4s, 57.7s, etc.\n * @return {Number} Next reconnection interval in seconds.\n * @private\n */\nfunction reconnectDelay() {\n\treturn 1000 * Math.pow(1.5, reconnectAttempts++);\n}\n\ncoreWebsocketModule.setup = (_url, _protocols) => {\n\turl = _url;\n\tprotocols = _protocols;\n\twebsocket = new WebSocket(url, protocols);\n\tforceClose = false;\n\n\twebsocket.onopen = event => {\n\t\tdebug.log('Websocket opened', event);\n\n\t\t// Drain queue and empty it.\n\t\tqueue.forEach(data => websocket.send(data));\n\t\tqueue = [];\n\n\t\treconnectAttempts = 0;\n\t\tcopies.forEach(({ websocket }) =>\n\t\t\ttypeof websocket.onopen === 'function' && websocket.onopen(event));\n\t};\n\n\twebsocket.onclose = event => {\n\t\tdebug.log('Websocket closed', event);\n\t\tcopies.forEach(({ websocket }) =>\n\t\t\ttypeof websocket.onclose === 'function' && websocket.onclose(event));\n\n\t\tif (!forceClose) {\n\t\t\treconnectAttempts++;\n\t\t\tsetTimeout(() => {\n\t\t\t\tcoreWebsocketModule.setup(url, protocols);\n\t\t\t}, reconnectDelay());\n\t\t}\n\t};\n\n\twebsocket.onconnecting = event => {\n\t\tdebug.log('Websocket connecting', event);\n\t\tcopies.forEach(({ websocket }) =>\n\t\t\ttypeof websocket.onconnecting === 'function' && websocket.onconnecting(event));\n\t};\n\n\twebsocket.onmessage = event => {\n\t\tdebug.log('Websocket message', event);\n\t\tlet parsedData;\n\n\t\t// If the message has a reply attached, it means it's an answer to a specific request, and not\n\t\t// something that should just be sent to everybody. Therefore, we find the requester in the\n\t\t// callback map, call the callback function, and then terminate.\n\t\tif (event.data.startsWith('{\"wa\":\"reply\"')) {\n\t\t\tparsedData = JSON.parse(event.data);\n\t\t\tconst token = parsedData.token;\n\t\t\tif (token && callbacks.has(token)) {\n\t\t\t\tconst callback = callbacks.get(token);\n\t\t\t\tcallbacks.delete(token);\n\t\t\t\tcallback(parsedData.reply);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tcopies.forEach(({ websocket, filter }) => {\n\t\t\tif (!filter || filter(event)) {\n\t\t\t\tif (typeof websocket.onmessage === 'function') {\n\t\t\t\t\twebsocket.onmessage(event);\n\t\t\t\t}\n\t\t\t\t// As an optimization, we add a custom onjsonmessage event to websockets, so every websocket\n\t\t\t\t// copy doesn't have to parse the same data.\n\t\t\t\tif (typeof websocket.onjsonmessage === 'function') {\n\t\t\t\t\tif (parsedData === undefined) {\n\t\t\t\t\t\tparsedData = Object.freeze(JSON.parse(event.data));\n\t\t\t\t\t}\n\t\t\t\t\twebsocket.onjsonmessage(parsedData);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\twebsocket.onerror = event => {\n\t\tdebug.log('Websocket error', event);\n\t\tcopies.forEach(({ websocket }) =>\n\t\t\ttypeof websocket.onerror === 'function' && websocket.onerror(event));\n\t};\n};\n\n/**\n * Get a copy of the websocket, allowing modules to treat it like their own and overwrite onopen,\n * onmessage, etc. without fear of overwriting other modules' callbacks.\n * @param  {function} filter A filter function, allowing users to filter messages before receiving\n *                           them.\n * @return {WebSocket}       A WebSocket (almost up to specification).\n * @public\n */\ncoreWebsocketModule.copy = filter => {\n\tconst copy = {\n\t\tsend: coreWebsocketModule.send,\n\t\tclose: () => {\n\t\t\tforceClose = true;\n\t\t\twebsocket.close();\n\t\t},\n\t\trefresh: () => {\n\t\t\twebsocket.close();\n\t\t},\n\t\turl: url,\n\t\tURL: url,\n\t\tprotocols: protocols,\n\t\tget readyState() {\n\t\t\treturn websocket.readyState;\n\t\t}\n\t};\n\tcopies.push({ websocket: copy, filter });\n\treturn copy;\n};\n\n/**\n * Send messages through the websocket. This is possible both directly through coreWebsocket.send\n * (as defined here) or through a websocket copy. Some modules may not need the websocket for more\n * than sending a message, in which case there's no reason to create a copy.\n * The method signature does not exactly adhere to the specification.\n * @param  {mixed}   data      The data to be sent. According to the specification, this should be\n *                             string, but we allow objects as well, which we then stringify.\n * @param  {Function} callback A callback function to be called when the server replies to the\n *                             message. This is done by attaching a token to the message and having\n *                             the server reply with the same token.\n * @param  {Object}   options  Allows setting certain properties. Currently only `waitForOpen`.\n *                             When set, if somebody tries to send a message over the websocket\n *                             before it has been opened, the message gets queued to be sent once\n *                             connected.\n * @public\n */\ncoreWebsocketModule.send = (data, callback, options = {}) => {\n\t// Allow the user to specify a callback to be called when the server replies. This requires\n\t// the server to implment the token functionality as well, so it must be used with care, as\n\t// not all type of messages can handle callbacks.\n\tif (typeof callback === 'function') {\n\t\tif (typeof data === 'string') {\n\t\t\tdata = JSON.parse(data);\n\t\t}\n\t\tconst token = coreUtils.randomString();\n\t\tdata.token = token;\n\t\tcallbacks.set(token, callback);\n\t}\n\n\t// If we attempt to send an object, we convert it to JSON first. This isn't part of the\n\t// WebSocket specification, but it's nice to have.\n\tif (typeof data === 'object') {\n\t\tdata = JSON.stringify(data);\n\t}\n\n\t// Always send the message if we can. If we can't, try anyway, or if waitForOpen is specified,\n\t// add it to a queue for it to be sent later.\n\tif (websocket.readyState === WebSocket.OPEN || !options.waitForOpen) {\n\t\twebsocket.send(data);\n\t} else {\n\t\tqueue.push(data);\n\t}\n};\n\nmodule.exports = coreWebsocketModule;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreWebsocket.js\n// module id = 2\n// module chunks = 0","'use strict';\n//const coreEvents = require('./coreEvents');\nconst coreDatabase = require('./coreDatabase');\nconst corePopulator = require('./corePopulator');\nconst coreUtils = require('./coreUtils');\n\nconst globalObjectModule = {};\n\n// Public webstrate object\nconst publicObject = {};\n\nObject.defineProperty(publicObject, 'webstrateId', {\n\tget: () => coreUtils.getLocationObject().webstrateId,\n\tset: () => { throw new Error('webstrate ID should not be modified'); },\n\tenumerable: true\n});\n\n// Every webstrate object needs a unique ID. Let's just go with 'document' for the global object.\nObject.defineProperty(publicObject, 'id', {\n\tget: () => 'document',\n\tset: () => { throw new Error('node ID should not be modified'); },\n\tenumerable: true\n});\n\nObject.defineProperty(publicObject, 'isStatic', {\n\tget: () => coreUtils.getLocationObject().staticMode,\n\tset: () => { throw new Error('isStatic cannot be modified.'); },\n\tenumerable: true\n});\n\nglobalObjectModule.publicObject = publicObject;\n\n// Map from event names to a set of the actual listeners: string -> set of listeners.\nconst eventListeners = {};\n// Map from event names to actual listeners: string -> function.\nconst addEventListenerListeners = {};\n// Map from event names to actual listeners: string -> function.\nconst removeEventListenerListeners = {};\n\nglobalObjectModule.createEvent = (eventName, options = {}) => {\n\tif (typeof eventListeners[eventName] !== 'undefined' && !options.idempotent) {\n\t\tthrow new Error(`Event ${eventName} already exists.`);\n\t}\n\n\tif (typeof options.addListener !== 'undefined') {\n\t\tif (typeof options.addListener !== 'function') {\n\t\t\tthrow new Error(`addListener must be a function, received: ${options.addListener}`);\n\t\t}\n\t\taddEventListenerListeners[eventName] = options.addListener;\n\t}\n\n\tif (typeof options.removeListener !== 'undefined') {\n\t\tif (typeof options.removeListener !== 'function') {\n\t\t\tthrow new Error(`removeListener must be a function, received: ${options.removeListener}`);\n\t\t}\n\t\tremoveEventListenerListeners[eventName] = options.removeListener;\n\t}\n\n\teventListeners[eventName] = new Set();\n};\n\nglobalObjectModule.triggerEvent = (eventName, ...args) => {\n\tif (typeof eventListeners[eventName] === 'undefined') {\n\t\tthrow new Error(`Event ${eventName} doesn't exist.`);\n\t}\n\teventListeners[eventName].forEach(eventListener => {\n\t\tsetImmediate(eventListener, ...args);\n\t});\n};\n\npublicObject.on = (eventName, eventListener) => {\n\tif (typeof eventListeners[eventName] === 'undefined') {\n\t\tthrow new Error(`Event ${eventName} doesn't exist.`);\n\t}\n\teventListeners[eventName].add(eventListener);\n\tif (addEventListenerListeners[eventName]) {\n\t\taddEventListenerListeners[eventName](eventListener);\n\t}\n};\n\npublicObject.off = (eventName, eventListener) => {\n\tif (typeof eventListeners[eventName] === 'undefined') {\n\t\tthrow new Error(`Event ${eventName} doesn't exist.`);\n\t}\n\teventListeners[eventName].delete(eventListener);\n\tif (removeEventListenerListeners[eventName]) {\n\t\tremoveEventListenerListeners[eventName](eventListener);\n\t}\n};\n\n/**\n * Restore document to a previous version, either by version number or tag label.\n * Labels cannot begin with a digit whereas versions consist only of digits, so distinguishing\n * is easy.\n * @param  {string} tagOrVersion Tag label or version number.\n */\npublicObject.restore = (tagOrVersion, callback) => {\n\tif (publicObject.isStatic) {\n\t\tconsole.log('fetch');\n\t\tcoreDatabase.fetch(publicObject.webstrateId, tagOrVersion).then(doc => {\n\t\t\tcorePopulator.populate(document, doc);\n\t\t});\n\t} else {\n\t\tcoreDatabase.restore(publicObject.webstrateId, tagOrVersion);\n\t}\n};\n\n/*coreEvents.addEventListener('populated', (targetElement, webstrateId) => {\n\tpublicObject.webstrateId = webstrateId;\n}, coreEvents.PRIORITY.IMMEDIATE);*/\n\nwindow.webstrate = publicObject;\nmodule.exports = globalObjectModule;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/globalObject.js\n// module id = 3\n// module chunks = 0","module.exports = {\n\tVERBOSE_MODE: false,\n\tmodules: [\n\t\t'globalObject',\n\t\t'loadedEvent',\n\t\t'userObject',\n\t\t'cookies',\n\t\t'nodeObjects',\n\t\t'domEvents',\n\t\t'transclusionEvent',\n\t\t'connectionEvents',\n\t\t'permissions',\n\t\t'tagging',\n\t\t'clientManager',\n\t\t'signaling', // Depends on connectionEvents for reconnect event.\n\t\t'signalStream',\n\t\t'assets',\n\n\t\t'keepAlive'\n\t],\n\t// Supports selector syntax, i.e. 'div.not-persisted' to not persist all DIV elements with the\n\t// class 'not-persisted'.\n\tisTransientElement: (DOMNode) => DOMNode.matches('transient'),\n\t// Any attributeName starting with 'transient-' should be transient.\n\tisTransientAttribute: (DOMNode, attributeName) => attributeName.startsWith('transient-'),\n\t// Keep alive message interval in seconds. A falsy value disabled the interval.\n\tkeepAliveInterval: 55,\n\t// Peer Connection configuration used for the WebRTC-based signal streaming.\n\tpeerConnectionConfig: {\n\t\t'iceServers': [\n\t\t\t{ url: 'stun:stun.services.mozilla.com' },\n\t\t\t{ url: 'stun:stun.l.google.com:19302' }\n\t\t]\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/config.js\n// module id = 4\n// module chunks = 0","'use strict';\nconst coreEvents = require('./coreEvents');\nconst globalObject = require('./globalObject');\n\nconst loadedEventModule = {};\n\nlet loadedTriggered = false;\n\n// List of events that has to be resolved before the loaded event gets triggered.\nlet delayLoadedUntilPromises = [];\n\n/**\n * Add event to list of events that has to be resolved, before the loaded event gets triggered.\n * This allows other modules to postpone the loaded event until they're ready.\n * @param  {...string} eventNames List of event names.\n * @public\n */\nloadedEventModule.delayUntil = (...args) => {\n\tvar [eventName, ...eventNames] = args;\n\tif (!eventName) return;\n\n\tdebug.log('Delay loaded event until', eventName, 'has been triggered');\n\tdelayLoadedUntilPromises.push(new Promise((accept) => {\n\t\t// Low priority, because want need to ensure that this gets triggered after the webstrateId\n\t\t// has been set on the wet publicObject (which we do below at medium priority).\n\t\tcoreEvents.addEventListener(eventName, accept, coreEvents.PRIORITY.LOW);\n\t}));\n\n\tloadedEventModule.delayUntil(...eventNames);\n};\n\n// Initially delay the loaded event until the document has been populated.\nloadedEventModule.delayUntil('populated');\n\n// Create loaded event -- event to be triggered when the webstrate has finished.\nglobalObject.createEvent('loaded');\n\n// Also create an internal event.\ncoreEvents.createEvent('loadedTriggered', {\n\t// If anybody adds a 'loaded' event listener after it has already been triggered, we run the\n\t// callback immediately.\n\taddListener: callback => {\n\t\tif (loadedTriggered) {\n\t\t\tsetImmediate(callback, globalObject.publicObject.webstrateId,\n\t\t\t\tglobalObject.publicObject.clientId, globalObject.publicObject.user);\n\t\t}\n\t}\n});\n\n// Wait for all events to have been triggered, before firing the loaded event.\ncoreEvents.addEventListener('allModulesLoaded', () => {\n\tPromise.all(delayLoadedUntilPromises).then(() => {\n\t\tloadedTriggered = true;\n\t\tglobalObject.triggerEvent('loaded', globalObject.publicObject.webstrateId,\n\t\t\t// These last two arguments depend on the existance of the clientManager and userObject\n\t\t\t// modules, respectively, which aren't a part of the core. It may be bad style to have them\n\t\t\t// here anyway, but luckily it won't break anything if these two modules aren't present.\n\t\t\tglobalObject.publicObject.clientId, globalObject.publicObject.user);\n\t\tcoreEvents.triggerEvent('loadedTriggered');\n\t});\n});\n\nmodule.exports = loadedEventModule;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/loadedEvent.js\n// module id = 5\n// module chunks = 0","'use strict';\nconst coreEvents = require('./coreEvents');\nconst coreWebsocket = require('./coreWebsocket');\nconst sharedb = require('sharedb/lib/client');\n\nconst coreDatabaseModule = {};\n\ncoreEvents.createEvent('receivedDocument');\ncoreEvents.createEvent('receivedOps');\n\nlet doc;\n\ncoreDatabaseModule.getDocument = () => doc;\n\n/**\n * Get the element at a given path in a JsonML document.\n * @param  {JsonMLPath} path Path to follow in snapshot.\n * @return {JsonML}          Element at path in snapshot.\n * @public\n */\ncoreDatabaseModule.elementAtPath = function(snapshot, path) {\n// Snapshot is optional (and only used in the internal recursion).\n\tif (!path) {\n\t\tpath = snapshot;\n\t\tsnapshot = doc.data;\n\t}\n\n\tif (path.length > 0 && typeof path[path.length-1] === 'string') {\n\t\treturn null;\n\t}\n\n\tvar [head, ...tail] = path;\n\tif (!head || !snapshot[head]) {\n\t\treturn snapshot;\n\t}\n\n\treturn coreDatabaseModule.elementAtPath(snapshot[head], tail);\n};\n\n\ncoreDatabaseModule.subscribe = (documentName) => {\n\treturn new Promise((resolve, reject) => {\n\t\t// Filter out our own messages. This could be done more elegantly by parsing the JSON object and\n\t\t// then checking if the \"wa\" property exists, but this is a lot faster.\n\t\t// This filter is passed to coreWebsocket.copy() when getting a copy of a websocket.\n\t\t// @param  {obj} event  Websocket onmessage event.\n\t\t// @return {bool}       Whether the message should be let through to ShareDB.\n\t\tconst websocket = coreWebsocket.copy(event => !event.data.startsWith('{\"wa\":'));\n\n\t\t// Create a shareDB connection.\n\t\tconst conn = new sharedb.Connection(websocket);\n\n\t\t// Get ShareDB document for webstrateId.\n\t\tdoc = conn.get('webstrates', documentName);\n\n\t\t// Subscribe to remote operations (changes to the ShareDB document).\n\t\tdoc.subscribe(function(error) {\n\n\t\t\tif (error) {\n\t\t\t\treturn reject(error);\n\t\t\t}\n\n\t\t\tcoreEvents.triggerEvent('receivedDocument', doc, { static: false });\n\n\t\t\tdoc.on('op', (ops, source) => {\n\t\t\t\t// If source is truthy, it is our own op, which should not be broadcasted as \"recivedOps\".\n\t\t\t\t// It will already have been broadcasted as \"createdOps\".\n\t\t\t\tif (!source) {\n\t\t\t\t\tcoreEvents.triggerEvent('receivedOps', ops);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tcoreEvents.addEventListener('createdOps', (ops) => {\n\t\t\t\tdoc.submitOp(ops);\n\t\t\t}, coreEvents.PRIORITY.IMMEDIATE);\n\n\t\t\tresolve(doc);\n\t\t});\n\t});\n};\n\ncoreDatabaseModule.fetch = (documentName, tagOrVersion) => {\n\treturn new Promise((resolve, reject) => {\n\t\tconst msgObj = {\n\t\t\twa: 'fetchdoc',\n\t\t\td: documentName\n\t\t};\n\n\t\tif (/^\\d/.test(tagOrVersion) && Number(tagOrVersion)) {\n\t\t\tmsgObj.v = Number(tagOrVersion);\n\t\t} else {\n\t\t\tmsgObj.l = tagOrVersion;\n\t\t}\n\n\t\t// The second parameter is `sendWhenReady` and true means to queue the message until the\n\t\t// websocket is open rather than to throw and error if the websocket isn't ready. This is not\n\t\t// part of the WebSocket specification, but has been implemented in coreWebsocket anyway.\n\t\tcoreWebsocket.send(msgObj, doc => {\n\t\t\tcoreEvents.triggerEvent('receivedDocument', doc, { static: true });\n\t\t\tresolve(doc);\n\t\t}, { waitForOpen: true });\n\t});\n};\n\n/**\n * Restore document to a previous version, either by version number or tag label.\n * Labels cannot begin with a digit whereas versions consist only of digits, so distinguishing\n * is easy.\n * This does not return a promise, as we do not have control over exactly when the document gets\n * reverted as this is ShareDB's job.\n * @param  {string} tagOrVersion Tag label or version number.\n */\ncoreDatabaseModule.restore = (documentName, tagOrVersion) => {\n\tvar msgObj = {\n\t\twa: 'restore',\n\t\td: documentName\n\t};\n\n\tif (/^\\d/.test(tagOrVersion)) {\n\t\tmsgObj.v = tagOrVersion;\n\t} else {\n\t\tmsgObj.l = tagOrVersion;\n\t}\n\n\tcoreWebsocket.send(msgObj);\n};\n\nmodule.exports = coreDatabaseModule;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreDatabase.js\n// module id = 6\n// module chunks = 0","const debugModule = {};\n\nfunction tryStringify(obj) {\n\ttry {\n\t\treturn JSON.stringify(obj);\n\t} catch (e) {\n\t\treturn obj;\n\t}\n}\n\nif (config.VERBOSE_MODE) {\n\tif (window.chrome) {\n\t\tdebugModule.log = (...args) => {\n\t\t\targs = args.map(arg => typeof arg === 'object' ? tryStringify(arg) : arg);\n\t\t\tlet callstack = new Error().stack;\n\t\t\tlet location = callstack.split('\\n')[2].match(/\\((.*)\\)$/)[1];\n\t\t\tconsole.debug('[' + location + ']', ...args);\n\t\t};\n\t} else {\n\t\t// Safari's error.stack string is useless, so we just divert the arguments directly to\n\t\t// console.debug.\n\t\tconsole.debug('For a better debug.log results, please use Chrome.');\n\t\tdebugModule.log = (...args) => {\n\t\t\tconsole.debug(...args);\n\t\t};\n\t}\n} else {\n\tdebugModule.log = () => {};\n}\nmodule.exports = debugModule;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/debug.js\n// module id = 7\n// module chunks = 0","'use strict';\nconst coreUtils = require('./coreUtils');\n\n/* JsonML <-> HTML library by Kristian B. Antonsen\n * This library is based on jQuery JSONML Plugin by Trevor Norris.\n * This document is licensed as free software under the terms of the\n * MIT License: http://www.opensource.org/licenses/mit-license.php\n */\n\nconst coreJsonML = {};\n\nfunction getNs(elem) {\n\tif (!elem) return undefined;\n\tvar ns;\n\tfor (var index in elem) {\n\t\tif (index === 'xmlns') {\n\t\t\tns = elem[index];\n\t\t}\n\t}\n\n\tif (ns !== undefined) {\n\t\treturn ns;\n\t}\n\n\tif (elem.parent === elem) {\n\t\treturn undefined;\n\t}\n\n\treturn getNs(elem.parent);\n}\n\nfunction isPlainObject(obj) {\n\treturn obj && typeof obj === 'object' &&\n\t\tObject.getPrototypeOf(obj) === Object.prototype && !obj.nodeType;\n}\n\nfunction toHTML(elem, xmlNs, scripts) {\n\tvar fragment = document.createDocumentFragment();\n\tvar i = 0;\n\tvar selector;\n\tvar name = null;\n\n\t// Check if is an element or array of elements\n\tif (typeof elem[0] == 'string') {\n\t\tname = elem[0];\n\t\ti = 1;\n\t}\n\n\tif (elem[0] === '!' || elem[0] === '#comment') {\n\t\treturn document.createComment(elem.slice(typeof elem[1] === 'string' ? 1 : 2).join(''));\n\t}\n\n\tfor (; i < elem.length; i++) {\n\t\t// If array create new element\n\t\tif (Array.isArray(elem[i])) {\n\t\t\tfragment.appendChild(toHTML(elem[i], xmlNs, scripts));\n\n\t\t\t// If object set element attributes\n\t\t} else if (isPlainObject(elem[i])) {\n\t\t\tif (name) {\n\t\t\t\tname = coreUtils.sanitizeString(name);\n\t\t\t\tif (!xmlNs) {\n\t\t\t\t\txmlNs = getNs(elem[i]);\n\t\t\t\t}\n\n\t\t\t\t// When loading a website with an SVG element without a namespace attribute, Chrome will\n\t\t\t\t// guess the namespace itself. When adding it like we do with Webstrates, it won't. So\n\t\t\t\t// to have Webstrates give us a more normal browser experience, we add the namespace\n\t\t\t\t// manually.\n\t\t\t\tif (!xmlNs && name === 'svg') {\n\t\t\t\t\txmlNs = 'http://www.w3.org/2000/svg';\n\t\t\t\t}\n\n\t\t\t\tif (xmlNs) {\n\t\t\t\t\tselector = document.createElementNS(xmlNs, name);\n\t\t\t\t} else {\n\t\t\t\t\tselector = document.createElement(name);\n\t\t\t\t}\n\n\t\t\t\t// Add attributes to the element.\n\t\t\t\tfor (var index in elem[i]) {\n\t\t\t\t\t// The __wid attribute is a unique ID assigned each node and should not be in the DOM, but\n\t\t\t\t\t// instead be a property on the DOM element.\n\t\t\t\t\tif (index.toLowerCase() === '__wid') {\n\t\t\t\t\t\tcoreUtils.setWidOnElement(selector, elem[i][index]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tvar value = elem[i][index] && elem[i][index]\n\t\t\t\t\t\t.replace(/&quot;/g, '\\'').replace(/&amp;/g, '&');\n\t\t\t\t\tindex = coreUtils.sanitizeString(index);\n\t\t\t\t\tif (xmlNs) {\n\t\t\t\t\t\tif (index === 'href' || index === 'xlink:href') {\n\t\t\t\t\t\t\tselector.setAttributeNS('http://www.w3.org/1999/xlink', index, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar isSvgPath = selector.tagName.toLowerCase() === 'path' && index === 'd';\n\t\t\t\t\tif (isSvgPath) {\n\t\t\t\t\t\tselector.__d = value;\n\t\t\t\t\t}\n\t\t\t\t\tselector.setAttribute(index, value);\n\t\t\t\t}\n\n\t\t\t\t// Add scripts to our scripts list, so we can execute them later synchronously. Only add\n\t\t\t\t// JavaScripts, i.e. scripts either without a type attribute, or with 'text/javascript' as\n\t\t\t\t// the type attribute.\n\t\t\t\tif (selector.tagName.toLowerCase() === 'script' && (!selector.getAttribute('type') ||\n\t\t\t\t\tselector.getAttribute('type') === 'text/javascript')) {\n\t\t\t\t\tselector.async = false;\n\t\t\t\t\tscripts && scripts.push(selector);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If string or number insert text node\n\t\t} else if (typeof elem[i] == 'number' || typeof elem[i] == 'string') {\n\t\t\tfragment.appendChild(document.createTextNode(elem[i]));\n\n\t\t\t// If is an element append to fragment\n\t\t} else if (elem[i].nodeType) {\n\t\t\tfragment.appendChild(elem[i]);\n\t\t}\n\t}\n\n\tif (!selector && name) {\n\t\tname = coreUtils.sanitizeString(name);\n\t\tselector = document.createElement(name);\n\t}\n\n\t// If a selector is set append children and return\n\tif (selector) {\n\t\t// When creating <templates>, we need the document to actually contain an documentFragment.\n\t\t// If we just add a documentFragment to an element, the children of documentFragment will\n\t\t// actually be added instead. To prevent this, we add the children to the `content` property\n\t\t// if it exists.\n\t\tif (selector.content && selector.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {\n\t\t\tselector.content.appendChild(fragment);\n\t\t} else {\n\t\t\tselector.appendChild(fragment);\n\t\t}\n\t\treturn selector;\n\t}\n\n\t// Otherwise return children of fragment\n\treturn fragment.childNodes;\n}\n\ncoreJsonML.toHTML = toHTML;\n\nfunction addChildren(/*DOM*/ elem, /*function*/ filter, /*JsonML*/ jml) {\n\tvar childNodes = coreUtils.getChildNodes(elem);\n\tif ((childNodes = coreUtils.getChildNodes(elem))) {\n\t\tfor (var i=0; i<childNodes.length; i++) {\n\t\t\tvar child = childNodes[i];\n\t\t\tchild = fromHTML(child, filter);\n\t\t\tif (child) {\n\t\t\t\tjml.push(child);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/**\n * @param {Node} elem\n * @param {function} filter\n * @return {array} JsonML\n */\nfunction fromHTML(elem, filter) {\n\t// If an element doesn't have a PathTree, we don't want it in the JsonML. This will be the case\n\t// for <transient> elements.\n\tif (!elem || !elem.nodeType || !elem.__pathNodes || elem.__pathNodes.length === 0) {\n\t\t// free references\n\t\treturn (elem = null);\n\t}\n\n\tvar i, jml;\n\tswitch (elem.nodeType) {\n\t\tcase document.ELEMENT_NODE:\n\t\tcase document.DOCUMENT_NODE:\n\t\tcase document.DOCUMENT_FRAGMENT_NODE:\n\t\t\tjml = [elem.tagName||''];\n\n\t\t\tvar attr = elem.attributes,\n\t\t\t\tprops = {},\n\t\t\t\thasAttrib = false;\n\n\t\t\tfor (i=0; attr && i<attr.length; i++) {\n\t\t\t\tif (attr[i].specified) {\n\t\t\t\t\tif (attr[i].name === 'style') {\n\t\t\t\t\t\tprops.style = elem.style.cssText || attr[i].value;\n\t\t\t\t\t} else if ('string' === typeof attr[i].value) {\n\t\t\t\t\t\tif (elem.namespaceURI === 'http://www.w3.org/2000/svg') {\n\t\t\t\t\t\t\tprops[attr[i].name.toLowerCase()] = attr[i].value;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tprops[attr[i].name] = attr[i].value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\thasAttrib = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (elem.__wid) {\n\t\t\t\tprops['__wid'] = elem.__wid;\n\t\t\t\thasAttrib = true;\n\t\t\t}\n\n\t\t\tjml.push(props); //Webstrates always assumes that an element has attributes.\n\n\t\t\tvar child, childNodes;\n\t\t\tswitch (jml[0].toLowerCase()) {\n\t\t\t\tcase 'frame':\n\t\t\t\tcase 'iframe':\n\t\t\t\t\tbreak; //Do not recursively serialize content in iFrames (CNK)\n\t\t\t/*try {\n\t\t\t\tif ('undefined' !== typeof elem.contentDocument) {\n\t\t\t\t\t// W3C\n\t\t\t\t\tchild = elem.contentDocument;\n\t\t\t\t} else if ('undefined' !== typeof elem.contentWindow) {\n\t\t\t\t\t// Microsoft\n\t\t\t\t\tchild = elem.contentWindow.document;\n\t\t\t\t} else if ('undefined' !== typeof elem.document) {\n\t\t\t\t\t// deprecated\n\t\t\t\t\tchild = elem.document;\n\t\t\t\t}\n\n\t\t\t\tchild = fromHTML(child, filter);\n\t\t\t\tif (child) {\n\t\t\t\t\tjml.push(child);\n\t\t\t\t}\n\t\t\t} catch (ex) {}\n\t\t\tbreak;*/\n\t\t\t\tcase 'style':\n\t\t\t\t\tchild = elem.styleSheet && elem.styleSheet.cssText;\n\t\t\t\t\tif (child && 'string' === typeof child) {\n\t\t\t\t// unwrap comment blocks\n\t\t\t\t\t\tchild = child.replace('<!--', '').replace('-->', '');\n\t\t\t\t\t\tjml.push(child);\n\t\t\t// elem.content may have childNodes if elem is a template (i.e. elem.content is a\n\t\t\t// document fragment).\n\t\t\t\t\t} else if ((childNodes = coreUtils.getChildNodes(elem))) {\n\t\t\t\t\t\tfor (i=0; i<childNodes.length; i++) {\n\t\t\t\t\t\t\tchild = childNodes[i];\n\t\t\t\t\t\t\tchild = fromHTML(child, filter);\n\t\t\t\t\t\t\tif (child && 'string' === typeof child) {\n\t\t\t\t\t\t// unwrap comment blocks\n\t\t\t\t\t\t\t\tchild = child.replace('<!--', '').replace('-->', '');\n\t\t\t\t\t\t\t\tjml.push(child);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'input':\n\t\t\t\t\taddChildren(elem, filter, jml);\n\t\t\t\t\tchild = (elem.type !== 'password') && elem.value;\n\t\t\t\t\tif (child) {\n\t\t\t\t\t\tif (!hasAttrib) {\n\t\t\t\t\t// need to add an attribute object\n\t\t\t\t\t\t\tjml.shift();\n\t\t\t\t\t\t\tprops = {};\n\t\t\t\t\t\t\tjml.unshift(props);\n\t\t\t\t\t\t\tjml.unshift(elem.tagName||'');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tprops.value = child;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'textarea':\n\t\t\t\t\tif (!addChildren(elem, filter, jml)) {\n\t\t\t\t\t\tchild = elem.value || elem.innerHTML;\n\t\t\t\t\t\tif (child && 'string' === typeof child) {\n\t\t\t\t\t\t\tjml.push(child);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\taddChildren(elem, filter, jml);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t// filter result\n\t\t\tif ('function' === typeof filter) {\n\t\t\t\tjml = filter(jml, elem);\n\t\t\t}\n\n\t\t// free references\n\t\t\telem = null;\n\t\t\treturn jml;\n\t\tcase 3: // text node\n\t\tcase 4: // CDATA node\n\t\t\tvar str = String(elem.nodeValue);\n\t\t// free references\n\t\t\telem = null;\n\t\t\treturn str;\n\t\tcase 10: // doctype\n\t\t\tjml = ['!'];\n\n\t\t\tvar type = ['DOCTYPE', (elem.name || 'html').toLowerCase()];\n\n\t\t\tif (elem.publicId) {\n\t\t\t\ttype.push('PUBLIC', '\"' + elem.publicId + '\"');\n\t\t\t}\n\n\t\t\tif (elem.systemId) {\n\t\t\t\ttype.push('\"' + elem.systemId + '\"');\n\t\t\t}\n\n\t\t\tjml.push(type.join(' '));\n\n\t\t// filter result\n\t\t\tif ('function' === typeof filter) {\n\t\t\t\tjml = filter(jml, elem);\n\t\t\t}\n\t\t// free references\n\t\t\telem = null;\n\t\t\treturn jml;\n\t\tcase 8: // comment node\n\t\t\tif ((elem.nodeValue||'').indexOf('DOCTYPE') !== -1) {\n\t\t\t// free references\n\t\t\t\telem = null;\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tjml = ['!',\n\t\t\t\telem.nodeValue];\n\n\t\t// filter result\n\t\t\tif ('function' === typeof filter) {\n\t\t\t\tjml = filter(jml, elem);\n\t\t\t}\n\n\t\t// free references\n\t\t\telem = null;\n\t\t\treturn jml;\n\t\tdefault: // etc.\n\t\t// free references\n\t\t\treturn (elem = null);\n\t}\n}\n\ncoreJsonML.fromHTML = fromHTML;\n\nmodule.exports = coreJsonML;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreJsonML.js\n// module id = 8\n// module chunks = 0","'use strict';\n/*\nWebstrates PathTree (webstrates.pathree.js)\n\nPathTree is a tree data structure mapping to the DOM, but with some extended attributes. Each node\nin a PathTree consists of a unique id, a list of children, a parent, and the node's mapped DOM\nelement.\n\nThe primary purposes of the PathTree are to:\n  1) Maintain a copy of the DOM tree's structure pre-mutation, so operations on the pre-mutation DOM\n     tree can be rewritten to work on the post-mutation DOM tree.\n  2) Facilitate lightweight creation of JsonML which is used when creating operations that are to be\n     sent to the Webstrates server.\n  3) Allow for verifying the integrity of the document by comparing every DOM node to its respective\n     PathTree node.\n*/\n\n/**\n * Generate a unique identifier (UUID4).\n * @return {UUID}\n */\nfunction generateUUID() {\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t\tvar r = Math.random() * 16 | 0;\n\t\tvar v = c === 'x' ? r : (r & 0x3) | 0x8;\n\t\treturn v.toString(16);\n\t});\n}\n\n/**\n * Create a PathTree from a DOM element. If a parentPathTree is provided, the created\n * PathTree will be a subtree of the parent.\n * @param {DOMNode} DOMNode\tDOMNode to create PathTree from.\n * @param {PathTree} parentPathTree\tPathTree to add as parent.\n * @param {bool} overwrite\tWhether existing PathTree on the DOMNode should be overwritten by the\n * new PathTree or just appended to it.\n * @return {PathTree} Created PathTree.\n */\nfunction PathTree(DOMNode, parentPathTree, overwrite) {\n\tthis.id = generateUUID();\n\tthis.children = [];\n\tthis.parent = parentPathTree;\n\tthis.DOMNode = DOMNode;\n\n\t// When moving an element around, a node may exist in two places at once for a brief moment.\n\t// __pathNodes therefore has to be a list.\n\tif (overwrite || !DOMNode.__pathNodes || DOMNode.__pathNodes.length === 0) {\n\t\tDOMNode.__pathNodes = [this];\n\t} else {\n\t\tDOMNode.__pathNodes.push(this);\n\t}\n\n\tvar childNodes = DOMNode.hasChildNodes() ? DOMNode.childNodes :\n\t\t(DOMNode.content && DOMNode.content.childNodes) || [];\n\tArray.from(childNodes).forEach(function(childNode) {\n\t\tvar childPathNode = PathTree.create(childNode, this, overwrite);\n\t\tif (childPathNode) {\n\t\t\tthis.children.push(childPathNode);\n\t\t}\n\t}.bind(this));\n}\n\n/**\n * Check whether a DOM Node is a descendant of a template tag (or actually a documentFragment).\n * One might assume this could be done with `element.closest(\"template\")`, but that won't be the\n * case, because a documentFragment technically isn't a parent (and also doesn't have any parent),\n * so there will be no tree to search upwards through after we reach the documentFragment.\n * @param  {DOMNode} DOMNode DOM Node to check.\n * @return {boolean}         True if the DOM Node is a descendant of a template.\n * @private\n */\nfunction elementIsTemplateDescendant(element) {\n\treturn document.documentElement.ownerDocument !== element.ownerDocument;\n}\n\n/**\n * Check whether a DOM Node should be persisted on the server (i.e. whether it's transient or not).\n * For a DOM Node to be transient, it has to be an element (i.e. not a text node), exist outside of\n * a template tag, as well as not be in the list of transient elements (config.transientElements).\n * @param  {DOMNode} DOMNode DOM Node to check.\n * @return {boolean}         True if the DOM Node is transient.\n * @private\n */\nfunction isTransientElement(DOMNode) {\n\t// Only elements can be transient\n\treturn DOMNode.nodeType === document.ELEMENT_NODE\n\t\t// Nothing in templates can be transient\n\t\t&& !elementIsTemplateDescendant(DOMNode)\n\t\t// Only elements passing a function defined in config.isTransientElement are transient.\n\t\t&& config.isTransientElement && config.isTransientElement(DOMNode);\n}\n\n/**\n * Add PathNode to node if the node isn't a <transient> element.\n * @param  {[type]} DOMNode        [description]\n * @param  {[type]} parentPathTree [description]\n * @param  {[type]} overwrite      [description]\n * @return {[type]}                [description]\n */\nPathTree.create = function(DOMNode, parentPathTree, overwrite) {\n\t// Transient elements are not supposed to be persisted, and should thus not be part of the\n\t// PathTree. Unless the transient element is in a <template>.\n\tif (isTransientElement(DOMNode)) {\n\t\treturn;\n\t}\n\n\treturn new PathTree(DOMNode, parentPathTree, overwrite);\n};\n/**\n * Creates a JsonML representation of the PathTree.\n * @return {JsonML} JsonML representation of PathTree.\n */\nPathTree.prototype.toPath = function() {\n\tif (!this.parent) {\n\t\treturn [];\n\t}\n\n\tvar childIndex = this.parent.children.findIndex(function(sibling) {\n\t\treturn sibling.id === this.id;\n\t}.bind(this));\n\n\t// In the JsonML representation, the list elements start at position 2 in the object:\n\t//   [tag-name, attributes, ...element-list]\n\tvar ELEMENT_LIST_OFFSET = 2;\n\treturn [...this.parent.toPath(), ELEMENT_LIST_OFFSET + childIndex];\n};\n\n/**\n * Remove a PathTree by removing itself from parent as well as removing all children.\n * @param {bool} shallow Does not remove itself from parent if true (deletion if shallow).\n * @return {PathTree}    The deleted PathTree, consisting only of an object with an id.\n */\nPathTree.prototype.remove = function(shallow) {\n\t// TODO: Why can't we do this EVERY time? If we do this on the children as well, the integrity\n\t// check fails.\n\tif (!shallow) {\n\t\t// Remove ourselves from our parent.\n\t\tthis.parent.children.splice(this.parent.children.indexOf(this), 1);\n\t}\n\tthis.parent = null;\n\n\t// Remove ourselves from our DOMNode.\n\tthis.DOMNode.__pathNodes.splice(this.DOMNode.__pathNodes.indexOf(this), 1);\n\tthis.DOMNode = null;\n\n\t// Remove all our children.\n\tthis.children.forEach(function(child) {\n\t\tchild.remove(true);\n\t});\n\tthis.children = null;\n\n\treturn this;\n};\n\n/**\n * Checks the integrity of the document by recursively comparing the elements of the PathTree to\n * that of the DOM node.\n * @return {Array of results}\n */\nPathTree.prototype.check = function() {\n\tif (this.DOMNode.__pathNodes.length > 1) {\n\t\tconsole.log(this.DOMNode, this.DOMNode.__pathNodes);\n\t\twindow.alert('Webstrates has encountered an error. Please reload the page.');\n\t\tthrow 'Node has multiple paths';\n\t}\n\n\tvar domNodePathNode = this.DOMNode.__pathNodes[0];\n\tif (domNodePathNode.id !== this.id) {\n\t\tconsole.log(this.DOMNode, this);\n\t\twindow.alert('Webstrates has encountered an error. Please reload the page.');\n\t\tthrow 'No id match';\n\t}\n\n\tvar definedChildNodesInDom = (function() {\n\t\tvar ref, ref1;\n\t\tref = this.DOMNode.hasChildNodes() ? this.DOMNode.childNodes\n\t\t\t: (this.DOMNode.content && this.DOMNode.content.childNodes) || [];\n\t\tvar results = [];\n\t\tfor (var j = 0, len = ref.length; j < len; j++) {\n\t\t\tvar childNode = ref[j];\n\t\t\tif (((ref1 = childNode.__pathNodes) != null ? ref1.length : void 0) > 0) {\n\t\t\t\tresults.push(childNode);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}.bind(this))();\n\n\tif (definedChildNodesInDom.length !== this.children.length) {\n\t\tconsole.log(definedChildNodesInDom, this.children, this);\n\t\twindow.alert('Webstrates has encountered an error. Please reload the page.');\n\t\tthrow 'Different amount of children';\n\t}\n\n\tvar childNodes = this.DOMNode.hasChildNodes() ? this.DOMNode.childNodes\n\t\t\t: (this.DOMNode.content && this.DOMNode.content.childNodes) || [];\n\tchildNodes = Array.from(childNodes).filter(function(childNode) {\n\t\treturn !childNode.tagName || childNode.tagName.toLowerCase() !== 'transient'\n\t\t\t|| elementIsTemplateDescendant(childNode);\n\t});\n\tif (definedChildNodesInDom.length !== childNodes.length) {\n\t\tconsole.log(definedChildNodesInDom, childNodes);\n\t\tconsole.warn('Warning: Found zombie nodes in DOM.');\n\t}\n\n\tvar results = [];\n\tfor (var i = 0, j = 0, len = definedChildNodesInDom.length; j < len; i = ++j) {\n\t\tresults.push(this.children[i].check());\n\t}\n\n\treturn results;\n};\n\n/**\n * Returns the last added pathNode of an element. If a parent DOM element is provided, we search\n * for the pathNode that matches on parent.\n * @param  {DOMNode} elem       Element to get pathNode of.\n * @param  {DOMNode} parentElem Parent of Element (optional).\n * @return {PathTree}           PathNode found or null.\n */\nPathTree.getPathNode = function(elem, parentElem) {\n\tif (!elem || !elem.__pathNodes) {\n\t\treturn null;\n\t}\n\n\tif (!parentElem || !parentElem.__pathNodes) {\n\t\treturn elem.__pathNodes[elem.__pathNodes.length - 1];\n\t}\n\n\tvar matchingElement = null;\n\tparentElem.__pathNodes.some(function(parentPathNode) {\n\t\treturn (matchingElement = elem.__pathNodes.find(function(pathNode) {\n\t\t\treturn pathNode.parent.id === parentPathNode.id;\n\t\t}));\n\t});\n\n\treturn matchingElement;\n};\n\nvar jsonml = {\n\tTAG_NAME_INDEX: 0,\n\tATTRIBUTE_INDEX: 1,\n\tELEMENT_LIST_OFFSET: 2\n};\n\n/**\n * Returns the DOM element at the end of the path.\n * @param  {HTMLElement|PathTree} parentElement The element used to nagivate to the path from. May\n *                                              be either a DOM element or a PathTree.\n * @param  {JsonMLPath} path                    Path to follow on parentElement.\n * @return {[DOMElement, int, DOMElement, int]} The DOM element found, including its index on its\n *                                              parent, the parent DOM element, as possibly a\n *                                              JsonML index in case the path doesn't at a DOM\n *                                              element (it may end at a tag name or attribute\n *                                              object).\n */\nPathTree.elementAtPath = function(parentElement, path) {\n\tvar parentPathNode = parentElement instanceof PathTree ? parentElement\n\t\t: PathTree.getPathNode(parentElement);\n\n\tvar jsonmlIndex = path[0];\n\tif (jsonmlIndex === jsonml.ATTRIBUTE_INDEX) {\n\t\t// An attribute's parent could arguably be the element it's defined on, so the childElement\n\t\t// and parentElement are the same. Therefore, there also can't be a childIndex.\n\t\treturn [parentElement, undefined, parentElement, jsonmlIndex];\n\t}\n\n\tvar childIndex = jsonmlIndex - jsonml.ELEMENT_LIST_OFFSET;\n\tvar childPathNode = parentPathNode && parentPathNode.children[childIndex];\n\n\tvar nextJsonmlIndex = path[1];\n\tif (path.length === 1\n\t\t|| nextJsonmlIndex === jsonml.TAG_NAME_INDEX\n\t\t|| nextJsonmlIndex === jsonml.ATTRIBUTE_INDEX) {\n\t\tvar childElement = childPathNode && childPathNode.DOMNode;\n\t\tparentElement = parentPathNode.DOMNode;\n\t\treturn [childElement, childIndex, parentElement, nextJsonmlIndex];\n\t}\n\n\treturn PathTree.elementAtPath(childPathNode, path.slice(1));\n};\n\nmodule.exports = PathTree;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/corePathTree.js\n// module id = 9\n// module chunks = 0","var apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\nexports.setImmediate = setImmediate;\nexports.clearImmediate = clearImmediate;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/node-libs-browser/~/timers-browserify/main.js\n// module id = 10\n// module chunks = 0","'use strict';\nconst coreEvents = require('./coreEvents');\nconst coreUtils = require('./coreUtils');\n\nconst coreMutation = {};\n\n//coreEvents.createEvent('premutation');\ncoreEvents.createEvent('mutation');\n\nconst observerOptions = {\n\tchildList: true,\n\tsubtree: true,\n\tattributes: true,\n\tcharacterData: true,\n\tattributeOldValue: true,\n\tcharacterDataOldValue: true\n};\n\nlet rootElement;\nconst primaryObserver = new MutationObserver(mutationsHandler);\nconst fragmentObservers = {};\nconst fragmentParentMap = {};\n\nfunction mutationsHandler(mutations) {\n\tmutations.forEach(function forEachMutation(mutation) {\n\t\t// DocumentFragments (as per the specification) can't have parents, even if they actually do.\n\t\t// Therefore, they also can't exist in the PathTree. Instead, we pretend that they *are*\n\t\t// their parents. Since this is only used with <template>s, whose only children are a single\n\t\t// documentFragment, this makes sense. The JsonML also does not store the documentFragment,\n\t\t// but it is automatically created when creating a <template> tag.\n\t\tif (mutation.target.nodeType === document.DOCUMENT_FRAGMENT_NODE) {\n\t\t\t// We use defineProperty rather than a primitive assignemtn, because the target property is\n\t\t\t// read-only.\n\t\t\tObject.defineProperty(mutation, 'target', {\n\t\t\t\tvalue: () => fragmentParentMap[mutation.target.id]\n\t\t\t});\n\t\t}\n\n\t\t// The global mutation observer does not observe on changes to documentFragments within the\n\t\t// document, so we have to manually create and manage individual observers for each\n\t\t// documentFragment manually.\n\t\tif (mutation.type === 'childList') {\n\t\t\tArray.from(mutation.addedNodes).forEach(function(addedNode) {\n\t\t\t\tcoreUtils.recursiveForEach(addedNode, (node) => {\n\t\t\t\t\tif (node.content && node.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {\n\t\t\t\t\t\tsetupFragmentObserver(node.content, node);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t\tArray.from(mutation.removedNodes).forEach(function(removedNode) {\n\t\t\t\tcoreUtils.recursiveForEach(removedNode, function(node) {\n\t\t\t\t\tif (node.content && node.content.nodeType === document.DOCUMENT_FRAGMENT_NODE) {\n\t\t\t\t\t\tteardownFragmentObserver(node.content);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\tcoreEvents.triggerEvent('mutation', mutation);\n\t});\n}\n\nlet isPaused = true;\nObject.defineProperty(coreMutation, 'isPaused', {\n\tget: function() { return isPaused; }\n});\n\n\n/**\n * Set ups a Mutation Observer on a Document Fragment.\n * @param {DocumentFragment} fragment Fragment to observe.\n * @param {DOMElement} element        Element containing fragment.\n * @private\n */\nfunction setupFragmentObserver(fragment, element) {\n\tif (fragment.id) {\n\t\treturn;\n\t}\n\tfragment.id = coreUtils.util.randomString();\n\tconst fragmentObserver = new MutationObserver(mutationsHandler);\n\tfragmentObserver.observe(fragment, observerOptions);\n\tfragmentObservers[fragment.id] = [fragment, fragmentObserver];\n\tfragmentParentMap[fragment.id] = element;\n}\n\n/**\n * Removes a Mutation Observer from a Document Fragment.\n * @param {DocumentFragment} fragment Fragment to remove observer from.\n * @private\n */\nfunction teardownFragmentObserver(fragment) {\n\tif (!fragment.id || !fragmentParentMap[fragment.id]) {\n\t\treturn;\n\t}\n\tlet fragmentObserver;\n\t[fragment, fragmentObserver] = fragmentObservers[fragment.id];\n\tfragmentObserver.disconnect();\n\tdelete fragmentObservers[fragment.id];\n\tdelete fragmentParentMap[fragment.id];\n}\n\ncoreMutation.emitMutationsFrom = (_rootElement) => {\n\trootElement = _rootElement;\n\tprimaryObserver.observe(rootElement, observerOptions);\n\tisPaused = false;\n};\n\ncoreMutation.pause = () => {\n\tif (isPaused) return;\n\tObject.keys(fragmentObservers).forEach(function(fragmentId) {\n\t\tvar [_fragment, fragmentObserver] = fragmentObservers[fragmentId];\n\t\tfragmentObserver.disconnect();\n\t});\n\tprimaryObserver.disconnect();\n\tisPaused = true;\n};\n\ncoreMutation.resume = () => {\n\tif (!isPaused) return;\n\tObject.keys(fragmentObservers).forEach(function(fragmentId) {\n\t\tvar [fragment, fragmentObserver] = fragmentObservers[fragmentId];\n\t\tfragmentObserver.observe(fragment, observerOptions);\n\t});\n\tprimaryObserver.observe(rootElement, observerOptions);\n\tisPaused = false;\n};\n\nmodule.exports = coreMutation;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreMutation.js\n// module id = 11\n// module chunks = 0","'use strict';\nconst coreEvents = require('./coreEvents');\nconst coreUtils = require('./coreUtils');\nconst coreJsonML = require('./coreJsonML');\nconst corePathTree = require('./corePathTree');\nconst sharedb = require('sharedb/lib/client');\n\nconst corePopulator = {};\n\ncoreEvents.createEvent('populated');\n\ncorePopulator.populate = function(rootElement, doc) {\n\t// Empty the document, so we can use it.\n\twhile (rootElement.firstChild) {\n\t\trootElement.removeChild(rootElement.firstChild);\n\t}\n\n\tconst webstrateId = doc.id;\n\n\t// This will normally be the case, but when using the static parameter, the document will just\n\t// be a plain JavaScript object, in which case we don't need all this stuff.\n\tif (doc instanceof sharedb.Doc) {\n\t\t// A typeless document is not a document at all. Let's create one.\n\t\tif (!doc.type || doc.data.length === 0) {\n\t\t\tif (!doc.type) {\n\t\t\t\tconsole.log(`Creating new sharedb document: \"${webstrateId}\".`);\n\t\t\t\tdoc.create('json0');\n\t\t\t} else {\n\t\t\t\tconsole.log('Document exists, but was empty. Recreating basic document.');\n\t\t\t}\n\n\t\t\tconst op = rootElement.parentNode\n\t\t\t\t\t? [{ 'p': [], 'oi': [ 'div', { id: 'doc_' + webstrateId, 'class': 'document' }]}]\n\t\t\t\t\t: [{ 'p': [], 'oi': [ 'html', {}, [ 'head', {} ], [ 'body', {} ]]}];\n\t\t\tdoc.submitOp(op);\n\t\t}\n\n\t\t// All documents are persisted as JsonML, so we only know how to work with JSON documents.\n\t\tif (doc.type.name !== 'json0') {\n\t\t\tthrow `Unsupported document type: ${doc.type.name}`;\n\t\t}\n\t}\n\n\t// In order to execute scripts synchronously, we insert them all without execution, and then\n\t// execute them in order afterwards.\n\tconst scripts = [];\n\tcoreUtils.appendChildWithoutScriptExecution(rootElement,\n\t\tcoreJsonML.toHTML(doc.data, undefined, scripts));\n\n\treturn new Promise((resolve) => {\n\t\tcoreUtils.executeScripts(scripts, () => {\n\t\t\t// Do not include the parent element in the path, i.e. create corePathTree on the <html>\n\t\t\t// element rather than the document element.\n\t\t\tconst targetElement = rootElement.childNodes[0];\n\t\t\tconst pathTree = corePathTree.create(targetElement, null, true);\n\t\t\tpathTree.check();\n\t\t\tresolve();\n\t\t\tcoreEvents.triggerEvent('populated', targetElement, webstrateId);\n\t\t});\n\t});\n};\n\nmodule.exports = corePopulator;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/corePopulator.js\n// module id = 12\n// module chunks = 0","'use strict';\nconst coreEvents = require('./coreEvents');\nconst coreWebsocket = require('./coreWebsocket');\nconst globalObject = require('./globalObject');\nconst loadedEvent = require('./loadedEvent');\n\nconst userObjectModule = {};\n\ncoreEvents.createEvent('userObjectAdded');\n\n// Delay the loaded event, until the 'userObjectAdded' event has been triggered.\nloadedEvent.delayUntil('userObjectAdded');\n\nconst websocket = coreWebsocket.copy((event) => event.data.startsWith('{\"wa\":'));\n\n// Public user object\nconst publicObject = {};\n\nuserObjectModule.publicObject = publicObject;\nglobalObject.publicObject.user = publicObject;\n\nwebsocket.onjsonmessage = (message) => {\n\tif (message.wa === 'hello') {\n\t\t// Merge the incoming information with the existing user object. We don't overwrite it, as other\n\t\t// modules may already have added their own stuff.\n\t\tObject.assign(publicObject, message.user);\n\t\tcoreEvents.triggerEvent('userObjectAdded');\n\t}\n};\n\nmodule.exports = userObjectModule;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/userObject.js\n// module id = 13\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 14\n// module chunks = 0","'use strict';\nconst coreEvents = require('./coreEvents');\nconst coreUtils = require('./coreUtils');\nconst corePathTree = require('./corePathTree');\nconst coreMutation = require('./coreMutation');\nconst coreJsonML = require('./coreJsonML');\n\n/*\nWebstrates ApplyOp (webstrates.applyop.js)\n\nThis module exposes the applyOp(op, rootElement) function on the Webstrates scope. This function\napplies a subset of json0 OT operations (see https://github.com/ottypes/json0) to a DOM element.\nThe operations handled are list insertion and deletion (li and ld), as well as string insertion and\ndeletion (si and sd). These operations are generated on another client using the CreateOp module.\n*/\nconst coreOpApplier = {};\n\n// The 'idempotent' option allows these events to be created even if they already\n// exists. We do this, because these events also are used (and created) in coreOpCreator.\ncoreEvents.createEvent('DOMAttributeSet', { idempotent: true });\ncoreEvents.createEvent('DOMAttributeRemoved', { idempotent: true });\ncoreEvents.createEvent('DOMNodeInserted', { idempotent: true });\ncoreEvents.createEvent('DOMNodeDeleted', { idempotent: true });\ncoreEvents.createEvent('DOMAttributeTextInsertion', { idempotent: true });\ncoreEvents.createEvent('DOMTextNodeInsertion', { idempotent: true });\ncoreEvents.createEvent('DOMAttributeTextDeletion', { idempotent: true });\ncoreEvents.createEvent('DOMTextNodeDeletion', { idempotent: true });\n\nconst jsonml = {\n\tTAG_NAME_INDEX: 0,\n\tATTRIBUTE_INDEX: 1,\n\tELEMENT_LIST_OFFSET: 2\n};\n\n/**\n * Extract the XML namespace from a DOM element.\n * @param  {DOMNode} element Element.\n * @return {string}          Namespace string.\n * @private\n */\nfunction getNamespace(element) {\n\tif (!element || !element.getAttribute) {\n\t\treturn undefined;\n\t}\n\n\tvar namespace = element.getAttribute('xmlns');\n\treturn namespace ? namespace : getNamespace(element.parent);\n}\n\n/**\n * Recursively navigates an element using path to set the value as an attribute.\n * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.\n * @param {DOMPath} path          Path to follow on DOMNode. Last element of path is the attribute\n *                                key.\n * @param {string} value          Attribute value.\n * @private\n */\nfunction setAttribute(rootElement, path, attributeName, newValue) {\n\tconst [childElement] = corePathTree.elementAtPath(rootElement, path);\n\n\tif (config.isTransientAttribute(childElement, attributeName)) {\n\t\treturn;\n\t}\n\n\t// The __wid attribute is a unique ID assigned each node and should not be in the DOM.\n\tif (attributeName === '__wid') {\n\t\tcoreUtils.setWidOnElement(childElement, newValue);\n\t\treturn;\n\t}\n\n\tconst isSvgPath = childElement.tagName.toLowerCase() === 'path' && attributeName === 'd';\n\tif (isSvgPath) childElement.__d = newValue;\n\n\tconst oldValue = childElement.getAttribute(attributeName);\n\tchildElement.setAttribute(attributeName, newValue);\n\n\t// Last argument is false for not local, i.e happened on another client.\n\tcoreEvents.triggerEvent('DOMAttributeSet', childElement, attributeName, oldValue, newValue,\n\t\tfalse);\n}\n\n/**\n * Recursively navigates an element using path to remove the attribute at the end of the path.\n * @param {DOMNode} rootElement   DOMNode usf ed as root element for path navigation.\n * @param {DOMPath} path          Path to fllow on DOMNode. Last element of path is the attribute\n *                                key.\n * @private\n */\nfunction removeAttribute(rootElement, path, attributeName) {\n\tconst [childElement ] = corePathTree.elementAtPath(rootElement, path);\n\n\tif (config.isTransientAttribute(childElement, attributeName)) {\n\t\treturn;\n\t}\n\n\tconst isSvgPath = childElement.tagName.toLowerCase() === 'path' && attributeName === 'd';\n\tif (isSvgPath) delete childElement.__d;\n\tconst oldValue = childElement.getAttribute(attributeName);\n\tchildElement.removeAttribute(attributeName);\n\n\t// Last argument is false for not local, i.e happened on another client.\n\tcoreEvents.triggerEvent('DOMAttributeRemoved', childElement, attributeName, oldValue, false);\n}\n\n/**\n * Recursively navigates an element using path to insert an element.\n * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.\n * @param {DOMPath} path          Path to follow on DOMNode.\n * @param {mixed} value           Element to insert, either a text string or JSON element.\n * @private\n */\nfunction insertNode(rootElement, path, value) {\n\tconst [childElement, childIndex, parentElement] =\n\t\tcorePathTree.elementAtPath(rootElement, path);\n\n\tconst namespace = getNamespace(parentElement);\n\tconst newElement = typeof value === 'string' ?\n\t\tdocument.createTextNode(value) : coreJsonML.toHTML(value, namespace);\n\n\t// childElement may be undefined, and if so we insert newElement at the end of the list. If\n\t// chidElement is defined, however, we insert the element before childElement.\n\tcoreUtils.appendChildWithoutScriptExecution(parentElement, newElement, childElement);\n\n\tconst parentPathNode = corePathTree.getPathNode(parentElement);\n\tconst childPathNode = corePathTree.create(newElement, parentPathNode);\n\n\t// childPathNode may not have been created, because its parent doesn't have a PathTree (because\n\t// its a descendant of a transient element, or a transient element itself) or because the new\n\t// element itself is a transient element.\n\tif (childPathNode) {\n\t\t// Insert new element into parent PathTree.\n\t\tparentPathNode.children.splice(childIndex, 0, childPathNode);\n\t}\n\n\tcoreEvents.triggerEvent('DOMNodeInserted', newElement, parentElement, false);\n}\n\n/**\n * Recursively navigates an element using path to delete an element.\n * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.\n * @param {DOMPath} path          Path to follow on DOMNode.\n * @private\n */\nfunction deleteNode(rootElement, path) {\n\tconst [childElement, childIndex, parentElement] =\n\t\tcorePathTree.elementAtPath(rootElement, path);\n\n\t// Update PathTree to reflect the deletion.\n\t// TODO: Use PathTree.remove() instead.\n\tconst parentPathNode = corePathTree.getPathNode(parentElement);\n\t//const childPathNode = corePathTree.getPathNode(childElement, parentPathNode);\n\tparentPathNode.children.splice(childIndex, 1);\n\n\t// And remove the actual DOM node.\n\tchildElement.remove();\n\n\t// Notify nodeRemoved listeners.\n\tcoreEvents.triggerEvent('DOMNodeDeleted', childElement, parentElement, false);\n}\n\n/**\n * Replace a node, either a tag name, list of attributes or a regular node.\n * Note that this is added for compatibility with a wider array of json0 operations such as those\n * used by Webstrates file system. Webstrates itself does not create these kinds of operations.\n * @param {DOMNode} rootElement   DOMNode used as root element for path navigation.\n * @param {DOMPath} path          Path to follow on DOMNode.\n * @param {mixed} value           Element to insert, new tag name, or new set of attributes.\n * @private\n */\nfunction replaceNode(rootElement, path, value) {\n\tconst [childElement, childIndex, parentElement, indexType] =\n\t\tcorePathTree.elementAtPath(rootElement, path);\n\n\t// Webstrates file system has some broken parsing, so it may think JavaScript like \"< b)\" in\n\t// \"if (a < b)\" is an element and try to send a replacement op. In this case, childElement\n\t// doesn't exist. This should be solved in Webstrates file system, but we'll fix it here, too.\n\tif (!childElement) {\n\t\treturn;\n\t}\n\n\tswitch (indexType) {\n\t// We're renaming a tag, e.g. when <span>foo</span> should become <div>foo</div>.\n\t\tcase jsonml.TAG_NAME_INDEX: {\n\t\t\tconst oldElement = childElement;\n\t\t\tconst namespace = getNamespace(oldElement);\n\t\t\tconst newElement = coreJsonML.toHTML([value], namespace);\n\n\t\t\tconst parentPathNode = corePathTree.getPathNode(parentElement);\n\t\t\tif (!parentPathNode) {\n\t\t\t\tconsole.warn('No parentPathNode found, aborting. This shouldn\\'t happen, but...');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// Move all children.\n\t\t\twhile (oldElement.firstChild) {\n\t\t\t\tcoreUtils.appendChildWithoutScriptExecution(newElement, oldElement.firstChild);\n\t\t\t}\n\n\t\t\t// Copy all attributes.\n\t\t\tfor (let i = 0; i < oldElement.attributes.length; i++) {\n\t\t\t\tconst attr = oldElement.attributes.item(i);\n\t\t\t\tconst attributeName = attr.nodeName;\n\t\t\t\tconst isSvgPath = childElement.tagName.toLowerCase() === 'path' && attributeName === 'd';\n\t\t\t\tif (isSvgPath) newElement.__d = attr.nodeValue;\n\t\t\t\tnewElement.setAttribute(attributeName, attr.nodeValue);\n\t\t\t}\n\n\t\t\t// Overwrite old node with new node.\n\t\t\tcoreUtils.appendChildWithoutScriptExecution(parentElement, newElement, oldElement);\n\t\t\toldElement.remove();\n\n\t\t\tconst newElementPathNode = corePathTree.create(newElement, parentPathNode, true);\n\n\t\t\t// New element may not have a PathNode if it's a transient object.\n\t\t\tif (!newElementPathNode) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tparentPathNode.children.splice(childIndex, 1, newElementPathNode);\n\n\t\t\tcoreEvents.triggerEvent('DOMNodeDeleted', oldElement, parentElement, false);\n\t\t\tcoreEvents.triggerEvent('DOMNodeInserted', newElement, parentElement, false);\n\t\t\tbreak;\n\t\t}\n\t\t// We're replacing an entire object of attributes by writing all the new attributes and\n\t\t// deleting old ones.\n\t\tcase jsonml.ATTRIBUTE_INDEX: {\n\t\t\tconst newAttributes = value;\n\t\t\tconst oldAttributeKeys = Array.from(childElement.attributes).map(function(attribute) {\n\t\t\t\treturn attribute.name;\n\t\t\t});\n\n\t\t\tconst attributes = new Set([...Object.keys(newAttributes), ...oldAttributeKeys]);\n\t\t\tattributes.forEach(function(attributeName) {\n\t\t\t\tconst isSvgPath = childElement.tagName.toLowerCase() === 'path' && attributeName === 'd';\n\t\t\t\tif (attributeName in newAttributes) {\n\t\t\t\t\tif (isSvgPath) childElement.__d = newAttributes[attributeName];\n\t\t\t\t\tchildElement.setAttribute(attributeName, newAttributes[attributeName]);\n\t\t\t\t} else {\n\t\t\t\t\tif (isSvgPath) delete childElement.__d;\n\t\t\t\t\tchildElement.removeAttribute(attributeName);\n\t\t\t\t}\n\t\t\t});\n\t\t\tbreak;\n\t\t}\n\t\t// Otherwise, we're just replacing a regular node.\n\t\tdefault: {\n\t\t\tdeleteNode(rootElement, path);\n\t\t\tinsertNode(rootElement, path, value);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Recursively navigates an element using path to insert text at an index.\n * @param {DOMNode} parentElement DOMNode used as root element for path navigation.\n * @param {DOMPath} path          Path to follow on DOMNode.\n * @param {int} charIndex         Index in existing string to insert new string at.\n * @param {string} value          String to be inserted.\n * @private\n */\nfunction insertInText(rootElement, path, charIndex, value) {\n\tlet [childElement, /*childIndex*/, parentElement, indexType] =\n\t\tcorePathTree.elementAtPath(rootElement, path);\n\tlet attributeName = typeof path[path.length-1] === 'string' ? path[path.length-1] : undefined;\n\n\tswitch (indexType) {\n\t\tcase jsonml.TAG_NAME_INDEX:\n\t\t\t// Diff changes to tag names is not supported.\n\t\t\tthrow Error('Unsupported indexType jsonml.TAGNAME_INDEX (0)');\n\t\tcase jsonml.ATTRIBUTE_INDEX:\n\t\t\t// This is not necessarily an attribute change, because the attribute object in JsonML is\n\t\t\t// optional. Therefore, it may just be a change made to a comment or regular text node\n\t\t\t// without an attribute object. We verify by seeing if an attribute name exists.\n\t\t\tif (attributeName) {\n\t\t\t\t// Attribute value diff.\n\t\t\t\tattributeName = path.pop();\n\t\t\t\t// The SVG stuff below is a hack, because Microsoft Edge rounds the d value on SVG paths,\n\t\t\t\t// which messes up our attribute diffing. We also do this in deleteInText below.\n\t\t\t\tconst isSvgPath = childElement.tagName.toLowerCase() === 'path' && attributeName === 'd';\n\t\t\t\tlet oldValue = childElement.getAttribute(attributeName);\n\t\t\t\tif (isSvgPath) oldValue = childElement.__d;\n\t\t\t\tconst newValue = oldValue.substring(0, charIndex)\n\t\t\t\t\t+ value + oldValue.substring(charIndex);\n\t\t\t\tif (isSvgPath) childElement.__d = newValue;\n\t\t\t\tchildElement.setAttribute(attributeName, newValue);\n\t\t\t\tcoreEvents.triggerEvent('DOMAttributeSet', childElement, attributeName, oldValue, newValue,\n\t\t\t\t\tfalse);\n\t\t\t\tcoreEvents.triggerEvent('DOMAttributeTextInsertion', childElement, attributeName, charIndex,\n\t\t\t\t\tvalue, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// falls through if not an attribute value change.\n\t\tdefault:\n\t\t\t// Text node or comment content change.\n\t\t\tvar isComment = parentElement.nodeType === document.COMMENT_NODE;\n\t\t\tparentElement = isComment ? parentElement : childElement;\n\t\t\tvar oldValue = parentElement.data;\n\t\t\tvar newValue = oldValue.substring(0, charIndex)\n\t\t\t\t+ value + oldValue.substring(charIndex);\n\t\t\tparentElement.data = newValue;\n\t\t\tcoreEvents.triggerEvent('DOMTextNodeInsertion', childElement, parentElement, charIndex,\n\t\t\t\tvalue);\n\t\t\tbreak;\n\t}\n\n\t// Create and dispatch deprecated events.\n\t// TODO: This should be removed, eventually.\n\tvar event = new CustomEvent('insertText', {\n\t\tdetail: { position: charIndex, value: value, attributeName: attributeName }\n\t});\n\tparentElement.dispatchEvent(event);\n\n}\n\n/**\n * Recursively navigates an element using path to delete text at an index.\n * @param {DOMNode} parentElement DOMNode used as root element for path navigation.\n * @param {DOMPath} path          Path to follow on DOMNode.\n * @param {int} charIndex         Index in existing string to remove string from.\n * @param {string} value          String to be removed.\n * @private\n */\nfunction deleteInText(rootElement, path, charIndex, value) {\n\tlet [childElement, /*childIndex*/, parentElement, indexType] =\n\t\tcorePathTree.elementAtPath(rootElement, path);\n\tlet attributeName = typeof path[path.length-1] === 'string' ? path[path.length-1] : undefined;\n\n\tswitch (indexType) {\n\t\tcase jsonml.TAG_NAME_INDEX:\n\t\t\t// Diff changes to tag names is not supported.\n\t\t\tthrow Error('Unsupported indexType jsonml.TAGNAME_INDEX (1)');\n\t\tcase jsonml.ATTRIBUTE_INDEX:\n\t\t\tif (attributeName) {\n\t\t\t\t// Attribute value diff.\n\t\t\t\tattributeName = path.pop();\n\t\t\t\t// The SVG stuff below is a hack, because Microsoft Edge rounds the d value on SVG paths,\n\t\t\t\t// which messes up our attribute diffing. We also do this in insertInText above.\n\t\t\t\tconst isSvgPath = childElement.tagName.toLowerCase() === 'path' && attributeName === 'd';\n\t\t\t\tlet oldValue = childElement.getAttribute(attributeName);\n\t\t\t\tif (isSvgPath) oldValue = childElement.__d;\n\t\t\t\tconst newValue = oldValue.substring(0, charIndex)\n\t\t\t\t\t+ oldValue.substring(charIndex + value.length);\n\t\t\t\tif (isSvgPath) childElement.__d = newValue;\n\t\t\t\tchildElement.setAttribute(attributeName, newValue);\n\t\t\t\tcoreEvents.triggerEvent('DOMAttributeSet', childElement, attributeName, oldValue, newValue,\n\t\t\t\t\tfalse);\n\t\t\t\tcoreEvents.triggerEvent('DOMAttributeTextDeletion', childElement, attributeName, charIndex,\n\t\t\t\t\tvalue, false);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// If not an attribute value change: falls through.\n\t\tdefault:\n\t\t\t// Text node or comment content change.\n\t\t\tvar isComment = parentElement.nodeType === document.COMMENT_NODE;\n\t\t\tparentElement = isComment ? parentElement : childElement;\n\t\t\tvar oldValue = parentElement.data;\n\t\t\tvar newValue = oldValue.substring(0, charIndex)\n\t\t\t\t+ oldValue.substring(charIndex + value.length);\n\t\t\tparentElement.data = newValue;\n\t\t\tcoreEvents.triggerEvent('DOMTextNodeDeletion', childElement, parentElement, charIndex, value);\n\t\t\tbreak;\n\t}\n\n\t// Create and dispatch deprecated events. This should be removed, eventually.\n\tconst event = new CustomEvent('deleteText', {\n\t\tdetail: { position: charIndex, value: value, attributeName: attributeName }\n\t});\n\tparentElement.dispatchEvent(event);\n\n\t// Notify deleteText listeners.\n\t//coreEvents.triggerEvent(\"deleteText\", charIndex, value, attributeName);\n}\n\n/**\n * Apply an operation to an element.\n * @param  {Op} op   Operation to be applied. Contains path and op type.\n * @param  {DOMNode} DOMNode used as root element for path navigation.\n * @public\n */\nfunction applyOp(op, rootElement) {\n\tlet charIndex, attributeName;\n\tconst path = op.p;\n\tif (path.length === 0) {\n\t\treturn;\n\t}\n\n\t// We have to use \"prop in obj\" syntax, because not all properties have a value, necessarily\n\t// (i.e. `oi`).\n\tif ('si' in op || 'sd' in op) {\n\t\t// For string insertions and string deletions, we extract the character index from the path.\n\t\tcharIndex = path.pop();\n\t}\n\n\tif ('oi' in op || 'od' in op) {\n\t\t// For attribute insertions and attribute deletions, we extract the attribtue name from the\n\t\t// path.\n\t\tattributeName = path.pop();\n\t}\n\t// Attribute insertion (object insertion). Also catches replace operations, i.e. operations with\n\t// both `oi` and `od`.\n\tif ('oi' in op) {\n\t\treturn setAttribute(rootElement, path, attributeName, op.oi);\n\t}\n\n\t// Attribute removal (object deletion)\n\tif ('od' in op) {\n\t\treturn removeAttribute(rootElement, path, attributeName);\n\t}\n\n\t// String deletion.\n\tif ('sd' in op) {\n\t\treturn deleteInText(rootElement, path, charIndex, op.sd);\n\t}\n\n\t// String insertion.\n\tif ('si' in op) {\n\t\treturn insertInText(rootElement, path, charIndex, op.si);\n\t}\n\n\t// Node replacement, either a regular node, tag renaming, or a complete replacement of\n\t// attributes.\n\tif ('li' in op && 'ld' in op) {\n\t\treturn replaceNode(rootElement, path, op.li);\n\t}\n\n\t// Element deletion operation (list deletion).\n\tif ('ld' in op) {\n\t\treturn deleteNode(rootElement, path);\n\t}\n\n\t// Element insertion operation (list insertion).\n\tif ('li' in op) {\n\t\treturn insertNode(rootElement, path, op.li);\n\t}\n}\n\ncoreOpApplier.listenForOpsAndApplyOn = (rootElement) => {\n\tcoreEvents.addEventListener('receivedOps', (ops) => {\n\t\t// We disable the mutation observers before applying the operations. Otherwise, applying the\n\t\t// operations would cause new mutations to be created, which in turn would cause the\n\t\t// creation of new operations, leading to a livelock for all clients.\n\t\tcoreMutation.pause();\n\n\t\tops.forEach((op) => {\n\t\t\tapplyOp(op, rootElement);\n\t\t});\n\n\t\t// And re-enable MuationObservers.\n\t\tcoreMutation.resume();\n\t});\n};\n\nmodule.exports = coreOpApplier;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreOpApplier.js\n// module id = 15\n// module chunks = 0","'use strict';\nconst coreEvents = require('./coreEvents');\nconst coreDatabase = require('./coreDatabase');\nconst corePathTree = require('./corePathTree');\nconst coreUtils = require('./coreUtils');\nconst coreJsonML = require('./coreJsonML');\nconst diffMatchPatch = require('diff-match-patch');\n\nconst coreOpCreator = {};\n\ncoreEvents.createEvent('createdOps');\n\n// The 'idempotent' option allows these events to be created even if they already\n// exists. We do this, because these events also are used (and created) in coreOpApplier.\ncoreEvents.createEvent('DOMAttributeSet', { idempotent: true });\ncoreEvents.createEvent('DOMAttributeRemoved', { idempotent: true });\ncoreEvents.createEvent('DOMNodeInserted', { idempotent: true });\ncoreEvents.createEvent('DOMNodeDeleted', { idempotent: true });\ncoreEvents.createEvent('DOMAttributeTextInsertion', { idempotent: true });\ncoreEvents.createEvent('DOMTextNodeInsertion', { idempotent: true });\ncoreEvents.createEvent('DOMAttributeTextDeletion', { idempotent: true });\ncoreEvents.createEvent('DOMTextNodeDeletion', { idempotent: true });\n\n// The attribute's index into a JsonML element array.\nconst ATTRIBUTE_INDEX = 1;\n\n// Instantiate the DiffMatchPatch library used for creating ops from text mutations.\nconst dmp = new diffMatchPatch();\n\n/**\n * Convert a number of string patches to OT operations.\n * @param  {JsonMLPath} path Base path for patches to apply to.\n * @param  {string} oldValue Old value.\n * @param  {string} newValue New value.\n * @return {Ops}             List of resulting operations.\n */\nfunction patchesToOps(path, oldValue, newValue) {\n\tvar ops = [];\n\n\tvar patches = dmp.patch_make(oldValue, newValue);\n\n\tObject.keys(patches).forEach(function(i) {\n\t\tvar patch = patches[i], offset = patch.start1;\n\t\tpatch.diffs.forEach(function([type, value]) {\n\t\t\tswitch (type) {\n\t\t\t\tcase diffMatchPatch.DIFF_DELETE:\n\t\t\t\t\tops.push({ sd: value, p: [...path, offset] });\n\t\t\t\t\tbreak;\n\t\t\t\tcase diffMatchPatch.DIFF_INSERT:\n\t\t\t\t\tops.push({ si: value, p: [...path, offset] });\n\t\t\t\t\t// falls through intentionally\n\t\t\t\tcase diffMatchPatch.DIFF_EQUAL:\n\t\t\t\t\toffset += value.length;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: throw Error(`Unsupported operation type: ${type}`);\n\t\t\t}\n\t\t});\n\t});\n\n\treturn ops;\n}\n\n/**\n * Replaces ampersands (&) and double-quotes (\") with their respective HTML entities.\n * @param  {string} value Unescaped string.\n * @return {string}       Escaped string.\n */\nfunction escape(value) {\n\tif (!value) return value;\n\treturn value.replace(/&/g, '&amp;').replace(/\\\"/g, '&quot;');\n}\n\n/**\n * Creates attribute operation (object insertion) from mutation.\n * @param  {MutationRecord} mutation MutationRecord created by MutationObserver.\n * @param  {PathNode} targetPathNode The PathNode from PathTree that is the target of the\n *                                   mutation.\n */\nfunction attributeMutation(mutation, targetPathNode) {\n\tif (config.isTransientAttribute(mutation.target, mutation.attributeName)) {\n\t\treturn;\n\t}\n\n\tvar targetPathNodeJsonML = targetPathNode.toPath();\n\tvar path = [...targetPathNodeJsonML, ATTRIBUTE_INDEX, mutation.attributeName];\n\tvar oldValue = mutation.oldValue;\n\tvar newValue = escape(mutation.target.getAttribute(mutation.attributeName));\n\n\tvar jsonmlAttrs = coreDatabase.elementAtPath([...targetPathNodeJsonML, ATTRIBUTE_INDEX]);\n\n\t// If the new value is null, we are removing the attribute.\n\tif (newValue === null) {\n\t\tcoreEvents.triggerEvent('DOMAttributeRemoved', mutation.target, mutation.attributeName,\n\t\t\toldValue, newValue, true);\n\t\treturn [{ od: oldValue, p: path }];\n\t}\n\n\tif (newValue === jsonmlAttrs[mutation.attributeName]) {\n\t\treturn [];\n\t}\n\n\t// dmp.patch_make does not accept empty strings, so if we are creating a new attribute (or\n\t// setting an attribute's value for the first time), we have to create the operation manually.\n\t// The second condition should not be true without the first one, but it will if the changes\n\t// happen so rapidly, that the browser skipped a MutationRecord. Or that's my theory, at least.\n\t// We are lose about checking jsonmlAttrs[mutation.attributeName], because we don't want to\n\t// diff, regardless of whether it's an empty string or it's null.\n\tif (oldValue === null || !jsonmlAttrs[mutation.attributeName]) {\n\t\tcoreEvents.triggerEvent('DOMAttributeSet', mutation.target, mutation.attributeName, oldValue,\n\t\t\tnewValue, true);\n\t\treturn [{ oi: newValue, p: path }];\n\t}\n\n\tcoreEvents.triggerEvent('DOMAttributeSet', mutation.target, mutation.attributeName, oldValue,\n\t\tnewValue, true);\n\tlet ops = patchesToOps(path, jsonmlAttrs[mutation.attributeName], newValue);\n\treturn ops;\n}\n\n/**\n * Creates string insertion and string deletion operations from mutation.\n * @param  {MutationRecord} mutation MutationRecord created by MutationObserver.\n * @param  {PathNode} targetPathNode The PathNode from PathTree that is the target of the\n *                                   mutation.\n */\nfunction characterDataMutation(mutation, targetPathNode) {\n\tvar isComment = mutation.target.nodeType === document.COMMENT_NODE;\n\tvar path = targetPathNode.toPath();\n\tvar oldValue = mutation.oldValue;\n\tvar newValue = mutation.target.data;\n\n\tif (!isComment && coreDatabase.elementAtPath(path) !== oldValue) {\n\t\t// This should not happen, but it will if a text node is inserted and then altered right\n\t\t// after. If this happens, we can ignore it.\n\t\treturn;\n\t}\n\n\tvar ops = patchesToOps(path, oldValue, newValue);\n\tif (isComment) {\n\t\tops[0].p.splice(ops[0].p.length - 1, 0, 1);\n\t}\n\n\tops.forEach((op) => {\n\t\tvar charIndex = op.p[op.p.length - 1];\n\t\tcoreEvents.triggerEvent('DOMTextNodeInsertion', mutation.target, mutation.target.parentElement,\n\t\t\tcharIndex, op.si);\n\t});\n\n\treturn ops;\n}\n\n/**\n * Creates node insertion and deletion operations from mutation.\n * @param  {MutationRecord} mutation MutationRecord created by MutationObserver.\n * @param  {PathNode} targetPathNode The PathNode from PathTree that is the target of the\n *                                   mutation.\n */\nfunction childListMutation(mutation, targetPathNode) {\n\tlet ops = [];\n\n\tArray.from(mutation.addedNodes).forEach(function(addedNode) {\n\t\t// Sanitizes all nodes (i.e. ensures valid tag names and attributes) and set wids on all nodes.\n\t\tconst parentNode = mutation.target;\n\t\tcoreUtils.recursiveForEach(addedNode, (childNode, parentNode) => {\n\t\t\tlet addedPathNode = corePathTree.getPathNode(childNode, parentNode);\n\t\t\tif (addedPathNode && targetPathNode.id === addedPathNode.parent.id) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (childNode.nodeType === document.ELEMENT_NODE) {\n\t\t\t\tlet sanitizedTagName = coreUtils.sanitizeString(childNode.tagName);\n\t\t\t\t// If the name is unsanitized, we remove the element and replace it with an identical\n\t\t\t\t// element with a sanitized tag name.\n\t\t\t\tif (sanitizedTagName !== childNode.tagName) {\n\t\t\t\t\tlet replacementNode = document.createElementNS(childNode.tagName.namespaceURI,\n\t\t\t\t\t\tsanitizedTagName);\n\n\t\t\t\t\t// Move all children.\n\t\t\t\t\twhile (childNode.firstChild) {\n\t\t\t\t\t\tcoreUtils.appendChildWithoutScriptExecution(replacementNode, childNode.firstChild);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Copy all attributes and sanitize them as well.\n\t\t\t\t\tfor (let i = 0; i < childNode.attributes.length; i++) {\n\t\t\t\t\t\tlet attr = childNode.attributes[i];\n\t\t\t\t\t\treplacementNode.setAttribute(coreUtils.sanitizeString(attr.nodeName),\n\t\t\t\t\t\t\tattr.nodeValue);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Insert the element before childNode.\n\t\t\t\t\tcoreUtils.appendChildWithoutScriptExecution(childNode.parentElement,\n\t\t\t\t\t\treplacementNode, childNode);\n\t\t\t\t\tchildNode.remove();\n\t\t\t\t\tchildNode = replacementNode;\n\t\t\t\t} else {\n\t\t\t\t\t// If we haven't replaced the element, we still have to sanitize the attributes.\n\t\t\t\t\tfor (let i = 0; i < childNode.attributes.length; i++) {\n\t\t\t\t\t\tlet attr = childNode.attributes[i];\n\t\t\t\t\t\tlet sanitizedNodeName = coreUtils.sanitizeString(attr.nodeName);\n\t\t\t\t\t\tif (sanitizedNodeName !== attr.nodeName) {\n\t\t\t\t\t\t\tchildNode.removeAttribute(attr.nodeName);\n\t\t\t\t\t\t\tchildNode.setAttribute(sanitizedNodeName, attr.nodeValue);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst wid = coreUtils.randomString();\n\t\t\t\tcoreUtils.setWidOnElement(childNode, wid);\n\t\t\t}\n\t\t}, parentNode);\n\n\t\t// The above wid/sanitization, we do recursively on each node, so one might naturally wonder why\n\t\t// we don't need to do the same here: Creating a PathTree (as below) happens recursively on all\n\t\t// child nodes automatically. When it comes to inserting the newly created PathTree afterwards,\n\t\t// that shouldn't happen recursively; we just need to add the newly created PathTree one place\n\t\t// in the existing tree.\n\n\t\t// If we can't create path node, it can't been registered in the JsonML at all, so creating\n\t\t// an op for it doesn't make sense. This happens for instance with transient elements.\n\t\tvar newPathNode = corePathTree.create(addedNode, targetPathNode);\n\t\tif (!newPathNode) {\n\t\t\treturn;\n\t\t}\n\n\t\t// We use the previous sibling to insert the new element in the correct position in the path\n\t\t// tree. However, if the previous sibling doesn't have a webstrate object, it won't be in the\n\t\t// path tree, so it will appear that the element has no previous element. Therefore, we\n\t\t// traverse the list of previous siblings until we find one that does have a webstrate object.\n\t\t// Transient elements (outside of template tags) will righfully be absent from the pathtree,\n\t\t// and thus not have webstrate objects.\n\t\tvar previousSibling = mutation.previousSibling;\n\t\tvar previousSiblingPathNode = corePathTree.getPathNode(previousSibling, parentNode);\n\t\twhile (previousSibling && !previousSiblingPathNode) {\n\t\t\tpreviousSibling = previousSibling.previousSibling;\n\t\t\tpreviousSiblingPathNode = corePathTree.getPathNode(previousSibling, parentNode);\n\t\t}\n\n\t\tif (previousSibling) {\n\t\t\tvar previousSiblingIndex = targetPathNode.children.indexOf(previousSiblingPathNode);\n\t\t\ttargetPathNode.children.splice(previousSiblingIndex + 1, 0, newPathNode);\n\t\t} else if (mutation.nextSibling) {\n\t\t\ttargetPathNode.children.unshift(newPathNode);\n\t\t} else {\n\t\t\ttargetPathNode.children.push(newPathNode);\n\t\t}\n\n\t\tvar path = corePathTree.getPathNode(addedNode, parentNode).toPath();\n\t\tvar op = { li: coreJsonML.fromHTML(addedNode), p: path };\n\t\tdebug.log(op);\n\t\tops.push(op);\n\n\t\tcoreEvents.triggerEvent('DOMNodeInserted', addedNode, targetPathNode.DOMNode, true);\n\n\t});\n\n\tArray.from(mutation.removedNodes).forEach(function(removedNode) {\n\t\tvar removedPathNode = corePathTree.getPathNode(removedNode, mutation.target);\n\t\t// If an element has no path node, it hasn't been registered in the JsonML at all, so it won't\n\t\t// exist on other clients, and therefore creating an op to delete it wouldn't make sense.\n\t\tif (!removedPathNode) {\n\t\t\treturn;\n\t\t}\n\n\t\tcoreEvents.triggerEvent('DOMNodeDeleted', removedNode, removedPathNode.parent.DOMNode, true);\n\n\t\tvar path = removedPathNode.toPath();\n\t\tremovedPathNode.remove();\n\t\tvar jsonmlElement = coreDatabase.elementAtPath(path);\n\t\t// If the element doesn't exist in the JsonML, we can't create an op for its deletion, and we\n\t\t// shouldn't either, so we return. This happens when we replace an unsanitized tag with a\n\t\t// sanitized one.\n\t\tif (!jsonmlElement) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar op = { ld: jsonmlElement, p: path };\n\t\tops.push(op);\n\t});\n\n\treturn ops;\n}\n\ncoreOpCreator.emitOpsFromMutations = () => {\n\tcoreEvents.addEventListener('mutation', (mutation) => {\n\t\tvar targetPathNode = corePathTree.getPathNode(mutation.target);\n\t\t// It doesn't make sense to create operation for a node that doesn't exist, so we return.\n\t\t// This may happen if another user performs an operation on an element that we have just\n\t\t// deleted.\n\t\tif (!targetPathNode) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet ops;\n\t\tswitch (mutation.type) {\n\t\t\tcase 'attributes':\n\t\t\t\tops = attributeMutation(mutation, targetPathNode); break;\n\t\t\tcase 'characterData':\n\t\t\t\tops = characterDataMutation(mutation, targetPathNode); break;\n\t\t\tcase 'childList':\n\t\t\t\tops = childListMutation(mutation, targetPathNode); break;\n\t\t}\n\n\t\t// In rare cases, what happens doesn't amount to an operation, so we ignore it.\n\t\tif (!ops || ops.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tcoreEvents.triggerEvent('createdOps', ops);\n\t}, coreEvents.PRIORITY.IMMEDIATE);\n};\n\nfunction addWidToElement(node) {\n\tif (node.nodeType === document.ELEMENT_NODE && !node.__wid) {\n\t\tconst pathNode = corePathTree.getPathNode(node);\n\t\tif (pathNode) {\n\t\t\tconst wid = coreUtils.randomString();\n\t\t\tcoreUtils.setWidOnElement(node, wid);\n\t\t\tconst ops = [{ oi: wid, p: [...pathNode.toPath(), ATTRIBUTE_INDEX, '__wid' ]}];\n\t\t\tcoreEvents.triggerEvent('createdOps', ops);\n\t\t}\n\t}\n}\n\ncoreOpCreator.ensureExistenceOfWids = (targetElement) => {\n\tcoreUtils.recursiveForEach(targetElement, (node) => addWidToElement(node));\n};\n\ncoreEvents.addEventListener('DOMNodeInserted', (node, parentElement, local) => {\n\t// If local is set, this node was inserted by ourself and thus already has a wid (if it needs to).\n\tif (!local) addWidToElement(node);\n}, coreEvents.PRIORITY.IMMEDIATE);\n\nmodule.exports = coreOpCreator;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/coreOpCreator.js\n// module id = 16\n// module chunks = 0","'use strict';\nconst coreEvents = require('./coreEvents');\nconst coreUtils = require('./coreUtils');\nconst loadedEvent = require('./loadedEvent');\n\nconst nodeObjectsModule = {};\nnodeObjectsModule.nodes = new Map();\n\ncoreEvents.createEvent('webstrateObjectsAdded');\ncoreEvents.createEvent('webstrateObjectAdded');\n\n// Delay the loaded event, until the 'clientsReceied' event has been triggered.\nloadedEvent.delayUntil('webstrateObjectsAdded');\n\n// All nodes get a Webstrate object attached after they enter the DOM. It may, however, be\n// useful to access the Webstrate object before the element has been added to the DOM.\n// Therefore, we add Webstrate objects to all nodes created with document.createElement and\n// document.createElementNS immediately here.\ndocument.__createElementNS = document.createElementNS;\ndocument.createElementNS = function(namespaceURI, qualifiedName) {\n\tvar element = document.__createElementNS(namespaceURI, qualifiedName);\n\n\tattachWebstrateObjectToNode(element, false); // false to trigger webstrateObjectAdded event.\n\treturn element;\n};\n\ndocument.__createElement = document.createElement;\ndocument.createElement = function(tagName, options) {\n\tvar element = document.__createElement(tagName, options);\n\tattachWebstrateObjectToNode(element, true); // false to trigger webstrateObjectAdded event.\n\treturn element;\n};\n\n/**\n * Attach webstrate object to node if it doesn't exist.\n * @param  {DOMNode} node        DOM Node to add webstrate object to.\n * @param  {bool} triggerEvent   Whether to trigger the webstrateObjectAdded event.\n * @private\n */\nfunction attachWebstrateObjectToNode(node, triggerEvent) {\n\tconst objectAlreadyExists = !!node.webstate;\n\n\t// If object doesn't exist, we create it.\n\tif (!objectAlreadyExists) {\n\t\tnode.webstrate = {};\n\t}\n\n\t// If this webstrate object is being added before the element has been node to the DOM (or if the\n\t// node is transient), it won't have a __wid, so we won't create an id property.\n\tif (node.__wid) {\n\t\t// We don't use `writeable: false` and value here, because in rare cases, node.__wid may change,\n\t\t// so we need to always serve the current node.__wid, not the node.__wid value that existed when\n\t\t// this was added. The wid may get redefined if a client (e.g. file system) creates a node\n\t\t// without a wid, causing a race condition on setting the wid on the other clients. This is\n\t\t// handled by sharedb, so we won't have different wids for the same node for more than a few\n\t\t// milliseconds under normal network conditions. That's the cost of eventual consistency.\n\t\tObject.defineProperty(node.webstrate, 'id', {\n\t\t\tget: () => node.__wid,\n\t\t\tset: () => { throw new Error('node ID should not be modified'); },\n\t\t\tenumerable: true\n\t\t});\n\t}\n\n\t// If the object existed when we started, the below stuff will already have been defined, so we\n\t// can terminate.\n\tif (objectAlreadyExists) {\n\t\treturn;\n\t}\n\n\t// Map from event names to a set of the actual listeners: string -> set of listeners.\n\tconst eventListeners = {};\n\t// Map from event names to actual listeners: string -> function.\n\tconst addEventListenerListeners = {};\n\t// Map from event names to actual listeners: string -> function.\n\tconst removeEventListenerListeners = {};\n\n\tnode.webstrate.on = (eventName, eventListener) => {\n\t\tif (typeof eventListeners[eventName] === 'undefined') {\n\t\t\tthrow new Error(`Event ${eventName} doesn't exist on ${node}.`);\n\t\t}\n\t\teventListeners[eventName].add(eventListener);\n\t\tif (addEventListenerListeners[eventName]) {\n\t\t\taddEventListenerListeners[eventName](eventListener);\n\t\t}\n\t};\n\n\tnode.webstrate.off = (eventName, eventListener) => {\n\t\tif (typeof eventListeners[eventName] === 'undefined') {\n\t\t\tthrow new Error(`Event ${eventName} doesn't exist.`);\n\t\t}\n\t\teventListeners[eventName].delete(eventListener);\n\t\tif (removeEventListenerListeners[eventName]) {\n\t\t\tremoveEventListenerListeners[eventName](eventListener);\n\t\t}\n\t};\n\n\tconst eventObject = {\n\t\tcreateEvent: (eventName, options = {}) => {\n\t\t\tif (typeof eventListeners[eventName] !== 'undefined' && !options.idempotent) {\n\t\t\t\tthrow new Error(`Event ${eventName} already exist.`);\n\t\t\t}\n\n\t\t\tif (typeof options.addListener !== 'undefined') {\n\t\t\t\tif (typeof options.addListener !== 'function') {\n\t\t\t\t\tthrow new Error(`addListener must be a function, received: ${options.addListener}`);\n\t\t\t\t}\n\t\t\t\taddEventListenerListeners[eventName] = options.addListener;\n\t\t\t}\n\n\t\t\tif (typeof options.removeListener !== 'undefined') {\n\t\t\t\tif (typeof options.removeListener !== 'function') {\n\t\t\t\t\tthrow new Error(`removeListener must be a function, received: ${options.removeListener}`);\n\t\t\t\t}\n\t\t\t\tremoveEventListenerListeners[eventName] = options.removeListener;\n\t\t\t}\n\n\t\t\teventListeners[eventName] = new Set();\n\t\t},\n\t\ttriggerEvent: (eventName, ...args) => {\n\t\t\tif (typeof eventListeners[eventName] === 'undefined') {\n\t\t\t\tconsole.log(node);\n\t\t\t\tthrow new Error(`Event ${eventName} doesn't exist on ${node}.`);\n\t\t\t}\n\t\t\teventListeners[eventName].forEach(eventListener => {\n\t\t\t\tsetImmediate(eventListener, ...args);\n\t\t\t});\n\t\t}\n\t};\n\n\tnodeObjectsModule.nodes.set(node, eventObject);\n\n\tif (triggerEvent) {\n\t\tcoreEvents.triggerEvent('webstrateObjectAdded', node, eventObject);\n\t}\n}\n\ncoreEvents.addEventListener('populated', targetElement => {\n\tcoreUtils.recursiveForEach(targetElement, childNode => {\n\t\t// The second argument is whether to trigger the webstrateObjectAdded event. We do not want to\n\t\t// trigger these when we add the webstrate object initially as it may cause confusion when an\n\t\t// webstrateObjectsAdded event is triggered with the node in the nodes array, while a\n\t\t// webstrateObjectAdded event also is triggered for the same node.\n\t\tattachWebstrateObjectToNode(childNode, false);\n\t});\n\n\tcoreEvents.triggerEvent('webstrateObjectsAdded', nodeObjectsModule.nodes);\n}, coreEvents.PRIORITY.IMMEDIATE);\n\ncoreEvents.addEventListener('DOMNodeInserted', (node) => {\n\tcoreUtils.recursiveForEach(node, childNode => {\n\t\t// Thse second argument is whether to trigger the webstrateObjectAdded event. We do want that.\n\t\tattachWebstrateObjectToNode(childNode, true);\n\t});\n}, coreEvents.PRIORITY.IMMEDIATE);\n\ncoreEvents.addEventListener('DOMTextNodeInsertion', (node) => {\n\t// Thse second argument is whether to trigger the webstrateObjectAdded event. We do want that.\n\tattachWebstrateObjectToNode(node, true);\n}, coreEvents.PRIORITY.IMMEDIATE);\n\nmodule.exports = nodeObjectsModule;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/nodeObjects.js\n// module id = 17\n// module chunks = 0","'use strict';\nconst coreUtils = require('./coreUtils');\nconst coreEvents = require('./coreEvents');\nconst coreWebsocket = require('./coreWebsocket');\nconst globalObject = require('./globalObject');\nconst nodeObjects = require('./nodeObjects');\n\nconst signalingModule = {};\n\ncoreEvents.createEvent('receivedSignal');\n\nconst websocket = coreWebsocket.copy(event => event.data.startsWith('{\"wa\":\"publish\"'));\n\n// Allow other modules to add interceptors to signals. An interceptor is function that gets access\n// to a signal payload, then decides whether this module should handle the signal as a regular\n// signal. For instance, the signal streaming module uses the signaling mechanism to set up\n// streaming connections, but we don't want the streaming signals to be triggering regular signals\n// on nodes. Therefore, the streaming module intercepts all signals, and handles the streaming\n// signals and then returns true to intercept it.\nconst interceptors = new Set();\n\nsignalingModule.addInterceptor = interceptor => interceptors.add(interceptor);\nsignalingModule.removeInterceptor = interceptor => interceptors.delete(interceptor);\n\n// Allow other modules to subscribe manually to a node. This is useful for interception. E.g. signal\n// streaming needs to subscribe to nodes, but subscribing in the \"normal\" way will be silly, since\n// the callback given there will never be triggered, because we intercept all the signals.\nsignalingModule.subscribe = wid => subscribe(wid);\nsignalingModule.unsubscribe = wid => unsubscribe(wid);\n\nwebsocket.onjsonmessage = payload => {\n\tlet intercepted = false;\n\tinterceptors.forEach(interceptor => {\n\t\tintercepted |= interceptor(payload);\n\t});\n\t// If any of the interceptors has returned true, we don't want to process the signal, as the\n\t// intercepting module has already done what needs to be done with it.\n\tif (intercepted) return;\n\n\tconst wid = payload.id;\n\tconst node = coreUtils.getElementByWid(wid);\n\tif (!node && wid !== 'document') {\n\t\treturn;\n\t}\n\n\tconst senderId = payload.s;\n\tconst message = payload.m;\n\tconst eventObject = nodeObjects.nodes.get(node);\n\n\t// Trigger event in userland.\n\tconst triggerTarget = node ? eventObject : globalObject;\n\ttriggerTarget.triggerEvent('signal', message, senderId, node);\n\n\t// Trigger event internally.\n\tcoreEvents.triggerEvent('receivedSignal', message, senderId, node);\n};\n\n// The webstrateId is required for signal, subscribe, unsubscribe messages. We can't wrap everything\n// below in the 'populated' handler, because webstrateobjectsAdded may (will) be triggered before\n// we get to subscribe. However, the populated even always happens just before\n// webstrateobjectsAdded, so we are not at risk of needing webstrateId before it has been defined.\n// We could have created two promises (populated and webstrateobjectsAdded) and waited for both to\n// be resolved, but there's really no need.\nlet webstrateId;\ncoreEvents.addEventListener('populated', (rootElement, _webstrateId) => webstrateId = _webstrateId);\n\n// Map of wids to number of subscribers on the wid. Used to resubscribe after a disconnect.\nconst subscriptions = {};\n\nfunction signal(wid, message, recipients) {\n\tconst msgObj = {\n\t\twa: 'publish',\n\t\td: webstrateId,\n\t\tid: wid,\n\t\tm: message\n\t};\n\tif (recipients) {\n\t\tmsgObj.recipients = recipients;\n\t}\n\twebsocket.send(msgObj);\n}\n\nfunction subscribe(wid) {\n\tdebug.log('Subscribe on', wid);\n\tconst msgObj = {\n\t\twa: 'subscribe',\n\t\td: webstrateId,\n\t\tid: wid\n\t};\n\twebsocket.send(msgObj);\n\tsubscriptions[wid] = (subscriptions[wid] || 0) + 1;\n}\n\nfunction unsubscribe(wid) {\n\tsubscriptions[wid] = (subscriptions[wid] || 0) - 1;\n\tif (subscriptions[wid] < 1) {\n\t\tdebug.log('Unsubscribe on', wid);\n\t\tconst msgObj = {\n\t\t\twa: 'unsubscribe',\n\t\t\td: webstrateId,\n\t\t\tid: wid\n\t\t};\n\t\twebsocket.send(msgObj);\n\t\tdelete subscriptions[wid];\n\t}\n}\n\nfunction setupSignal(publicObject, eventObject) {\n\tconst wid = publicObject.id;\n\n\t// Text nodes and transient elements won't have wids, meaning there's way for us to signal on\n\t// them, and thus it'd be pointless to add a signaling method and event.\n\tif (!wid) return;\n\n\tObject.defineProperty(publicObject, 'signal', {\n\t\tvalue: (message, recipients) => signal(wid, message, recipients),\n\t\twritable: false\n\t});\n\n\teventObject.createEvent('signal', {\n\t\taddListener: () => subscribe(wid),\n\t\tremoveListener: () => unsubscribe(wid)\n\t});\n}\n\nsetupSignal(globalObject.publicObject, globalObject);\n\n// Add signal events to all webstrate objects (with a wid) after the document has been populated.\ncoreEvents.addEventListener('webstrateObjectsAdded', (nodes) => {\n\tnodes.forEach((eventObject, node) => setupSignal(node.webstrate, eventObject));\n}, coreEvents.PRIORITY.IMMEDIATE);\n\n// Add signal events to all webstrate objects (with wid) after they're added continually.\ncoreEvents.addEventListener('webstrateObjectAdded', (node, eventObject) => {\n\tsetupSignal(node.webstrate, eventObject);\n}, coreEvents.PRIORITY.IMMEDIATE);\n\ncoreEvents.addEventListener('reconnect', () => Object.keys(subscriptions).forEach(subscribe));\n\nmodule.exports = signalingModule;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/signaling.js\n// module id = 18\n// module chunks = 0","var EventEmitter = require('events').EventEmitter;\n\nexports.EventEmitter = EventEmitter;\nexports.mixin = mixin;\n\nfunction mixin(Constructor) {\n  for (var key in EventEmitter.prototype) {\n    Constructor.prototype[key] = EventEmitter.prototype[key];\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/emitter.js\n// module id = 19\n// module chunks = 0","var makeError = require('make-error');\n\nfunction ShareDBError(code, message) {\n  ShareDBError.super.call(this, message);\n  this.code = code;\n}\n\nmakeError(ShareDBError);\n\nmodule.exports = ShareDBError;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/error.js\n// module id = 20\n// module chunks = 0","\nexports.defaultType = require('ot-json0').type;\n\nexports.map = {};\n\nexports.register = function(type) {\n  if (type.name) exports.map[type.name] = type;\n  if (type.uri) exports.map[type.uri] = type;\n};\n\nexports.register(exports.defaultType);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/types.js\n// module id = 21\n// module chunks = 0","'use strict';\nconst coreEvents = require('./coreEvents');\nconst coreUtils = require('./coreUtils');\nconst coreWebsocket = require('./coreWebsocket');\nconst globalObject = require('./globalObject');\n\nconst assetsModule = {};\n\n// Create internal event that other modules may subscribe to\ncoreEvents.createEvent('asset');\n\n// Create event in userland.\nglobalObject.createEvent('asset');\n\nlet assets;\n\nconst websocket = coreWebsocket.copy((event) => event.data.startsWith('{\"wa\":'));\n\nwebsocket.onjsonmessage = (message) => {\n\tswitch (message.wa) {\n\t\tcase 'assets':\n\t\t\tassets = message.assets;\n\t\t\tbreak;\n\t\tcase 'asset':\n\t\t\tassets.push(message.asset);\n\t\t\tcoreEvents.triggerEvent('asset', message.asset);\n\t\t\tglobalObject.triggerEvent('asset', message.asset);\n\t\t\tbreak;\n\t}\n};\n\n/**\n * Get a list of all assets. Returns a frozen copy, so users won't (accidentally) modify it.\n * @return {obj} List of assets.\n * @public\n */\nglobalObject.publicObject.assets = Object.freeze(coreUtils.objectClone(assets));\n\n/**\n * Makes it possible to select and upload files .\n * @param  {Function} callback Callback with two arguments, error and response. First argument will\n *                             be null on success.\n * @public\n */\nglobalObject.publicObject.uploadAsset = (callback = () => {}) => {\n\tconst input = document.createElement('input');\n\tinput.setAttribute('multiple', true);\n\tinput.setAttribute('type', 'file');\n\n\tinput.addEventListener('change', event => {\n\t\tconst formData = new FormData();\n\t\tfor (let i=0; i < input.files.length; i++) {\n\t\t\tformData.append('file[]', input.files.item(i));\n\t\t}\n\t\tfetch('', {\n\t\t\tmethod: 'post',\n\t\t\tcredentials: 'include',\n\t\t\theaders: 'multipart/form-data',\n\t\t\tbody: formData\n\t\t})\n\t\t.then(res => callback(null, res))\n\t\t.catch(err => callback(err));\n\t});\n\n\tinput.click();\n};\n\nmodule.exports = assetsModule;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/assets.js\n// module id = 22\n// module chunks = 0","'use strict';\nconst coreEvents = require('./coreEvents');\nconst coreWebsocket = require('./coreWebsocket');\nconst globalObject = require('./globalObject');\nconst loadedEvent = require('./loadedEvent');\n\nconst clientManagerModule = {};\n\n// Create internal events that other modules may subscribe to\ncoreEvents.createEvent('clientsReceived');\ncoreEvents.createEvent('clientJoin');\ncoreEvents.createEvent('clientPart');\n\n// Delay the loaded event, until the 'clientsReceied' event has been triggered.\nloadedEvent.delayUntil('clientsReceived');\n\n// Create events in userland.\nglobalObject.createEvent('clientJoin');\nglobalObject.createEvent('clientPart');\n\nconst websocket = coreWebsocket.copy((event) => event.data.startsWith('{\"wa\":'));\n\nwebsocket.onjsonmessage = (message) => {\n\tswitch (message.wa) {\n\n\t\tcase 'hello':\n\t\t\tglobalObject.publicObject.clients = message.clients;\n\t\t\tglobalObject.publicObject.clientId = message.id;\n\t\t\tcoreEvents.triggerEvent('clientsReceived');\n\t\t\tbreak;\n\n\t\tcase 'clientJoin':\n\t\t\tcoreEvents.triggerEvent('clientJoin');\n\t\t\tglobalObject.triggerEvent('clientJoin');\n\t\t\tbreak;\n\n\t\tcase 'clientPart':\n\t\t\tcoreEvents.triggerEvent('clientPart');\n\t\t\tglobalObject.triggerEvent('clientPart');\n\t\t\tbreak;\n\n\t}\n};\n\n// The server delays firing the 'clientJoin' event until the joining client is ready.\n// If we didn't do that, another client might send a message to the joining client immediately after\n// the 'clientJoin' event has been triggered. At this point, however, the joining client's scripts\n// haven't been run (they usually aren't executed until after the userland 'loaded' event has been\n// triggered), so the joining client won't be able to receive the data. Therefore, we delay this\n// 'clientJoin' message, until after the userland 'loaded' event has been triggered, so that we know\n// the joining client will be ready to handle the reactions of the join.\n\n// Note that if the server doesn't receive a ready event within 2 seconds, it sends it out anyway.\n// That way, no clients can linger unnoticed in a document.\ncoreEvents.addEventListener('loadedTriggered', (webstrateId) => {\n\twebsocket.send({ wa: 'ready', d: webstrateId });\n});\n\n\nmodule.exports = clientManagerModule;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/clientManager.js\n// module id = 23\n// module chunks = 0","'use strict';\nconst coreEvents = require('./coreEvents');\nconst coreWebsocket = require('./coreWebsocket');\nconst globalObject = require('./globalObject');\n\n// Create internal events that other modules may subscribe to\ncoreEvents.createEvent('connect');\ncoreEvents.createEvent('disconnect');\ncoreEvents.createEvent('reconnect');\n\n// Create events in userland.\nglobalObject.createEvent('connect');\nglobalObject.createEvent('disconnect');\nglobalObject.createEvent('reconnect');\n\nconst websocket = coreWebsocket.copy();\n\nlet previousState = websocket.readyState;\n\nwebsocket.onopen = (event) => {\n\t// If this is the first time we're connecting.\n\tif (previousState === WebSocket.CONNECTING) {\n\t\tcoreEvents.triggerEvent('connect');\n\t\tglobalObject.triggerEvent('connect');\n\t// If we've been connected before.\n\t} else if (previousState === WebSocket.CLOSED) {\n\t\tcoreEvents.triggerEvent('reconnect');\n\t\tglobalObject.triggerEvent('reconnect');\n\t}\n\tpreviousState = websocket.readyState;\n};\n\nwebsocket.onerror = websocket.onclose = (event) => {\n\tpreviousState = websocket.readyState;\n\tcoreEvents.triggerEvent('disconnect');\n\tglobalObject.triggerEvent('disconnect');\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/connectionEvents.js\n// module id = 24\n// module chunks = 0","'use strict';\nconst coreWebsocket = require('./coreWebsocket');\nconst globalObject = require('./globalObject');\nconst userObject = require('./userObject');\n\nconst cookiesModule = {};\n\nconst websocket = coreWebsocket.copy((event) => event.data.startsWith('{\"wa\":'));\n\nglobalObject.createEvent('cookieUpdateHere');\nglobalObject.createEvent('cookieUpdateAnywhere');\n\nfunction updateCookie(key, value, isAnywhere = false) {\n\tvar updateObj = {\n\t\twa: 'cookieUpdate',\n\t\tupdate: { key, value }\n\t};\n\tif (!isAnywhere) {\n\t\tupdateObj.d = globalObject.webstrateObject.webstrateId;\n\t}\n\twebsocket.send(updateObj);\n}\n\nlet cookies;\nwebsocket.onjsonmessage = (message) => {\n\tswitch (message.wa) {\n\t\tcase 'hello':\n\t\t\tcookies = message.cookies || { here: {}, anywhere: {} };\n\n\t\t\t// Only allow cookies if the user object exists, i.e. is logged in with OAuth.\n\t\t\tif (userObject.publicObject.userId) {\n\t\t\t\tuserObject.publicObject.cookies = {\n\t\t\t\t\tanywhere: {\n\t\t\t\t\t\tget: function(key) {\n\t\t\t\t\t\t\treturn key ? cookies.anywhere[key] : cookies.anywhere;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset: function(key, value) {\n\t\t\t\t\t\t\tcookies.anywhere[key] = value;\n\t\t\t\t\t\t\tupdateCookie(key, value, true);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\there: {\n\t\t\t\t\t\tget: function(key) {\n\t\t\t\t\t\t\treturn key ? cookies.here[key] : cookies.here;\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset: function(key, value, callback) {\n\t\t\t\t\t\t\tcookies.here[key] = value;\n\t\t\t\t\t\t\tupdateCookie(key, value, false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'cookieUpdate':\n\t\t\tvar [key, value] = [message.update.key, message.update.value];\n\t\t\tif (message.d) {\n\t\t\t\tcookies.here[key] = value;\n\t\t\t\tglobalObject.triggerEvent('cookieUpdateHere', key, value);\n\t\t\t} else {\n\t\t\t\tcookies.anywhere[key] = value;\n\t\t\t\tglobalObject.triggerEvent('cookieUpdateAnywhere', key, value);\n\t\t\t}\n\t\t\tbreak;\n\t}\n};\n\nmodule.exports = cookiesModule;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/cookies.js\n// module id = 25\n// module chunks = 0","'use strict';\nconst coreEvents = require('./coreEvents');\n\n/**\n * Create public events on all webstrate objects on DOM nodes.\n * @param  {DOMNode} node       Node containing webstrate element.\n * @param  {Object} eventObject Event object associated to the webstrate element.\n * @private\n */\nfunction createEventsOnEventObject(node, eventObject) {\n\ttry {\n\t\tswitch (node.nodeType) {\n\t\t\tcase document.ELEMENT_NODE:\n\t\t\t\teventObject.createEvent('attributeChanged');\n\t\t\t\teventObject.createEvent('nodeAdded');\n\t\t\t\teventObject.createEvent('nodeRemoved');\n\t\t\t// falls through\n\t\t\tcase document.TEXT_NODE:\n\t\t\t\teventObject.createEvent('insertText');\n\t\t\t\teventObject.createEvent('deleteText');\n\t\t\t\tbreak;\n\t\t}\n\t} catch (e) {\n\t\tconsole.error('caught', e);\n\t}\n}\n\n// This gets triggered when the page has loaded initially and and nodes have had webstrate\n// objects added.\ncoreEvents.addEventListener('webstrateObjectsAdded', (nodes) => {\n\tnodes.forEach((eventObject, node) => createEventsOnEventObject(node, eventObject));\n\n\tcoreEvents.addEventListener('DOMAttributeSet', (node, attributeName, oldValue, newValue,\n\t\tlocal) => {\n\t\t// Finding the event object (i.e. the webstrate.on() related events) for the node and firing\n\t\t// the attributeChanged event in userland.\n\t\tconst eventObject = nodes.get(node);\n\t\teventObject.triggerEvent('attributeChanged', attributeName, oldValue, newValue, !!local);\n\t});\n\n\tcoreEvents.addEventListener('DOMAttributeRemoved', (node, attributeName, oldValue, local) => {\n\t\t// Finding the event object (i.e. the webstrate.on() related events) for the node and firing\n\t\t// the attributeChanged event in userland.\n\t\tconst eventObject = nodes.get(node);\n\t\teventObject.triggerEvent('attributeChanged', attributeName, oldValue, undefined, !!local);\n\t});\n\n\tcoreEvents.addEventListener('DOMNodeInserted', (node, parentElement, local) => {\n\t\t// Finding the event object of the parent instead of the node itself, as firing the event\n\t\t// on the node itself isn't very useful.\n\t\tconst eventObject = nodes.get(parentElement);\n\t\teventObject.triggerEvent('nodeAdded', node, !!local);\n\t});\n\n\tcoreEvents.addEventListener('DOMNodeDeleted', (node, parentElement, local) => {\n\t\t// Finding the event object of the parent instead of the node itself, as firing the event\n\t\t// on the node itself isn't very useful.\n\t\tconst eventObject = nodes.get(parentElement);\n\t\teventObject.triggerEvent('nodeRemoved', node, !!local);\n\t});\n\n\tcoreEvents.addEventListener('DOMAttributeTextInsertion', (node, attributeName, position,\n\t\tvalue, local) => {\n\t\t// Finding the event object (i.e. the webstrate.on() related events) for the node and firing\n\t\t// the attributeChanged event in userland.\n\t\tconst eventObject = nodes.get(node);\n\t\teventObject.triggerEvent('insertText', position, value, attributeName, !!local);\n\t});\n\n\tcoreEvents.addEventListener('DOMTextNodeInsertion', (node, parentElement, position, value,\n\t\tlocal) => {\n\t\tlet eventObject = nodes.get(node);\n\t\teventObject.triggerEvent('insertText', position, value, !!local);\n\t\t// Also trigger on parent.\n\t\tif (parentElement.nodeType === document.ELEMENT_NODE) {\n\t\t\teventObject = nodes.get(parentElement);\n\t\t\teventObject.triggerEvent('insertText', position, value, !!local);\n\t\t}\n\t});\n\n\tcoreEvents.addEventListener('DOMAttributeTextDeletion', (node, attributeName, position,\n\t\tvalue, local) => {\n\t\t// Finding the event object (i.e. the webstrate.on() related events) for the node and firing\n\t\t// the attributeChanged event in userland.\n\t\tconst eventObject = nodes.get(node);\n\t\teventObject.triggerEvent('deleteText', position, value, attributeName, !!local);\n\t});\n\n\tcoreEvents.addEventListener('DOMTextNodeDeletion', (node, parentElement, position, value,\n\t\tlocal) => {\n\t\tlet eventObject = nodes.get(node);\n\t\teventObject.triggerEvent('deleteText', position, value, !!local);\n\t\t// Also trigger on parent.\n\t\tif (parentElement.nodeType === document.ELEMENT_NODE) {\n\t\t\teventObject = nodes.get(parentElement);\n\t\t\teventObject.triggerEvent('deleteText', position, value, !!local);\n\t\t}\n\t});\n}, coreEvents.PRIORITY.IMMEDIATE);\n\n// This gets triggered when an node gets added after the initial page load.\ncoreEvents.addEventListener('webstrateObjectAdded', (node, eventObject) => {\n\tcreateEventsOnEventObject(node, eventObject);\n}, coreEvents.PRIORITY.IMMEDIATE);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/domEvents.js\n// module id = 26\n// module chunks = 0","'use strict';\nconst coreWebsocket = require('./coreWebsocket');\n\nconst websocket = coreWebsocket.copy();\nlet interval;\n\nwebsocket.onopen = (event) => {\n\tinterval = setInterval(() => {\n\t\twebsocket.send({ type: 'alive' });\n\t}, config.keepAliveInterval * 1000);\n};\n\nwebsocket.onclose = websocket.onerror = (event) => {\n\tclearInterval(interval);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/keepAlive.js\n// module id = 27\n// module chunks = 0","'use strict';\nconst coreEvents = require('./coreEvents');\nconst coreUtils = require('./coreUtils');\nconst coreWebsocket = require('./coreWebsocket');\nconst globalObject = require('./globalObject');\nconst userObject = require('./userObject');\nconst loadedEvent = require('./loadedEvent');\n\nconst permissionsModule = {};\n\n// Create internal events.\ncoreEvents.createEvent('globalPermissions');\ncoreEvents.createEvent('userPermissions');\n\n// Create events for userland.\nglobalObject.createEvent('permissionsChanged');\n\n// Delay the loaded event, until the 'globalPermissions' and 'userPermissions' events have been\n// triggered.\nloadedEvent.delayUntil('globalPermissions', 'userPermissions');\n\nconst websocket = coreWebsocket.copy((event) => event.data.startsWith('{\"wa\":'));\nlet doc, username, provider, userPermissions, defaultPermissionsList, permissionsList;\n\nfunction detectPermissionChanges(ops) {\n\tconst permissionsChanged = ops.some(op =>\n\t\top.p[0] && op.p[0] === 1 && op.p[1] && op.p[1] === 'data-auth');\n\n\t// If permissions have changed, we need to recalculate the user's permissions.\n\tif (permissionsChanged) {\n\t\tpermissionsList = permissionsModule.getPermissionsFromDocument(doc);\n\t\tcoreEvents.triggerEvent('globalPermissions', permissionsList);\n\t\tconst newUserPermissions = permissionsModule.getUserPermissions(username, provider);\n\t\tif (!coreUtils.objectEquals(userPermissions, newUserPermissions)) {\n\t\t\tuserPermissions = newUserPermissions;\n\t\t\tcoreEvents.triggerevent('userPermissions', userPermissions);\n\t\t}\n\t}\n}\n\npermissionsModule.getUserPermissions = (username, provider) => {\n\tlet activePermissionList = permissionsList;\n\t// If we found no permissions, resort to default permissions.\n\tif (!permissionsList || Object.keys(permissionsList).length === 0) {\n\t\t// If there's also no default permissions, we pretend every user has read-write permissions\n\t\t// lest we lock everybody out. We append a question mark to let the system know that these are\n\t\t// last-resort permissions.\n\t\tif (!defaultPermissionsList) {\n\t\t\treturn 'rw?';\n\t\t}\n\t\tactivePermissionList = defaultPermissionsList;\n\t}\n\n\tvar user = activePermissionList.find(user =>\n\t\tuser.username === username && user.provider === provider);\n\n\tif (user) {\n\t\treturn user.permissions;\n\t}\n\n\tvar anonymous = activePermissionList.find(user =>\n\t\tuser.username === 'anonymous' && user.provider === '');\n\n\treturn anonymous ? anonymous.permissions : '';\n};\n\npermissionsModule.getPermissionsFromDocument = (doc) => {\n\tif (doc && doc.data && doc.data[0] && doc.data[0] === 'html' &&\n\t\tdoc.data[1] && doc.data[1]['data-auth']) {\n\t\ttry {\n\t\t\treturn JSON.parse(doc.data[1]['data-auth'].replace(/'/g, '\"')\n\t\t\t\t.replace(/&quot;/g, '\"').replace(/&amp;/g, '&'));\n\t\t} catch (err) {\n\t\t\tconsole.warn('Couldn\\'t parse document permission');\n\t\t}\n\t}\n\treturn [];\n};\n\n/*\n * We need both doc, username, provider, permissionsList and defaultPermissionsList to be set before\n * we can emit permission events, so we create two promises, and wait until both have been resolved.\n */\nlet receivedDocumentPromise = new Promise((accept) => {\n\tcoreEvents.addEventListener('receivedDocument', (doc) => {\n\t\tpermissionsList = permissionsModule.getPermissionsFromDocument(doc);\n\t\tif (!globalObject.publicObject) {\n\t\t\tthrow new Error('Permissions loaded, but global webstrate object doesn\\'t exist.');\n\t\t}\n\t\tglobalObject.publicObject.permissions = permissionsList;\n\t\tcoreEvents.triggerEvent('globalPermissions', permissionsList);\n\t\taccept();\n\t});\n});\n\nlet helloMessageReceivedPromise = new Promise((accept) => {\n\twebsocket.onjsonmessage = (message) => {\n\t\tif (message.wa === 'hello') {\n\t\t\tusername = message.user.username;\n\t\t\tprovider = message.user.provider;\n\t\t\tdefaultPermissionsList = message.defaultPermissions;\n\t\t\tuserPermissions = permissionsModule.getUserPermissions(username, provider);\n\t\t\tif (!globalObject.publicObject || !userObject.publicObject) {\n\t\t\t\tthrow new Error('Permissions loaded, but global webstrate user object doesn\\'t exist.');\n\t\t\t}\n\t\t\tuserObject.publicObject.permissions = userPermissions;\n\t\t\tcoreEvents.triggerEvent('userPermissions', userPermissions);\n\t\t\taccept();\n\t\t}\n\t};\n});\n\nPromise.all([receivedDocumentPromise, helloMessageReceivedPromise]).then(() => {\n\tcoreEvents.addEventListener('receivedOps', detectPermissionChanges);\n\tcoreEvents.addEventListener('createdOps', detectPermissionChanges);\n});\n\nmodule.exports = permissionsModule;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/permissions.js\n// module id = 28\n// module chunks = 0","'use strict';\nconst coreUtils = require('./coreUtils');\nconst coreEvents = require('./coreEvents');\nconst globalObject = require('./globalObject');\nconst signaling = require('./signaling');\n\nconst signalStreamModule = {};\n\nlet clientId;\ncoreEvents.addEventListener('populated', (rootElement, _webstrateId) => {\n\tclientId = globalObject.publicObject.clientId;\n});\n\n// Mapping from wids to callbacks: string -> callback\nconst readyToStream = new Map();\nconst listeningForStreams = new Map();\n\nconst peerConnectionsOut = new Map();\nconst peerConnectionsIn = new Map();\n\n// Intercept streaming signals, so they're not processed as regular signals by the signaling module.\nsignaling.addInterceptor(payload => {\n\tconst message = payload.m;\n\tif (typeof message.__internal_webrtc === 'undefined') {\n\t\treturn false;\n\t}\n\n\t// No reason to do this all now, so we use setImmdiate.\n\tsetImmediate(handleSignal, payload);\n\treturn true;\n});\n\nfunction handleSignal(payload) {\n\tconst senderId = payload.s;\n\tconst message = payload.m;\n\n\t// Ignore our own messages.\n\tif (senderId === clientId) {\n\t\treturn;\n\t}\n\n\tconst wid = payload.id;\n\tconst node = coreUtils.getElementByWid(wid);\n\tif (!node && wid !== 'document') {\n\t\treturn;\n\t}\n\n\tconst webstrateObject = node ? node.webstrate : globalObject.publicObject;\n\n\t// An offerRequestRequest if when somebody comes in wanting to stream, they can send out an\n\t// offerRequestRequest. That is, a request for an offerRequest. The clients that may want to\n\t// receive the stream can then send back and offerRequest and get an offer in return.\n\t// It's like a guy walking into a bar, saying \"hey, if anybody wants a beer, just as for it\"\n\t// (offerRequestRequest). Another guy then responds with \"Yea, I want a bear\" (offerRequest),\n\t// and the first guy then says \"Okay, you can have a beer\" (offer). The offer is the stream.\n\t// So when a client receives this and they're listening for a stream, they can send out an\n\t// offerRequst as a reply.\n\tif (message.__internal_webrtc === 'offerRequestRequest' && listeningForStreams.has(wid)) {\n\t\tnode.webstrate.signal({\n\t\t\t__internal_webrtc: 'offerRequest'\n\t\t});\n\t\treturn;\n\t}\n\n\t// Somebody wants to listen to our stream, so they send out an offer request (as described above),\n\t// to which we reply with an offer.\n\tif (message.__internal_webrtc === 'offerRequest' && readyToStream.has(wid)) {\n\t\tconst callback = readyToStream.get(wid);\n\n\t\tcallback(senderId, function(stream, meta, onConnectCallback) {\n\t\t\tconst peerConnection = new RTCPeerConnection(config.peerConnectionConfig);\n\t\t\tconst streamId = coreUtils.randomString();\n\t\t\tpeerConnectionsOut.set(streamId, peerConnection);\n\n\t\t\tconst onCloseCallbacks = [];\n\n\t\t\t// Also send out any ICE candidates we might have.\n\t\t\tpeerConnection.onicecandidate = function(event) {\n\t\t\t\tif (!event.candidate) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twebstrateObject.signal({\n\t\t\t\t\t__internal_webrtc: 'iceCandidate',\n\t\t\t\t\tstreamId: streamId,\n\t\t\t\t\ticeCandidate: event.candidate\n\t\t\t\t}, senderId);\n\t\t\t};\n\n\t\t\tpeerConnection.oniceconnectionstatechange = function(event) {\n\t\t\t\tswitch (peerConnection.iceConnectionState) {\n\t\t\t\t\tcase 'connected':\n\t\t\t\t\t\tonConnectCallback && onConnectCallback();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'disconnected':\n\t\t\t\t\t\tonCloseCallbacks.forEach(function(callback) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Add the actual stream.\n\t\t\tpeerConnection.addStream(stream);\n\n\t\t\t// Send offer to the client requesting to get our stream.\n\t\t\tpeerConnection.createOffer().then(function(description) {\n\t\t\t\tpeerConnection.setLocalDescription(description).then(function() {\n\t\t\t\t\twebstrateObject.signal({\n\t\t\t\t\t\t__internal_webrtc: 'offer',\n\t\t\t\t\t\tstreamId: streamId,\n\t\t\t\t\t\tdescription: description,\n\t\t\t\t\t\tmeta: meta\n\t\t\t\t\t}, senderId);\n\t\t\t\t}).catch(function(err) {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t});\n\t\t\t}).catch(function(err) {\n\t\t\t\tconsole.error(err);\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tclose: function() {\n\t\t\t\t\treturn peerConnection.close();\n\t\t\t\t},\n\t\t\t\tonclose: function(callback) {\n\t\t\t\t\tonCloseCallbacks.push(callback);\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\treturn;\n\t}\n\n\t// Client listening for stream receives an offer.\n\tif (message.__internal_webrtc === 'offer' && listeningForStreams.has(wid)) {\n\t\tconst callback = listeningForStreams.get(wid);\n\t\tcallback(senderId, message.meta, function approveOffer(streamCallback) {\n\t\t\tvar peerConnection = new RTCPeerConnection(config.peerConnectionConfig);\n\t\t\tpeerConnectionsIn[message.streamId] = peerConnection;\n\t\t\tpeerConnection.setRemoteDescription(new RTCSessionDescription(message.description))\n\t\t\t.then(function() {\n\t\t\t\tpeerConnection.createAnswer().then(function(description) {\n\t\t\t\t\tpeerConnection.setLocalDescription(description).then(function() {\n\t\t\t\t\t\twebstrateObject.signal({\n\t\t\t\t\t\t\t__internal_webrtc: 'answer',\n\t\t\t\t\t\t\tstreamId: message.streamId,\n\t\t\t\t\t\t\tdescription: description\n\t\t\t\t\t\t}, senderId);\n\t\t\t\t\t}).catch(function(err) {\n\t\t\t\t\t\tconsole.error(err);\n\t\t\t\t\t});\n\t\t\t\t}).catch(function(err) {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t});\n\t\t\t}).catch(function(err) {\n\t\t\t\tconsole.error(err);\n\t\t\t});\n\n\t\t\tpeerConnection.onicecandidate = function(event) {\n\t\t\t\tif (!event.candidate) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\twebstrateObject.signal({\n\t\t\t\t\t__internal_webrtc: 'iceCandidate',\n\t\t\t\t\tstreamId: message.streamId,\n\t\t\t\t\ticeCandidate: event.candidate\n\t\t\t\t}, senderId);\n\t\t\t};\n\n\t\t\t// `onaddstream` is deprecated, but the replacement `ontrack` isn't implemented.\n\t\t\tvar stream;\n\t\t\tpeerConnection.onaddstream = function(event) {\n\t\t\t\tstream = event.stream;\n\t\t\t};\n\n\t\t\tpeerConnection.oniceconnectionstatechange = function(event) {\n\t\t\t\tswitch (peerConnection.iceConnectionState) {\n\t\t\t\t\tcase 'connected':\n\t\t\t\t\t\twebstrateObject.off('signalStream', callback);\n\t\t\t\t\t\tstreamCallback(stream);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'disconnected':\n\t\t\t\t\t\tonCloseCallbacks.forEach(function(callback) {\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tvar onCloseCallbacks = [];\n\t\t\treturn {\n\t\t\t\tclose: function() {\n\t\t\t\t\treturn peerConnection.close();\n\t\t\t\t},\n\t\t\t\tonclose: function(callback) {\n\t\t\t\t\tonCloseCallbacks.push(callback);\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\treturn;\n\t}\n\n\tif (message.__internal_webrtc === 'iceCandidate' && peerConnectionsOut.has(message.streamId)) {\n\t\tconst peerConnection = peerConnectionsOut.get(message.streamId);\n\t\tpeerConnection.addIceCandidate(new RTCIceCandidate(message.iceCandidate));\n\t\treturn;\n\t}\n\n\tif (message.__internal_webrtc === 'answer' && peerConnectionsOut.has(message.streamId)) {\n\t\tconst peerConnection = peerConnectionsOut.get(message.streamId);\n\t\tpeerConnection.setRemoteDescription(new RTCSessionDescription(message.description))\n\t\t.then(function() {\n\t\t}).catch(function(err) {\n\t\t\tconsole.error(err);\n\t\t});\n\t\treturn;\n\n\t}\n}\n\nfunction setupSignalStream(publicObject, eventObject) {\n\tconst wid = publicObject.id;\n\n\t// Text nodes and transient elements won't have wids, meaning there's way for us to signal on\n\t// them, and thus it'd be pointless to add a signaling method and event.\n\tif (!wid) return;\n\n\t// A mapping from user callbacks to our internal callbacks: fn -> fn.\n\t//const callbacks = new Map();\n\n\tObject.defineProperty(publicObject, 'signalStream', {\n\t\tvalue: (callback, recipients) => {\n\t\t\treadyToStream.set(wid, callback);\n\t\t\t// Manually subscribe to signals on the node. We don't use the regular public on handler here,\n\t\t\t// because we intercept all the signals ourselves anyway, so the callback would never get\n\t\t\t// triggered.\n\t\t\tsignaling.subscribe(wid);\n\t\t\tpublicObject.signal({\n\t\t\t\t__internal_webrtc: 'offerRequestRequest'\n\t\t\t});\n\t\t},\n\t\twritable: false\n\t});\n\n\tObject.defineProperty(publicObject, 'stopStreamSignal', {\n\t\tvalue: (callback) => {\n\t\t\tpublicObject.off('signal', callback);\n\t\t\treadyToStream.delete(wid);\n\t\t},\n\t\twritable: false\n\t});\n\n\teventObject.createEvent('signalStream', {\n\t\t// TODO Should be possible to add multiple callbacks to each wid, so the structure should be\n\t\t// Map<<wid>, Set<callback>>.\n\t\t// TODO: Also note that since we don't trigger the signalStream event at all through the\n\t\t// nodeObjects module, we could add some optmization here, so the callbacks aren't actually\n\t\t// added to nodeObjects.\n\t\taddListener: (callback) => {\n\t\t\tlisteningForStreams.set(wid, callback);\n\t\t\tsignaling.subscribe(wid);\n\t\t\tpublicObject.signal({\n\t\t\t\t__internal_webrtc: 'offerRequest'\n\t\t\t});\n\t\t},\n\t\tremoveListener: (callback) => {\n\t\t\tsignaling.unsubscribe(wid);\n\t\t\tlisteningForStreams.delete(wid);\n\t\t},\n\t});\n}\n\nsetupSignalStream(globalObject.publicObject, globalObject);\n\n// Add signalStream events to all webstrate objects (with a wid) after the document has been\n// populated.\ncoreEvents.addEventListener('webstrateObjectsAdded', (nodes) => {\n\tnodes.forEach((eventObject, node) => setupSignalStream(node.webstrate, eventObject));\n}, coreEvents.PRIORITY.IMMEDIATE);\n\n// Add signalStream events to all webstrate objects (with wid) after they're added continually.\ncoreEvents.addEventListener('webstrateObjectAdded', (node, eventObject) => {\n\tsetupSignalStream(node.webstrate, eventObject);\n}, coreEvents.PRIORITY.IMMEDIATE);\n\nmodule.exports = signalStreamModule;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/signalStream.js\n// module id = 29\n// module chunks = 0","'use strict';\nconst coreUtils = require('./coreUtils');\nconst coreEvents = require('./coreEvents');\nconst coreWebsocket = require('./coreWebsocket');\nconst globalObject = require('./globalObject');\n\nconst taggingModule = {};\n\ncoreEvents.createEvent('receivedTags');\nglobalObject.createEvent('tag');\nglobalObject.createEvent('untag');\n\nlet doc, currentTag, allTags = {}, futureTags = {};\n\nconst websocket = coreWebsocket.copy(event => event.data.startsWith('{\"wa\":'));\n\nwebsocket.onjsonmessage = (message) => {\n\tswitch (message.wa) {\n\n\t\tcase 'tags': {\n\t\t\tmessage.tags.forEach((tag) => {\n\t\t\t\tallTags[tag.v] = tag.label;\n\t\t\t});\n\t\t\tcoreEvents.triggerEvent('receivedTags', allTags);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'tag': {\n\t\t\tlet label = message.l;\n\t\t\tlet version = message.v;\n\n\t\t\t// The label may already be in use, but since labels are unique, we should remove it.\n\t\t\tlet existingVersion = Object.keys(allTags).find(candidateVersion =>\n\t\t\t\tallTags[candidateVersion] === label);\n\n\t\t\tif (existingVersion) {\n\t\t\t\tdelete allTags[existingVersion];\n\t\t\t}\n\n\t\t\tallTags[version] = label;\n\t\t\tif (doc.version === version) {\n\t\t\t\tcurrentTag = label;\n\t\t\t} else if (version > doc.version) {\n\t\t\t\tfutureTags[version] = label;\n\t\t\t}\n\n\t\t\tglobalObject.triggerEvent('tag', version, label);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase 'untag': {\n\t\t\tlet label = message.l;\n\t\t\tlet version = message.v;\n\n\t\t\tif (!version && label) {\n\t\t\t\tversion = Object.keys(allTags).find(candidateVersion =>\n\t\t\t\t\tallTags[candidateVersion] === label);\n\t\t\t}\n\t\t\tdelete allTags[version];\n\n\t\t\tglobalObject.triggerEvent('untag', version);\n\t\t\tbreak;\n\t\t}\n\n\t}\n};\n\n// When an op comes in, the document version changes and so does the tag. In rare cases, we may have\n// received a tag for a version we were yet to be in at the time, in which case we may already know\n// the tag of the new version, but most likely, this will set currentTag to undefined.\nfunction moveFutureTags() {\n\tcurrentTag = futureTags[doc.version];\n\t// Move all futureTags that are no longer \"future\" into allTags.\n\tObject.keys(futureTags).forEach(function(futureVersion) {\n\t\tif (futureVersion <= doc.version) {\n\t\t\tallTags[futureVersion] = futureTags[futureVersion];\n\t\t\tdelete futureTags[futureVersion];\n\t\t}\n\t});\n}\n\n// We can't set the currentTag until we have received all the tags and the document, so we know the\n// current version of the current. Therefore, we wait until both the document and tags have been\n// received using the promises below.\nconst docPromise = new Promise((accept, reject) => {\n\tcoreEvents.addEventListener('receivedDocument', doc => accept(doc));\n});\n\nconst tagsPromise = new Promise((accept, reject) => {\n\tcoreEvents.addEventListener('receivedTags', tags => accept(tags));\n});\n\n// We use two promises below, one just for doc and one for tags. In static mode, we won't receive\n// the tags, thus the document will never get set.\n// We can't just have two single promises, in case the tags promise gets resolved before the doc\n// promise.\n// TODO: Make sure we receive tags in static mode as well.\ndocPromise.then(_doc => {\n\tdoc = _doc;\n});\n\nPromise.all([docPromise, tagsPromise]).then(([_doc, tags]) => {\n\tcurrentTag = tags[doc.version];\n\n\t// We wait for both the document (so we know the version) and the tags to come in, before we can\n\t// start moving the currentTag 'tag pointer'.\n\tcoreEvents.addEventListener('receivedOps', moveFutureTags);\n\tcoreEvents.addEventListener('createdOps', moveFutureTags);\n});\n\n// Define functions on the global webstrate object to allow tagging and untagging.\n\n/**\n * Tag a document with a label at a specific version.\n * @param  {string} label    Tag label.\n * @param  {integer} version Version.\n * @public\n */\nglobalObject.publicObject.tag = (label, version) => {\n\tif (!label && !version) {\n\t\treturn currentTag;\n\t}\n\n\tif (/^\\d/.test(label)) {\n\t\tthrow new Error('Tag name should not begin with a number');\n\t}\n\n\tif (!version) {\n\t\tversion = doc.version;\n\t}\n\n\tif (isNaN(version)) {\n\t\tthrow new Error('Version must be a number');\n\t}\n\n\tif (allTags[doc.version] === label) return;\n\tallTags[doc.version] = label;\n\twebsocket.send({\n\t\twa: 'tag',\n\t\td: doc.id,\n\t\tv: version,\n\t\tl: label\n\t});\n};\n\n/**\n * Untag a document with a tag or version\n * @param  {mixed} tagOrVersion Tag or version.\n * @public\n */\nglobalObject.publicObject.untag = (tagOrVersion) => {\n\tif (!tagOrVersion) {\n\t\tthrow new Error('Tag label or version number must he provided');\n\t}\n\n\tconst msgObj = {\n\t\twa: 'untag',\n\t\td: doc.id,\n\t};\n\n\tlet version;\n\n\t// If tagOrVersion begins with a digit, we know it's a version.\n\tif (/^\\d/.test(tagOrVersion)) {\n\t\tversion = tagOrVersion;\n\t} else {\n\t\t// If it's a tag label, find the corresponding version.\n\t\tversion = Object.keys(allTags).find(candidateVersion =>\n\t\t\tallTags[candidateVersion] === tagOrVersion);\n\t}\n\n\tmsgObj.v = version;\n\n\tif (!version) {\n\t\tthrow new Error('Provided tag does not exist');\n\t}\n\n\tdelete allTags[version];\n\twebsocket.send(msgObj);\n};\n\nObject.defineProperty(globalObject.publicObject, 'version', {\n\t// If our document is an instance of sharedb.Doc (which it will be, unless we're requesting\n\t// a static version of the document), then doc.version is defined. If doc is just a plain\n\t// JavaScript object, the doc.version will be undefined, but doc.v will exist.\n\tget: () => doc.version || doc.v,\n\tset: (v) => { throw new Error('Version is read-only'); }\n});\n\n/**\n * Get a object of all tags. Returns a frozen copy, so users won't (accidentally) modify it.\n * @return {obj} Object with tags, indexed by version number.\n * @public\n */\nglobalObject.publicObject.tags = () => Object.freeze(coreUtils.objectClone(allTags));\n\nmodule.exports = taggingModule;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/tagging.js\n// module id = 30\n// module chunks = 0","'use strict';\nconst coreEvents = require('./coreEvents');\nconst globalObject = require('./globalObject');\n\nfunction referrerDomain() {\n\tvar a = document.createElement('a');\n\ta.href = document.referrer;\n\treturn a.host;\n}\n\n// If webstrate is transcluded in an iframe, we should probably raise an event on the frame element\n// in the parent document, so the parent document can trigger the transcluded event.\nif (window.frameElement) {\n\t// If the domain of the iframe we're in is different from the parent's domain, we shouldn't raise\n\t// we won't be allowed to access frameElement due to cross-domain restrictions on iframes.\n\tif (referrerDomain() === location.host) {\n\t\tcoreEvents.addEventListener('populated', () => {\n\t\t\twindow.frameElement.dispatchEvent(new CustomEvent('transcluded', {\n\t\t\t\tdetail: [\n\t\t\t\t\tglobalObject.publicObject.webstrateId,\n\t\t\t\t\tglobalObject.publicObject.clientId,\n\t\t\t\t\tglobalObject.publicObject.user\n\t\t\t\t],\n\t\t\t\tbubbles: true,\n\t\t\t\tcancelable: true\n\t\t\t}));\n\t\t}, coreEvents.PRIORITY.LAST);\n\t}\n}\n\n/**\n * Add 'transcluded' event to iframe. Do nothing if called with an element that is not an iframe.\n * @param {DOMNode} node       DOMNode.\n * @param {Object} eventObject Event object associated with the given DOM Node. This is the object\n *                             we should add the 'transcluded' event to if the node is an iframe.\n * @private\n */\nfunction addTransclusionEvent(node, eventObject) {\n\t/*if (node instanceof HTMLIFrameElement) {\n\t\tlet transcludedTriggered = false;\n\t\tlet eventDetails;\n\t\teventObject.createEvent('transcluded', {\n\t\t\taddListener: callback => {\n\t\t\t\tif (transcludedTriggered) {\n\t\t\t\t\tsetImmediate(callback, ...eventDetails);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tdocument.addEventListener('transcluded', (event) => {\n\t\t\tif (event.target === node) {\n\t\t\t\ttranscludedTriggered = true;\n\t\t\t\teventDetails = event.detail;\n\t\t\t\teventObject.triggerEvent('transcluded', ...eventDetails);\n\t\t\t}\n\t\t});\n\t}*/\n}\n\n// Wait for all webstrate objects to be defined, then create a transcluded event on all iframe\n// elements and trigger the event once it has loaded (i.e. been populated).\ncoreEvents.addEventListener('webstrateObjectsAdded', (nodes) => {\n\tnodes.forEach((eventObject, node) => addTransclusionEvent(node, eventObject));\n}, coreEvents.PRIORITY.IMMEDIATE);\n\n// Also listen for future webstrate objects that gets added.\ncoreEvents.addEventListener('webstrateObjectAdded', (node, eventObject) => {\n\taddTransclusionEvent(node, eventObject);\n}, coreEvents.PRIORITY.IMMEDIATE);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates/transclusionEvent.js\n// module id = 31\n// module chunks = 0","// These methods let you build a transform function from a transformComponent\n// function for OT types like JSON0 in which operations are lists of components\n// and transforming them requires N^2 work. I find it kind of nasty that I need\n// this, but I'm not really sure what a better solution is. Maybe I should do\n// this automatically to types that don't have a compose function defined.\n\n// Add transform and transformX functions for an OT type which has\n// transformComponent defined.  transformComponent(destination array,\n// component, other component, side)\nmodule.exports = bootstrapTransform\nfunction bootstrapTransform(type, transformComponent, checkValidOp, append) {\n  var transformComponentX = function(left, right, destLeft, destRight) {\n    transformComponent(destLeft, left, right, 'left');\n    transformComponent(destRight, right, left, 'right');\n  };\n\n  var transformX = type.transformX = function(leftOp, rightOp) {\n    checkValidOp(leftOp);\n    checkValidOp(rightOp);\n    var newRightOp = [];\n\n    for (var i = 0; i < rightOp.length; i++) {\n      var rightComponent = rightOp[i];\n\n      // Generate newLeftOp by composing leftOp by rightComponent\n      var newLeftOp = [];\n      var k = 0;\n      while (k < leftOp.length) {\n        var nextC = [];\n        transformComponentX(leftOp[k], rightComponent, newLeftOp, nextC);\n        k++;\n\n        if (nextC.length === 1) {\n          rightComponent = nextC[0];\n        } else if (nextC.length === 0) {\n          for (var j = k; j < leftOp.length; j++) {\n            append(newLeftOp, leftOp[j]);\n          }\n          rightComponent = null;\n          break;\n        } else {\n          // Recurse.\n          var pair = transformX(leftOp.slice(k), nextC);\n          for (var l = 0; l < pair[0].length; l++) {\n            append(newLeftOp, pair[0][l]);\n          }\n          for (var r = 0; r < pair[1].length; r++) {\n            append(newRightOp, pair[1][r]);\n          }\n          rightComponent = null;\n          break;\n        }\n      }\n\n      if (rightComponent != null) {\n        append(newRightOp, rightComponent);\n      }\n      leftOp = newLeftOp;\n    }\n    return [leftOp, newRightOp];\n  };\n\n  // Transforms op with specified type ('left' or 'right') by otherOp.\n  type.transform = function(op, otherOp, type) {\n    if (!(type === 'left' || type === 'right'))\n      throw new Error(\"type must be 'left' or 'right'\");\n\n    if (otherOp.length === 0) return op;\n\n    if (op.length === 1 && otherOp.length === 1)\n      return transformComponent([], op[0], otherOp[0], type);\n\n    if (type === 'left')\n      return transformX(op, otherOp)[0];\n    else\n      return transformX(otherOp, op)[1];\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ot-json0/lib/bootstrapTransform.js\n// module id = 32\n// module chunks = 0","var emitter = require('../emitter');\nvar ShareDBError = require('../error');\nvar types = require('../types');\n\n/**\n * A Doc is a client's view on a sharejs document.\n *\n * It is is uniquely identified by its `id` and `collection`.  Documents\n * should not be created directly. Create them with connection.get()\n *\n *\n * Subscriptions\n * -------------\n *\n * We can subscribe a document to stay in sync with the server.\n *   doc.subscribe(function(error) {\n *     doc.subscribed // = true\n *   })\n * The server now sends us all changes concerning this document and these are\n * applied to our data. If the subscription was successful the initial\n * data and version sent by the server are loaded into the document.\n *\n * To stop listening to the changes we call `doc.unsubscribe()`.\n *\n * If we just want to load the data but not stay up-to-date, we call\n *   doc.fetch(function(error) {\n *     doc.data // sent by server\n *   })\n *\n *\n * Events\n * ------\n *\n * You can use doc.on(eventName, callback) to subscribe to the following events:\n * - `before op (op, source)` Fired before a partial operation is applied to the data.\n *   It may be used to read the old data just before applying an operation\n * - `op (op, source)` Fired after every partial operation with this operation as the\n *   first argument\n * - `create (source)` The document was created. That means its type was\n *   set and it has some initial data.\n * - `del (data, source)` Fired after the document is deleted, that is\n *   the data is null. It is passed the data before delteion as an\n *   arguments\n * - `load ()` Fired when a new snapshot is ingested from a fetch, subscribe, or query\n */\n\nmodule.exports = Doc;\nfunction Doc(connection, collection, id) {\n  emitter.EventEmitter.call(this);\n\n  this.connection = connection;\n\n  this.collection = collection;\n  this.id = id;\n\n  this.version = null;\n  this.type = null;\n  this.data = undefined;\n\n  // Array of callbacks or nulls as placeholders\n  this.inflightFetch = [];\n  this.inflightSubscribe = [];\n  this.inflightUnsubscribe = [];\n  this.pendingFetch = [];\n\n  // Whether we think we are subscribed on the server. Synchronously set to\n  // false on calls to unsubscribe and disconnect. Should never be true when\n  // this.wantSubscribe is false\n  this.subscribed = false;\n  // Whether to re-establish the subscription on reconnect\n  this.wantSubscribe = false;\n\n  // The op that is currently roundtripping to the server, or null.\n  //\n  // When the connection reconnects, the inflight op is resubmitted.\n  //\n  // This has the same format as an entry in pendingOps\n  this.inflightOp = null;\n\n  // All ops that are waiting for the server to acknowledge this.inflightOp\n  // This used to just be a single operation, but creates & deletes can't be\n  // composed with regular operations.\n  //\n  // This is a list of {[create:{...}], [del:true], [op:...], callbacks:[...]}\n  this.pendingOps = [];\n\n  // The OT type of this document. An uncreated document has type `null`\n  this.type = null;\n\n  // The applyStack enables us to track any ops submitted while we are\n  // applying an op incrementally. This value is an array when we are\n  // performing an incremental apply and null otherwise. When it is an array,\n  // all submitted ops should be pushed onto it. The `_otApply` method will\n  // reset it back to null when all incremental apply loops are complete.\n  this.applyStack = null;\n\n  // Disable the default behavior of composing submitted ops. This is read at\n  // the time of op submit, so it may be toggled on before submitting a\n  // specifc op and toggled off afterward\n  this.preventCompose = false;\n}\nemitter.mixin(Doc);\n\nDoc.prototype.destroy = function(callback) {\n  var doc = this;\n  doc.whenNothingPending(function() {\n    doc.connection._destroyDoc(doc);\n    if (doc.wantSubscribe) {\n      return doc.unsubscribe(callback);\n    }\n    if (callback) callback();\n  });\n};\n\n\n// ****** Manipulating the document data, version and type.\n\n// Set the document's type, and associated properties. Most of the logic in\n// this function exists to update the document based on any added & removed API\n// methods.\n//\n// @param newType OT type provided by the ottypes library or its name or uri\nDoc.prototype._setType = function(newType) {\n  if (typeof newType === 'string') {\n    newType = types.map[newType];\n  }\n\n  if (newType) {\n    this.type = newType;\n\n  } else if (newType === null) {\n    this.type = newType;\n    // If we removed the type from the object, also remove its data\n    this.data = undefined;\n\n  } else {\n    var err = new ShareDBError(4008, 'Missing type ' + newType);\n    return this.emit('error', err);\n  }\n};\n\n// Ingest snapshot data. This data must include a version, snapshot and type.\n// This is used both to ingest data that was exported with a webpage and data\n// that was received from the server during a fetch.\n//\n// @param snapshot.v    version\n// @param snapshot.data\n// @param snapshot.type\n// @param callback\nDoc.prototype.ingestSnapshot = function(snapshot, callback) {\n  if (!snapshot) return callback && callback();\n\n  if (typeof snapshot.v !== 'number') {\n    var err = new ShareDBError(5008, 'Missing version in ingested snapshot. ' + this.collection + '.' + this.id);\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n\n  // If the doc is already created or there are ops pending, we cannot use the\n  // ingested snapshot and need ops in order to update the document\n  if (this.type || this.hasWritePending()) {\n    // The version should only be null on a created document when it was\n    // created locally without fetching\n    if (this.version == null) {\n      if (this.hasWritePending()) {\n        // If we have pending ops and we get a snapshot for a locally created\n        // document, we have to wait for the pending ops to complete, because\n        // we don't know what version to fetch ops from. It is possible that\n        // the snapshot came from our local op, but it is also possible that\n        // the doc was created remotely (which would conflict and be an error)\n        return callback && this.once('no write pending', callback);\n      }\n      // Otherwise, we've encounted an error state\n      var err = new ShareDBError(5009, 'Cannot ingest snapshot in doc with null version. ' + this.collection + '.' + this.id);\n      if (callback) return callback(err);\n      return this.emit('error', err);\n    }\n    // If we got a snapshot for a version further along than the document is\n    // currently, issue a fetch to get the latest ops and catch us up\n    if (snapshot.v > this.version) return this.fetch(callback);\n    return callback && callback();\n  }\n\n  // Ignore the snapshot if we are already at a newer version. Under no\n  // circumstance should we ever set the current version backward\n  if (this.version > snapshot.v) return callback && callback();\n\n  this.version = snapshot.v;\n  var type = (snapshot.type === undefined) ? types.defaultType : snapshot.type;\n  this._setType(type);\n  this.data = (this.type && this.type.deserialize) ?\n    this.type.deserialize(snapshot.data) :\n    snapshot.data;\n  this.emit('load');\n  callback && callback();\n};\n\nDoc.prototype.whenNothingPending = function(callback) {\n  if (this.hasPending()) {\n    this.once('nothing pending', callback);\n    return;\n  }\n  callback();\n};\n\nDoc.prototype.hasPending = function() {\n  return !!(\n    this.inflightOp ||\n    this.pendingOps.length ||\n    this.inflightFetch.length ||\n    this.inflightSubscribe.length ||\n    this.inflightUnsubscribe.length ||\n    this.pendingFetch.length\n  );\n};\n\nDoc.prototype.hasWritePending = function() {\n  return !!(this.inflightOp || this.pendingOps.length);\n};\n\nDoc.prototype._emitNothingPending = function() {\n  if (this.hasWritePending()) return;\n  this.emit('no write pending');\n  if (this.hasPending()) return;\n  this.emit('nothing pending');\n};\n\n// **** Helpers for network messages\n\nDoc.prototype._emitResponseError = function(err, callback) {\n  if (callback) {\n    callback(err);\n    this._emitNothingPending();\n    return;\n  }\n  this._emitNothingPending();\n  this.emit('error', err);\n};\n\nDoc.prototype._handleFetch = function(err, snapshot) {\n  var callback = this.inflightFetch.shift();\n  if (err) return this._emitResponseError(err, callback);\n  this.ingestSnapshot(snapshot, callback);\n  this._emitNothingPending();\n};\n\nDoc.prototype._handleSubscribe = function(err, snapshot) {\n  var callback = this.inflightSubscribe.shift();\n  if (err) return this._emitResponseError(err, callback);\n  // Indicate we are subscribed only if the client still wants to be. In the\n  // time since calling subscribe and receiving a response from the server,\n  // unsubscribe could have been called and we might already be unsubscribed\n  // but not have received the response. Also, because requests from the\n  // client are not serialized and may take different async time to process,\n  // it is possible that we could hear responses back in a different order\n  // from the order originally sent\n  if (this.wantSubscribe) this.subscribed = true;\n  this.ingestSnapshot(snapshot, callback);\n  this._emitNothingPending();\n};\n\nDoc.prototype._handleUnsubscribe = function(err) {\n  var callback = this.inflightUnsubscribe.shift();\n  if (err) return this._emitResponseError(err, callback);\n  if (callback) callback();\n  this._emitNothingPending();\n};\n\nDoc.prototype._handleOp = function(err, message) {\n  if (err) {\n    if (this.inflightOp) {\n      // The server has rejected submission of the current operation. If we get\n      // an error code 4002 \"Op submit rejected\", this was done intentionally\n      // and we should roll back but not return an error to the user.\n      if (err.code === 4002) err = null;\n      return this._rollback(err);\n    }\n    return this.emit('error', err);\n  }\n\n  if (this.inflightOp &&\n      message.src === this.inflightOp.src &&\n      message.seq === this.inflightOp.seq) {\n    // The op has already been applied locally. Just update the version\n    // and pending state appropriately\n    this._opAcknowledged(message);\n    return;\n  }\n\n  if (this.version == null || message.v > this.version) {\n    // This will happen in normal operation if we become subscribed to a\n    // new document via a query. It can also happen if we get an op for\n    // a future version beyond the version we are expecting next. This\n    // could happen if the server doesn't publish an op for whatever reason\n    // or because of a race condition. In any case, we can send a fetch\n    // command to catch back up.\n    //\n    // Fetch only sends a new fetch command if no fetches are inflight, which\n    // will act as a natural debouncing so we don't send multiple fetch\n    // requests for many ops received at once.\n    this.fetch();\n    return;\n  }\n\n  if (message.v < this.version) {\n    // We can safely ignore the old (duplicate) operation.\n    return;\n  }\n\n  if (this.inflightOp) {\n    var transformErr = transformX(this.inflightOp, message);\n    if (transformErr) return this._hardRollback(transformErr);\n  }\n\n  for (var i = 0; i < this.pendingOps.length; i++) {\n    var transformErr = transformX(this.pendingOps[i], message);\n    if (transformErr) return this._hardRollback(transformErr);\n  }\n\n  this.version++;\n  this._otApply(message, false);\n  return;\n};\n\n// Called whenever (you guessed it!) the connection state changes. This will\n// happen when we get disconnected & reconnect.\nDoc.prototype._onConnectionStateChanged = function() {\n  if (this.connection.canSend) {\n    this.flush();\n    this._resubscribe();\n  } else {\n    if (this.inflightOp) {\n      this.pendingOps.unshift(this.inflightOp);\n      this.inflightOp = null;\n    }\n    this.subscribed = false;\n    if (this.inflightFetch.length || this.inflightSubscribe.length) {\n      this.pendingFetch = this.pendingFetch.concat(this.inflightFetch, this.inflightSubscribe);\n      this.inflightFetch.length = 0;\n      this.inflightSubscribe.length = 0;\n    }\n    if (this.inflightUnsubscribe.length) {\n      var callbacks = this.inflightUnsubscribe;\n      this.inflightUnsubscribe = [];\n      callEach(callbacks);\n    }\n  }\n};\n\nDoc.prototype._resubscribe = function() {\n  var callbacks = this.pendingFetch;\n  this.pendingFetch = [];\n\n  if (this.wantSubscribe) {\n    if (callbacks.length) {\n      this.subscribe(function(err) {\n        callEach(callbacks, err);\n      });\n      return;\n    }\n    this.subscribe();\n    return;\n  }\n\n  if (callbacks.length) {\n    this.fetch(function(err) {\n      callEach(callbacks, err);\n    });\n  }\n};\n\n// Request the current document snapshot or ops that bring us up to date\nDoc.prototype.fetch = function(callback) {\n  if (this.connection.canSend) {\n    var isDuplicate = this.connection.sendFetch(this);\n    pushActionCallback(this.inflightFetch, isDuplicate, callback);\n    return;\n  }\n  this.pendingFetch.push(callback);\n};\n\n// Fetch the initial document and keep receiving updates\nDoc.prototype.subscribe = function(callback) {\n  this.wantSubscribe = true;\n  if (this.connection.canSend) {\n    var isDuplicate = this.connection.sendSubscribe(this);\n    pushActionCallback(this.inflightSubscribe, isDuplicate, callback);\n    return;\n  }\n  this.pendingFetch.push(callback);\n};\n\n// Unsubscribe. The data will stay around in local memory, but we'll stop\n// receiving updates\nDoc.prototype.unsubscribe = function(callback) {\n  this.wantSubscribe = false;\n  // The subscribed state should be conservative in indicating when we are\n  // subscribed on the server. We'll actually be unsubscribed some time\n  // between sending the message and hearing back, but we cannot know exactly\n  // when. Thus, immediately mark us as not subscribed\n  this.subscribed = false;\n  if (this.connection.canSend) {\n    var isDuplicate = this.connection.sendUnsubscribe(this);\n    pushActionCallback(this.inflightUnsubscribe, isDuplicate, callback);\n    return;\n  }\n  if (callback) process.nextTick(callback);\n};\n\nfunction pushActionCallback(inflight, isDuplicate, callback) {\n  if (isDuplicate) {\n    var lastCallback = inflight.pop();\n    inflight.push(function(err) {\n      lastCallback && lastCallback(err);\n      callback && callback(err);\n    });\n  } else {\n    inflight.push(callback);\n  }\n}\n\n\n// Operations //\n\n// Send the next pending op to the server, if we can.\n//\n// Only one operation can be in-flight at a time. If an operation is already on\n// its way, or we're not currently connected, this method does nothing.\nDoc.prototype.flush = function() {\n  // Ignore if we can't send or we are already sending an op\n  if (!this.connection.canSend || this.inflightOp) return;\n\n  // Send first pending op unless paused\n  if (!this.paused && this.pendingOps.length) {\n    this._sendOp();\n  }\n};\n\n// Helper function to set op to contain a no-op.\nfunction setNoOp(op) {\n  delete op.op;\n  delete op.create;\n  delete op.del;\n}\n\n// Transform server op data by a client op, and vice versa. Ops are edited in place.\nfunction transformX(client, server) {\n  // Order of statements in this function matters. Be especially careful if\n  // refactoring this function\n\n  // A client delete op should dominate if both the server and the client\n  // delete the document. Thus, any ops following the client delete (such as a\n  // subsequent create) will be maintained, since the server op is transformed\n  // to a no-op\n  if (client.del) return setNoOp(server);\n\n  if (server.del) {\n    return new ShareDBError(4017, 'Document was deleted');\n  }\n  if (server.create) {\n    return new ShareDBError(4018, 'Document alredy created');\n  }\n\n  // Ignore no-op coming from server\n  if (!server.op) return;\n\n  // I believe that this should not occur, but check just in case\n  if (client.create) {\n    return new ShareDBError(4018, 'Document already created');\n  }\n\n  // They both edited the document. This is the normal case for this function -\n  // as in, most of the time we'll end up down here.\n  //\n  // You should be wondering why I'm using client.type instead of this.type.\n  // The reason is, if we get ops at an old version of the document, this.type\n  // might be undefined or a totally different type. By pinning the type to the\n  // op data, we make sure the right type has its transform function called.\n  if (client.type.transformX) {\n    var result = client.type.transformX(client.op, server.op);\n    client.op = result[0];\n    server.op = result[1];\n  } else {\n    var clientOp = client.type.transform(client.op, server.op, 'left');\n    var serverOp = client.type.transform(server.op, client.op, 'right');\n    client.op = clientOp;\n    server.op = serverOp;\n  }\n};\n\n/**\n * Applies the operation to the snapshot\n *\n * If the operation is create or delete it emits `create` or `del`. Then the\n * operation is applied to the snapshot and `op` and `after op` are emitted.\n * If the type supports incremental updates and `this.incremental` is true we\n * fire `op` after every small operation.\n *\n * This is the only function to fire the above mentioned events.\n *\n * @private\n */\nDoc.prototype._otApply = function(op, source) {\n  if (op.op) {\n    if (!this.type) {\n      var err = new ShareDBError(4015, 'Cannot apply op to uncreated document. ' + this.collection + '.' + this.id);\n      return this.emit('error', err);\n    }\n\n    // Iteratively apply multi-component remote operations and rollback ops\n    // (source === false) for the default JSON0 OT type. It could use\n    // type.shatter(), but since this code is so specific to use cases for the\n    // JSON0 type and ShareDB explicitly bundles the default type, we might as\n    // well write it this way and save needing to iterate through the op\n    // components twice.\n    //\n    // Ideally, we would not need this extra complexity. However, it is\n    // helpful for implementing bindings that update DOM nodes and other\n    // stateful objects by translating op events directly into corresponding\n    // mutations. Such bindings are most easily written as responding to\n    // individual op components one at a time in order, and it is important\n    // that the snapshot only include updates from the particular op component\n    // at the time of emission. Eliminating this would require rethinking how\n    // such external bindings are implemented.\n    if (!source && this.type === types.defaultType && op.op.length > 1) {\n      if (!this.applyStack) this.applyStack = [];\n      var stackLength = this.applyStack.length;\n      for (var i = 0; i < op.op.length; i++) {\n        var component = op.op[i];\n        var componentOp = {op: [component]};\n        // Transform componentOp against any ops that have been submitted\n        // sychronously inside of an op event handler since we began apply of\n        // our operation\n        for (var j = stackLength; j < this.applyStack.length; j++) {\n          var transformErr = transformX(this.applyStack[j], componentOp);\n          if (transformErr) return this._hardRollback(transformErr);\n        }\n        // Apply the individual op component\n        this.emit('before op', componentOp.op, source);\n        this.data = this.type.apply(this.data, componentOp.op);\n        this.emit('op', componentOp.op, source);\n      }\n      // Pop whatever was submitted since we started applying this op\n      this._popApplyStack(stackLength);\n      return;\n    }\n\n    // The 'before op' event enables clients to pull any necessary data out of\n    // the snapshot before it gets changed\n    this.emit('before op', op.op, source);\n    // Apply the operation to the local data, mutating it in place\n    this.data = this.type.apply(this.data, op.op);\n    // Emit an 'op' event once the local data includes the changes from the\n    // op. For locally submitted ops, this will be synchronously with\n    // submission and before the server or other clients have received the op.\n    // For ops from other clients, this will be after the op has been\n    // committed to the database and published\n    this.emit('op', op.op, source);\n    return;\n  }\n\n  if (op.create) {\n    this._setType(op.create.type);\n    this.data = (this.type.deserialize) ?\n      (this.type.createDeserialized) ?\n        this.type.createDeserialized(op.create.data) :\n        this.type.deserialize(this.type.create(op.create.data)) :\n      this.type.create(op.create.data);\n    this.emit('create', source);\n    return;\n  }\n\n  if (op.del) {\n    var oldData = this.data;\n    this._setType(null);\n    this.emit('del', oldData, source);\n    return;\n  }\n};\n\n\n// ***** Sending operations\n\n// Actually send op to the server.\nDoc.prototype._sendOp = function() {\n  // Wait until we have a src id from the server\n  var src = this.connection.id;\n  if (!src) return;\n\n  // When there is no inflightOp, send the first item in pendingOps. If\n  // there is inflightOp, try sending it again\n  if (!this.inflightOp) {\n    // Send first pending op\n    this.inflightOp = this.pendingOps.shift();\n  }\n  var op = this.inflightOp;\n  if (!op) {\n    var err = new ShareDBError(5010, 'No op to send on call to _sendOp');\n    return this.emit('error', err);\n  }\n\n  // Track data for retrying ops\n  op.sentAt = Date.now();\n  op.retries = (op.retries == null) ? 0 : op.retries + 1;\n\n  // The src + seq number is a unique ID representing this operation. This tuple\n  // is used on the server to detect when ops have been sent multiple times and\n  // on the client to match acknowledgement of an op back to the inflightOp.\n  // Note that the src could be different from this.connection.id after a\n  // reconnect, since an op may still be pending after the reconnection and\n  // this.connection.id will change. In case an op is sent multiple times, we\n  // also need to be careful not to override the original seq value.\n  if (op.seq == null) op.seq = this.connection.seq++;\n\n  this.connection.sendOp(this, op);\n\n  // src isn't needed on the first try, since the server session will have the\n  // same id, but it must be set on the inflightOp in case it is sent again\n  // after a reconnect and the connection's id has changed by then\n  if (op.src == null) op.src = src;\n};\n\n\n// Queues the operation for submission to the server and applies it locally.\n//\n// Internal method called to do the actual work for submit(), create() and del().\n// @private\n//\n// @param op\n// @param [op.op]\n// @param [op.del]\n// @param [op.create]\n// @param [callback] called when operation is submitted\nDoc.prototype._submit = function(op, source, callback) {\n  // Locally submitted ops must always have a truthy source\n  if (!source) source = true;\n\n  // The op contains either op, create, delete, or none of the above (a no-op).\n  if (op.op) {\n    if (!this.type) {\n      var err = new ShareDBError(4015, 'Cannot submit op. Document has not been created. ' + this.collection + '.' + this.id);\n      if (callback) return callback(err);\n      return this.emit('error', err);\n    }\n    // Try to normalize the op. This removes trailing skip:0's and things like that.\n    if (this.type.normalize) op.op = this.type.normalize(op.op);\n  }\n\n  this._pushOp(op, callback);\n  this._otApply(op, source);\n\n  // The call to flush is delayed so if submit() is called multiple times\n  // synchronously, all the ops are combined before being sent to the server.\n  var doc = this;\n  process.nextTick(function() {\n    doc.flush();\n  });\n};\n\nDoc.prototype._pushOp = function(op, callback) {\n  if (this.applyStack) {\n    // If we are in the process of incrementally applying an operation, don't\n    // compose the op and push it onto the applyStack so it can be transformed\n    // against other components from the op or ops being applied\n    this.applyStack.push(op);\n  } else {\n    // If the type supports composes, try to compose the operation onto the\n    // end of the last pending operation.\n    var composed = this._tryCompose(op);\n    if (composed) {\n      composed.callbacks.push(callback);\n      return;\n    }\n  }\n  // Push on to the pendingOps queue of ops to submit if we didn't compose\n  op.type = this.type;\n  op.callbacks = [callback];\n  this.pendingOps.push(op);\n};\n\nDoc.prototype._popApplyStack = function(to) {\n  if (to > 0) {\n    this.applyStack.length = to;\n    return;\n  }\n  // Once we have completed the outermost apply loop, reset to null and no\n  // longer add ops to the applyStack as they are submitted\n  var op = this.applyStack[0];\n  this.applyStack = null;\n  if (!op) return;\n  // Compose the ops added since the beginning of the apply stack, since we\n  // had to skip compose when they were originally pushed\n  var i = this.pendingOps.indexOf(op);\n  if (i === -1) return;\n  var ops = this.pendingOps.splice(i);\n  for (var i = 0; i < ops.length; i++) {\n    var op = ops[i];\n    var composed = this._tryCompose(op);\n    if (composed) {\n      composed.callbacks = composed.callbacks.concat(op.callbacks);\n    } else {\n      this.pendingOps.push(op);\n    }\n  }\n};\n\n// Try to compose a submitted op into the last pending op. Returns the\n// composed op if it succeeds, undefined otherwise\nDoc.prototype._tryCompose = function(op) {\n  if (this.preventCompose) return;\n\n  // We can only compose into the last pending op. Inflight ops have already\n  // been sent to the server, so we can't modify them\n  var last = this.pendingOps[this.pendingOps.length - 1];\n  if (!last) return;\n\n  // Compose an op into a create by applying it. This effectively makes the op\n  // invisible, as if the document were created including the op originally\n  if (last.create && op.op) {\n    last.create.data = this.type.apply(last.create.data, op.op);\n    return last;\n  }\n\n  // Compose two ops into a single op if supported by the type. Types that\n  // support compose must be able to compose any two ops together\n  if (last.op && op.op && this.type.compose) {\n    last.op = this.type.compose(last.op, op.op);\n    return last;\n  }\n};\n\n// *** Client OT entrypoints.\n\n// Submit an operation to the document.\n//\n// @param operation handled by the OT type\n// @param options  {source: ...}\n// @param [callback] called after operation submitted\n//\n// @fires before op, op, after op\nDoc.prototype.submitOp = function(component, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  var op = {op: component};\n  var source = options && options.source;\n  this._submit(op, source, callback);\n};\n\n// Create the document, which in ShareJS semantics means to set its type. Every\n// object implicitly exists in the database but has no data and no type. Create\n// sets the type of the object and can optionally set some initial data on the\n// object, depending on the type.\n//\n// @param data  initial\n// @param type  OT type\n// @param options  {source: ...}\n// @param callback  called when operation submitted\nDoc.prototype.create = function(data, type, options, callback) {\n  if (typeof type === 'function') {\n    callback = type;\n    options = null;\n    type = null;\n  } else if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  if (!type) {\n    type = types.defaultType.uri;\n  }\n  if (this.type) {\n    var err = new ShareDBError(4016, 'Document already exists');\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n  var op = {create: {type: type, data: data}};\n  var source = options && options.source;\n  this._submit(op, source, callback);\n};\n\n// Delete the document. This creates and submits a delete operation to the\n// server. Deleting resets the object's type to null and deletes its data. The\n// document still exists, and still has the version it used to have before you\n// deleted it (well, old version +1).\n//\n// @param options  {source: ...}\n// @param callback  called when operation submitted\nDoc.prototype.del = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n  if (!this.type) {\n    var err = new ShareDBError(4015, 'Document does not exist');\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n  var op = {del: true};\n  var source = options && options.source;\n  this._submit(op, source, callback);\n};\n\n\n// Stops the document from sending any operations to the server.\nDoc.prototype.pause = function() {\n  this.paused = true;\n};\n\n// Continue sending operations to the server\nDoc.prototype.resume = function() {\n  this.paused = false;\n  this.flush();\n};\n\n\n// *** Receiving operations\n\n// This is called when the server acknowledges an operation from the client.\nDoc.prototype._opAcknowledged = function(message) {\n  if (this.inflightOp.create) {\n    this.version = message.v;\n\n  } else if (message.v !== this.version) {\n    // We should already be at the same version, because the server should\n    // have sent all the ops that have happened before acknowledging our op\n    console.warn('Invalid version from server. Expected: ' + this.version + ' Received: ' + message.v, message);\n\n    // Fetching should get us back to a working document state\n    return this.fetch();\n  }\n\n  // The op was committed successfully. Increment the version number\n  this.version++;\n\n  this._clearInflightOp();\n};\n\nDoc.prototype._rollback = function(err) {\n  // The server has rejected submission of the current operation. Invert by\n  // just the inflight op if possible. If not possible to invert, cancel all\n  // pending ops and fetch the latest from the server to get us back into a\n  // working state, then call back\n  var op = this.inflightOp;\n\n  if (op.op && op.type.invert) {\n    op.op = op.type.invert(op.op);\n\n    // Transform the undo operation by any pending ops.\n    for (var i = 0; i < this.pendingOps.length; i++) {\n      var transformErr = transformX(this.pendingOps[i], op);\n      if (transformErr) return this._hardRollback(transformErr);\n    }\n\n    // ... and apply it locally, reverting the changes.\n    //\n    // This operation is applied to look like it comes from a remote source.\n    // I'm still not 100% sure about this functionality, because its really a\n    // local op. Basically, the problem is that if the client's op is rejected\n    // by the server, the editor window should update to reflect the undo.\n    this._otApply(op, false);\n\n    this._clearInflightOp(err);\n    return;\n  }\n\n  this._hardRollback(err);\n};\n\nDoc.prototype._hardRollback = function(err) {\n  // Cancel all pending ops and reset if we can't invert\n  var op = this.inflightOp;\n  var pending = this.pendingOps;\n  this._setType(null);\n  this.version = null;\n  this.inflightOp = null;\n  this.pendingOps = [];\n\n  // Fetch the latest from the server to get us back into a working state\n  var doc = this;\n  this.fetch(function() {\n    var called = op && callEach(op.callbacks, err);\n    for (var i = 0; i < pending.length; i++) {\n      callEach(pending[i].callbacks, err);\n    }\n    if (err && !called) return doc.emit('error', err);\n  });\n};\n\nDoc.prototype._clearInflightOp = function(err) {\n  var called = callEach(this.inflightOp.callbacks, err);\n\n  this.inflightOp = null;\n  this.flush();\n  this._emitNothingPending();\n\n  if (err && !called) return this.emit('error', err);\n};\n\nfunction callEach(callbacks, err) {\n  var called = false;\n  for (var i = 0; i < callbacks.length; i++) {\n    var callback = callbacks[i];\n    if (callback) {\n      callback(err);\n      called = true;\n    }\n  }\n  return called;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/client/doc.js\n// module id = 33\n// module chunks = 0","exports.Connection = require('./connection');\nexports.Doc = require('./doc');\nexports.Error = require('../error');\nexports.Query = require('./query');\nexports.types = require('../types');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/client/index.js\n// module id = 34\n// module chunks = 0","var emitter = require('../emitter');\n\n// Queries are live requests to the database for particular sets of fields.\n//\n// The server actively tells the client when there's new data that matches\n// a set of conditions.\nmodule.exports = Query;\nfunction Query(action, connection, id, collection, query, options, callback) {\n  emitter.EventEmitter.call(this);\n\n  // 'qf' or 'qs'\n  this.action = action;\n\n  this.connection = connection;\n  this.id = id;\n  this.collection = collection;\n\n  // The query itself. For mongo, this should look something like {\"data.x\":5}\n  this.query = query;\n\n  // A list of resulting documents. These are actual documents, complete with\n  // data and all the rest. It is possible to pass in an initial results set,\n  // so that a query can be serialized and then re-established\n  this.results = null;\n  if (options && options.results) {\n    this.results = options.results;\n    delete options.results;\n  }\n  this.extra = undefined;\n\n  // Options to pass through with the query\n  this.options = options;\n\n  this.callback = callback;\n  this.ready = false;\n  this.sent = false;\n}\nemitter.mixin(Query);\n\nQuery.prototype.hasPending = function() {\n  return !this.ready;\n};\n\n// Helper for subscribe & fetch, since they share the same message format.\n//\n// This function actually issues the query.\nQuery.prototype.send = function() {\n  if (!this.connection.canSend) return;\n\n  var message = {\n    a: this.action,\n    id: this.id,\n    c: this.collection,\n    q: this.query\n  };\n  if (this.options) {\n    message.o = this.options;\n  }\n  if (this.results) {\n    // Collect the version of all the documents in the current result set so we\n    // don't need to be sent their snapshots again.\n    var results = [];\n    for (var i = 0; i < this.results.length; i++) {\n      var doc = this.results[i];\n      results.push([doc.id, doc.version]);\n    }\n    message.r = results;\n  }\n\n  this.connection.send(message);\n  this.sent = true;\n};\n\n// Destroy the query object. Any subsequent messages for the query will be\n// ignored by the connection.\nQuery.prototype.destroy = function(callback) {\n  if (this.connection.canSend && this.action === 'qs') {\n    this.connection.send({a: 'qu', id: this.id});\n  }\n  this.connection._destroyQuery(this);\n  // There is a callback for consistency, but we don't actually wait for the\n  // server's unsubscribe message currently\n  if (callback) process.nextTick(callback);\n};\n\nQuery.prototype._onConnectionStateChanged = function() {\n  if (this.connection.canSend && !this.sent) {\n    this.send();\n  } else {\n    this.sent = false;\n  }\n};\n\nQuery.prototype._handleFetch = function(err, data, extra) {\n  // Once a fetch query gets its data, it is destroyed.\n  this.connection._destroyQuery(this);\n  this._handleResponse(err, data, extra);\n};\n\nQuery.prototype._handleSubscribe = function(err, data, extra) {\n  this._handleResponse(err, data, extra);\n};\n\nQuery.prototype._handleResponse = function(err, data, extra) {\n  var callback = this.callback;\n  this.callback = null;\n  if (err) return this._finishResponse(err, callback);\n  if (!data) return this._finishResponse(null, callback);\n\n  var query = this;\n  var wait = 1;\n  var finish = function(err) {\n    if (err) return query._finishResponse(err, callback);\n    if (--wait) return;\n    query._finishResponse(null, callback);\n  };\n\n  if (Array.isArray(data)) {\n    wait += data.length;\n    this.results = this._ingestSnapshots(data, finish);\n    this.extra = extra;\n\n  } else {\n    for (var id in data) {\n      wait++;\n      var snapshot = data[id];\n      var doc = this.connection.get(snapshot.c || this.collection, id);\n      doc.ingestSnapshot(snapshot, finish);\n    }\n  }\n\n  finish();\n};\n\nQuery.prototype._ingestSnapshots = function(snapshots, finish) {\n  var results = [];\n  for (var i = 0; i < snapshots.length; i++) {\n    var snapshot = snapshots[i];\n    var doc = this.connection.get(snapshot.c || this.collection, snapshot.d);\n    doc.ingestSnapshot(snapshot, finish);\n    results.push(doc);\n  }\n  return results;\n};\n\nQuery.prototype._finishResponse = function(err, callback) {\n  this.emit('ready');\n  this.ready = true;\n  if (err) {\n    this.connection._destroyQuery(this);\n    if (callback) return callback(err);\n    return this.emit('error', err);\n  }\n  if (callback) callback(null, this.results, this.extra);\n};\n\nQuery.prototype._handleError = function(err) {\n  this.emit('error', err);\n};\n\nQuery.prototype._handleDiff = function(diff) {\n  // We need to go through the list twice. First, we'll ingest all the new\n  // documents. After that we'll emit events and actually update our list.\n  // This avoids race conditions around setting documents to be subscribed &\n  // unsubscribing documents in event callbacks.\n  for (var i = 0; i < diff.length; i++) {\n    var d = diff[i];\n    if (d.type === 'insert') d.values = this._ingestSnapshots(d.values);\n  }\n\n  for (var i = 0; i < diff.length; i++) {\n    var d = diff[i];\n    switch (d.type) {\n      case 'insert':\n        var newDocs = d.values;\n        Array.prototype.splice.apply(this.results, [d.index, 0].concat(newDocs));\n        this.emit('insert', newDocs, d.index);\n        break;\n      case 'remove':\n        var howMany = d.howMany || 1;\n        var removed = this.results.splice(d.index, howMany);\n        this.emit('remove', removed, d.index);\n        break;\n      case 'move':\n        var howMany = d.howMany || 1;\n        var docs = this.results.splice(d.from, howMany);\n        Array.prototype.splice.apply(this.results, [d.to, 0].concat(docs));\n        this.emit('move', docs, d.from, d.to);\n        break;\n    }\n  }\n\n  this.emit('changed', this.results);\n};\n\nQuery.prototype._handleExtra = function(extra) {\n  this.extra = extra;\n  this.emit('extra', extra);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/client/query.js\n// module id = 35\n// module chunks = 0","var map = {\n\t\"./assets\": 22,\n\t\"./assets.js\": 22,\n\t\"./clientManager\": 23,\n\t\"./clientManager.js\": 23,\n\t\"./connectionEvents\": 24,\n\t\"./connectionEvents.js\": 24,\n\t\"./cookies\": 25,\n\t\"./cookies.js\": 25,\n\t\"./coreDatabase\": 6,\n\t\"./coreDatabase.js\": 6,\n\t\"./coreEvents\": 0,\n\t\"./coreEvents.js\": 0,\n\t\"./coreJsonML\": 8,\n\t\"./coreJsonML.js\": 8,\n\t\"./coreMutation\": 11,\n\t\"./coreMutation.js\": 11,\n\t\"./coreOpApplier\": 15,\n\t\"./coreOpApplier.js\": 15,\n\t\"./coreOpCreator\": 16,\n\t\"./coreOpCreator.js\": 16,\n\t\"./corePathTree\": 9,\n\t\"./corePathTree.js\": 9,\n\t\"./corePopulator\": 12,\n\t\"./corePopulator.js\": 12,\n\t\"./coreUtils\": 1,\n\t\"./coreUtils.js\": 1,\n\t\"./coreWebsocket\": 2,\n\t\"./coreWebsocket.js\": 2,\n\t\"./domEvents\": 26,\n\t\"./domEvents.js\": 26,\n\t\"./globalObject\": 3,\n\t\"./globalObject.js\": 3,\n\t\"./keepAlive\": 27,\n\t\"./keepAlive.js\": 27,\n\t\"./loadedEvent\": 5,\n\t\"./loadedEvent.js\": 5,\n\t\"./nodeObjects\": 17,\n\t\"./nodeObjects.js\": 17,\n\t\"./permissions\": 28,\n\t\"./permissions.js\": 28,\n\t\"./signalStream\": 29,\n\t\"./signalStream.js\": 29,\n\t\"./signaling\": 18,\n\t\"./signaling.js\": 18,\n\t\"./tagging\": 30,\n\t\"./tagging.js\": 30,\n\t\"./transclusionEvent\": 31,\n\t\"./transclusionEvent.js\": 31,\n\t\"./userObject\": 13,\n\t\"./userObject.js\": 13\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\tvar id = map[req];\n\tif(!(id + 1)) // check for number or string\n\t\tthrow new Error(\"Cannot find module '\" + req + \"'.\");\n\treturn id;\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 36;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/webstrates ^\\.\\/.*$\n// module id = 36\n// module chunks = 0","'use strict';\nconst coreEvents = require('./webstrates/coreEvents');\nconst coreDatabase = require('./webstrates/coreDatabase');\nconst coreOpApplier = require('./webstrates/coreOpApplier');\nconst coreOpCreator = require('./webstrates/coreOpCreator');\nconst coreMutation = require('./webstrates/coreMutation');\nconst corePopulator = require('./webstrates/corePopulator');\nconst coreUtils = require('./webstrates/coreUtils');\nconst coreWebsocket = require('./webstrates/coreWebsocket');\n\n// Create an event that'll be triggered once all modules have been loaded.\ncoreEvents.createEvent('allModulesLoaded');\n\nconst protocol = location.protocol === 'http:' ? 'ws:' : 'wss:';\ncoreWebsocket.setup(`${protocol}//${location.host}/ws/`);\n\n// Load optional modules.\nconfig.modules.forEach(module => require('./webstrates/' + module));\n\n// Send out an event when all modules have been loaded.\ncoreEvents.triggerEvent('allModulesLoaded');\n\nconst request = coreUtils.getLocationObject();\n\nif (request.staticMode) {\n\tcoreDatabase.fetch(request.webstrateId, request.tagOrVersion).then((doc) => {\n\t\tcorePopulator.populate(document, doc);\n\t});\n}\nelse {\n\tcoreDatabase.subscribe(request.webstrateId).then((doc) => {\n\t\tcorePopulator.populate(document, doc).then(() => {\n\t\t\t// Emits mutations from changes on the document.\n\t\t\tcoreMutation.emitMutationsFrom(document);\n\n\t\t\t// Emits ops from the mutations emitted by coreMutation.\n\t\t\tcoreOpCreator.emitOpsFromMutations();\n\n\t\t\t// Apply changes on <html>, not document.\n\t\t\tconst targetElement = document.childNodes[0];\n\t\t\tcoreOpApplier.listenForOpsAndApplyOn(targetElement);\n\n\t\t\t// Create any missing wids in the document.\n\t\t\tcoreOpCreator.ensureExistenceOfWids(targetElement);\n\t\t});\n\t});\n}\n\n// TODO: Delete Webstrate handler\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/index.js\n// module id = 37\n// module chunks = 0","'use strict'\r\n\r\n/**\r\n * Diff Match and Patch\r\n *\r\n * Copyright 2006 Google Inc.\r\n * http://code.google.com/p/google-diff-match-patch/\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * @fileoverview Computes the difference between two texts to create a patch.\r\n * Applies the patch onto another text, allowing for errors.\r\n * @author fraser@google.com (Neil Fraser)\r\n */\r\n\r\n/**\r\n * Class containing the diff, match and patch methods.\r\n * @constructor\r\n */\r\nfunction diff_match_patch() {\r\n\r\n  // Defaults.\r\n  // Redefine these in your program to override the defaults.\r\n\r\n  // Number of seconds to map a diff before giving up (0 for infinity).\r\n  this.Diff_Timeout = 1.0;\r\n  // Cost of an empty edit operation in terms of edit characters.\r\n  this.Diff_EditCost = 4;\r\n  // At what point is no match declared (0.0 = perfection, 1.0 = very loose).\r\n  this.Match_Threshold = 0.5;\r\n  // How far to search for a match (0 = exact location, 1000+ = broad match).\r\n  // A match this many characters away from the expected location will add\r\n  // 1.0 to the score (0.0 is a perfect match).\r\n  this.Match_Distance = 1000;\r\n  // When deleting a large block of text (over ~64 characters), how close do\r\n  // the contents have to be to match the expected contents. (0.0 = perfection,\r\n  // 1.0 = very loose).  Note that Match_Threshold controls how closely the\r\n  // end points of a delete need to match.\r\n  this.Patch_DeleteThreshold = 0.5;\r\n  // Chunk size for context length.\r\n  this.Patch_Margin = 4;\r\n\r\n  // The number of bits in an int.\r\n  this.Match_MaxBits = 32;\r\n}\r\n\r\n\r\n//  DIFF FUNCTIONS\r\n\r\n\r\n/**\r\n * The data structure representing a diff is an array of tuples:\r\n * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]\r\n * which means: delete 'Hello', add 'Goodbye' and keep ' world.'\r\n */\r\nvar DIFF_DELETE = -1;\r\nvar DIFF_INSERT = 1;\r\nvar DIFF_EQUAL = 0;\r\n\r\n/** @typedef {{0: number, 1: string}} */\r\ndiff_match_patch.Diff;\r\n\r\n\r\n/**\r\n * Find the differences between two texts.  Simplifies the problem by stripping\r\n * any common prefix or suffix off the texts before diffing.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {boolean=} opt_checklines Optional speedup flag. If present and false,\r\n *     then don't run a line-level diff first to identify the changed areas.\r\n *     Defaults to true, which does a faster, slightly less optimal diff.\r\n * @param {number} opt_deadline Optional time when the diff should be complete\r\n *     by.  Used internally for recursive calls.  Users should set DiffTimeout\r\n *     instead.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines,\r\n    opt_deadline) {\r\n  // Set a deadline by which time the diff must be complete.\r\n  if (typeof opt_deadline == 'undefined') {\r\n    if (this.Diff_Timeout <= 0) {\r\n      opt_deadline = Number.MAX_VALUE;\r\n    } else {\r\n      opt_deadline = (new Date).getTime() + this.Diff_Timeout * 1000;\r\n    }\r\n  }\r\n  var deadline = opt_deadline;\r\n\r\n  // Check for null inputs.\r\n  if (text1 == null || text2 == null) {\r\n    throw new Error('Null input. (diff_main)');\r\n  }\r\n\r\n  // Check for equality (speedup).\r\n  if (text1 == text2) {\r\n    if (text1) {\r\n      return [[DIFF_EQUAL, text1]];\r\n    }\r\n    return [];\r\n  }\r\n\r\n  if (typeof opt_checklines == 'undefined') {\r\n    opt_checklines = true;\r\n  }\r\n  var checklines = opt_checklines;\r\n\r\n  // Trim off common prefix (speedup).\r\n  var commonlength = this.diff_commonPrefix(text1, text2);\r\n  var commonprefix = text1.substring(0, commonlength);\r\n  text1 = text1.substring(commonlength);\r\n  text2 = text2.substring(commonlength);\r\n\r\n  // Trim off common suffix (speedup).\r\n  commonlength = this.diff_commonSuffix(text1, text2);\r\n  var commonsuffix = text1.substring(text1.length - commonlength);\r\n  text1 = text1.substring(0, text1.length - commonlength);\r\n  text2 = text2.substring(0, text2.length - commonlength);\r\n\r\n  // Compute the diff on the middle block.\r\n  var diffs = this.diff_compute_(text1, text2, checklines, deadline);\r\n\r\n  // Restore the prefix and suffix.\r\n  if (commonprefix) {\r\n    diffs.unshift([DIFF_EQUAL, commonprefix]);\r\n  }\r\n  if (commonsuffix) {\r\n    diffs.push([DIFF_EQUAL, commonsuffix]);\r\n  }\r\n  this.diff_cleanupMerge(diffs);\r\n  return diffs;\r\n};\r\n\r\n\r\n/**\r\n * Find the differences between two texts.  Assumes that the texts do not\r\n * have any common prefix or suffix.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {boolean} checklines Speedup flag.  If false, then don't run a\r\n *     line-level diff first to identify the changed areas.\r\n *     If true, then run a faster, slightly less optimal diff.\r\n * @param {number} deadline Time when the diff should be complete by.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines,\r\n    deadline) {\r\n  var diffs;\r\n\r\n  if (!text1) {\r\n    // Just add some text (speedup).\r\n    return [[DIFF_INSERT, text2]];\r\n  }\r\n\r\n  if (!text2) {\r\n    // Just delete some text (speedup).\r\n    return [[DIFF_DELETE, text1]];\r\n  }\r\n\r\n  var longtext = text1.length > text2.length ? text1 : text2;\r\n  var shorttext = text1.length > text2.length ? text2 : text1;\r\n  var i = longtext.indexOf(shorttext);\r\n  if (i != -1) {\r\n    // Shorter text is inside the longer text (speedup).\r\n    diffs = [[DIFF_INSERT, longtext.substring(0, i)],\r\n             [DIFF_EQUAL, shorttext],\r\n             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];\r\n    // Swap insertions for deletions if diff is reversed.\r\n    if (text1.length > text2.length) {\r\n      diffs[0][0] = diffs[2][0] = DIFF_DELETE;\r\n    }\r\n    return diffs;\r\n  }\r\n\r\n  if (shorttext.length == 1) {\r\n    // Single character string.\r\n    // After the previous speedup, the character can't be an equality.\r\n    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\r\n  }\r\n\r\n  // Check to see if the problem can be split in two.\r\n  var hm = this.diff_halfMatch_(text1, text2);\r\n  if (hm) {\r\n    // A half-match was found, sort out the return data.\r\n    var text1_a = hm[0];\r\n    var text1_b = hm[1];\r\n    var text2_a = hm[2];\r\n    var text2_b = hm[3];\r\n    var mid_common = hm[4];\r\n    // Send both pairs off for separate processing.\r\n    var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);\r\n    var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);\r\n    // Merge the results.\r\n    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);\r\n  }\r\n\r\n  if (checklines && text1.length > 100 && text2.length > 100) {\r\n    return this.diff_lineMode_(text1, text2, deadline);\r\n  }\r\n\r\n  return this.diff_bisect_(text1, text2, deadline);\r\n};\r\n\r\n\r\n/**\r\n * Do a quick line-level diff on both strings, then rediff the parts for\r\n * greater accuracy.\r\n * This speedup can produce non-minimal diffs.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {number} deadline Time when the diff should be complete by.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {\r\n  // Scan the text on a line-by-line basis first.\r\n  var a = this.diff_linesToChars_(text1, text2);\r\n  text1 = a.chars1;\r\n  text2 = a.chars2;\r\n  var linearray = a.lineArray;\r\n\r\n  var diffs = this.diff_main(text1, text2, false, deadline);\r\n\r\n  // Convert the diff back to original text.\r\n  this.diff_charsToLines_(diffs, linearray);\r\n  // Eliminate freak matches (e.g. blank lines)\r\n  this.diff_cleanupSemantic(diffs);\r\n\r\n  // Rediff any replacement blocks, this time character-by-character.\r\n  // Add a dummy entry at the end.\r\n  diffs.push([DIFF_EQUAL, '']);\r\n  var pointer = 0;\r\n  var count_delete = 0;\r\n  var count_insert = 0;\r\n  var text_delete = '';\r\n  var text_insert = '';\r\n  while (pointer < diffs.length) {\r\n    switch (diffs[pointer][0]) {\r\n      case DIFF_INSERT:\r\n        count_insert++;\r\n        text_insert += diffs[pointer][1];\r\n        break;\r\n      case DIFF_DELETE:\r\n        count_delete++;\r\n        text_delete += diffs[pointer][1];\r\n        break;\r\n      case DIFF_EQUAL:\r\n        // Upon reaching an equality, check for prior redundancies.\r\n        if (count_delete >= 1 && count_insert >= 1) {\r\n          // Delete the offending records and add the merged ones.\r\n          diffs.splice(pointer - count_delete - count_insert,\r\n                       count_delete + count_insert);\r\n          pointer = pointer - count_delete - count_insert;\r\n          var a = this.diff_main(text_delete, text_insert, false, deadline);\r\n          for (var j = a.length - 1; j >= 0; j--) {\r\n            diffs.splice(pointer, 0, a[j]);\r\n          }\r\n          pointer = pointer + a.length;\r\n        }\r\n        count_insert = 0;\r\n        count_delete = 0;\r\n        text_delete = '';\r\n        text_insert = '';\r\n        break;\r\n    }\r\n    pointer++;\r\n  }\r\n  diffs.pop();  // Remove the dummy entry at the end.\r\n\r\n  return diffs;\r\n};\r\n\r\n\r\n/**\r\n * Find the 'middle snake' of a diff, split the problem in two\r\n * and return the recursively constructed diff.\r\n * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {number} deadline Time at which to bail if not yet complete.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {\r\n  // Cache the text lengths to prevent multiple calls.\r\n  var text1_length = text1.length;\r\n  var text2_length = text2.length;\r\n  var max_d = Math.ceil((text1_length + text2_length) / 2);\r\n  var v_offset = max_d;\r\n  var v_length = 2 * max_d;\r\n  var v1 = new Array(v_length);\r\n  var v2 = new Array(v_length);\r\n  // Setting all elements to -1 is faster in Chrome & Firefox than mixing\r\n  // integers and undefined.\r\n  for (var x = 0; x < v_length; x++) {\r\n    v1[x] = -1;\r\n    v2[x] = -1;\r\n  }\r\n  v1[v_offset + 1] = 0;\r\n  v2[v_offset + 1] = 0;\r\n  var delta = text1_length - text2_length;\r\n  // If the total number of characters is odd, then the front path will collide\r\n  // with the reverse path.\r\n  var front = (delta % 2 != 0);\r\n  // Offsets for start and end of k loop.\r\n  // Prevents mapping of space beyond the grid.\r\n  var k1start = 0;\r\n  var k1end = 0;\r\n  var k2start = 0;\r\n  var k2end = 0;\r\n  for (var d = 0; d < max_d; d++) {\r\n    // Bail out if deadline is reached.\r\n    if ((new Date()).getTime() > deadline) {\r\n      break;\r\n    }\r\n\r\n    // Walk the front path one step.\r\n    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {\r\n      var k1_offset = v_offset + k1;\r\n      var x1;\r\n      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {\r\n        x1 = v1[k1_offset + 1];\r\n      } else {\r\n        x1 = v1[k1_offset - 1] + 1;\r\n      }\r\n      var y1 = x1 - k1;\r\n      while (x1 < text1_length && y1 < text2_length &&\r\n             text1.charAt(x1) == text2.charAt(y1)) {\r\n        x1++;\r\n        y1++;\r\n      }\r\n      v1[k1_offset] = x1;\r\n      if (x1 > text1_length) {\r\n        // Ran off the right of the graph.\r\n        k1end += 2;\r\n      } else if (y1 > text2_length) {\r\n        // Ran off the bottom of the graph.\r\n        k1start += 2;\r\n      } else if (front) {\r\n        var k2_offset = v_offset + delta - k1;\r\n        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {\r\n          // Mirror x2 onto top-left coordinate system.\r\n          var x2 = text1_length - v2[k2_offset];\r\n          if (x1 >= x2) {\r\n            // Overlap detected.\r\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // Walk the reverse path one step.\r\n    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {\r\n      var k2_offset = v_offset + k2;\r\n      var x2;\r\n      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {\r\n        x2 = v2[k2_offset + 1];\r\n      } else {\r\n        x2 = v2[k2_offset - 1] + 1;\r\n      }\r\n      var y2 = x2 - k2;\r\n      while (x2 < text1_length && y2 < text2_length &&\r\n             text1.charAt(text1_length - x2 - 1) ==\r\n             text2.charAt(text2_length - y2 - 1)) {\r\n        x2++;\r\n        y2++;\r\n      }\r\n      v2[k2_offset] = x2;\r\n      if (x2 > text1_length) {\r\n        // Ran off the left of the graph.\r\n        k2end += 2;\r\n      } else if (y2 > text2_length) {\r\n        // Ran off the top of the graph.\r\n        k2start += 2;\r\n      } else if (!front) {\r\n        var k1_offset = v_offset + delta - k2;\r\n        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {\r\n          var x1 = v1[k1_offset];\r\n          var y1 = v_offset + x1 - k1_offset;\r\n          // Mirror x2 onto top-left coordinate system.\r\n          x2 = text1_length - x2;\r\n          if (x1 >= x2) {\r\n            // Overlap detected.\r\n            return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Diff took too long and hit the deadline or\r\n  // number of diffs equals number of characters, no commonality at all.\r\n  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];\r\n};\r\n\r\n\r\n/**\r\n * Given the location of the 'middle snake', split the diff in two parts\r\n * and recurse.\r\n * @param {string} text1 Old string to be diffed.\r\n * @param {string} text2 New string to be diffed.\r\n * @param {number} x Index of split point in text1.\r\n * @param {number} y Index of split point in text2.\r\n * @param {number} deadline Time at which to bail if not yet complete.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y,\r\n    deadline) {\r\n  var text1a = text1.substring(0, x);\r\n  var text2a = text2.substring(0, y);\r\n  var text1b = text1.substring(x);\r\n  var text2b = text2.substring(y);\r\n\r\n  // Compute both diffs serially.\r\n  var diffs = this.diff_main(text1a, text2a, false, deadline);\r\n  var diffsb = this.diff_main(text1b, text2b, false, deadline);\r\n\r\n  return diffs.concat(diffsb);\r\n};\r\n\r\n\r\n/**\r\n * Split two texts into an array of strings.  Reduce the texts to a string of\r\n * hashes where each Unicode character represents one line.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {{chars1: string, chars2: string, lineArray: !Array.<string>}}\r\n *     An object containing the encoded text1, the encoded text2 and\r\n *     the array of unique strings.\r\n *     The zeroth element of the array of unique strings is intentionally blank.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {\r\n  var lineArray = [];  // e.g. lineArray[4] == 'Hello\\n'\r\n  var lineHash = {};   // e.g. lineHash['Hello\\n'] == 4\r\n\r\n  // '\\x00' is a valid character, but various debuggers don't like it.\r\n  // So we'll insert a junk entry to avoid generating a null character.\r\n  lineArray[0] = '';\r\n\r\n  /**\r\n   * Split a text into an array of strings.  Reduce the texts to a string of\r\n   * hashes where each Unicode character represents one line.\r\n   * Modifies linearray and linehash through being a closure.\r\n   * @param {string} text String to encode.\r\n   * @return {string} Encoded string.\r\n   * @private\r\n   */\r\n  function diff_linesToCharsMunge_(text) {\r\n    var chars = '';\r\n    // Walk the text, pulling out a substring for each line.\r\n    // text.split('\\n') would would temporarily double our memory footprint.\r\n    // Modifying text would create many large strings to garbage collect.\r\n    var lineStart = 0;\r\n    var lineEnd = -1;\r\n    // Keeping our own length variable is faster than looking it up.\r\n    var lineArrayLength = lineArray.length;\r\n    while (lineEnd < text.length - 1) {\r\n      lineEnd = text.indexOf('\\n', lineStart);\r\n      if (lineEnd == -1) {\r\n        lineEnd = text.length - 1;\r\n      }\r\n      var line = text.substring(lineStart, lineEnd + 1);\r\n      lineStart = lineEnd + 1;\r\n\r\n      if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) :\r\n          (lineHash[line] !== undefined)) {\r\n        chars += String.fromCharCode(lineHash[line]);\r\n      } else {\r\n        chars += String.fromCharCode(lineArrayLength);\r\n        lineHash[line] = lineArrayLength;\r\n        lineArray[lineArrayLength++] = line;\r\n      }\r\n    }\r\n    return chars;\r\n  }\r\n\r\n  var chars1 = diff_linesToCharsMunge_(text1);\r\n  var chars2 = diff_linesToCharsMunge_(text2);\r\n  return {chars1: chars1, chars2: chars2, lineArray: lineArray};\r\n};\r\n\r\n\r\n/**\r\n * Rehydrate the text in a diff from a string of line hashes to real lines of\r\n * text.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @param {!Array.<string>} lineArray Array of unique strings.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var chars = diffs[x][1];\r\n    var text = [];\r\n    for (var y = 0; y < chars.length; y++) {\r\n      text[y] = lineArray[chars.charCodeAt(y)];\r\n    }\r\n    diffs[x][1] = text.join('');\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Determine the common prefix of two strings.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {number} The number of characters common to the start of each\r\n *     string.\r\n */\r\ndiff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {\r\n  // Quick check for common null cases.\r\n  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {\r\n    return 0;\r\n  }\r\n  // Binary search.\r\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n  var pointermin = 0;\r\n  var pointermax = Math.min(text1.length, text2.length);\r\n  var pointermid = pointermax;\r\n  var pointerstart = 0;\r\n  while (pointermin < pointermid) {\r\n    if (text1.substring(pointerstart, pointermid) ==\r\n        text2.substring(pointerstart, pointermid)) {\r\n      pointermin = pointermid;\r\n      pointerstart = pointermin;\r\n    } else {\r\n      pointermax = pointermid;\r\n    }\r\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n  }\r\n  return pointermid;\r\n};\r\n\r\n\r\n/**\r\n * Determine the common suffix of two strings.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {number} The number of characters common to the end of each string.\r\n */\r\ndiff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {\r\n  // Quick check for common null cases.\r\n  if (!text1 || !text2 ||\r\n      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {\r\n    return 0;\r\n  }\r\n  // Binary search.\r\n  // Performance analysis: http://neil.fraser.name/news/2007/10/09/\r\n  var pointermin = 0;\r\n  var pointermax = Math.min(text1.length, text2.length);\r\n  var pointermid = pointermax;\r\n  var pointerend = 0;\r\n  while (pointermin < pointermid) {\r\n    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==\r\n        text2.substring(text2.length - pointermid, text2.length - pointerend)) {\r\n      pointermin = pointermid;\r\n      pointerend = pointermin;\r\n    } else {\r\n      pointermax = pointermid;\r\n    }\r\n    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);\r\n  }\r\n  return pointermid;\r\n};\r\n\r\n\r\n/**\r\n * Determine if the suffix of one string is the prefix of another.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {number} The number of characters common to the end of the first\r\n *     string and the start of the second string.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {\r\n  // Cache the text lengths to prevent multiple calls.\r\n  var text1_length = text1.length;\r\n  var text2_length = text2.length;\r\n  // Eliminate the null case.\r\n  if (text1_length == 0 || text2_length == 0) {\r\n    return 0;\r\n  }\r\n  // Truncate the longer string.\r\n  if (text1_length > text2_length) {\r\n    text1 = text1.substring(text1_length - text2_length);\r\n  } else if (text1_length < text2_length) {\r\n    text2 = text2.substring(0, text1_length);\r\n  }\r\n  var text_length = Math.min(text1_length, text2_length);\r\n  // Quick check for the worst case.\r\n  if (text1 == text2) {\r\n    return text_length;\r\n  }\r\n\r\n  // Start by looking for a single character match\r\n  // and increase length until no match is found.\r\n  // Performance analysis: http://neil.fraser.name/news/2010/11/04/\r\n  var best = 0;\r\n  var length = 1;\r\n  while (true) {\r\n    var pattern = text1.substring(text_length - length);\r\n    var found = text2.indexOf(pattern);\r\n    if (found == -1) {\r\n      return best;\r\n    }\r\n    length += found;\r\n    if (found == 0 || text1.substring(text_length - length) ==\r\n        text2.substring(0, length)) {\r\n      best = length;\r\n      length++;\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Do the two texts share a substring which is at least half the length of the\r\n * longer text?\r\n * This speedup can produce non-minimal diffs.\r\n * @param {string} text1 First string.\r\n * @param {string} text2 Second string.\r\n * @return {Array.<string>} Five element Array, containing the prefix of\r\n *     text1, the suffix of text1, the prefix of text2, the suffix of\r\n *     text2 and the common middle.  Or null if there was no match.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {\r\n  if (this.Diff_Timeout <= 0) {\r\n    // Don't risk returning a non-optimal diff if we have unlimited time.\r\n    return null;\r\n  }\r\n  var longtext = text1.length > text2.length ? text1 : text2;\r\n  var shorttext = text1.length > text2.length ? text2 : text1;\r\n  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {\r\n    return null;  // Pointless.\r\n  }\r\n  var dmp = this;  // 'this' becomes 'window' in a closure.\r\n\r\n  /**\r\n   * Does a substring of shorttext exist within longtext such that the substring\r\n   * is at least half the length of longtext?\r\n   * Closure, but does not reference any external variables.\r\n   * @param {string} longtext Longer string.\r\n   * @param {string} shorttext Shorter string.\r\n   * @param {number} i Start index of quarter length substring within longtext.\r\n   * @return {Array.<string>} Five element Array, containing the prefix of\r\n   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix\r\n   *     of shorttext and the common middle.  Or null if there was no match.\r\n   * @private\r\n   */\r\n  function diff_halfMatchI_(longtext, shorttext, i) {\r\n    // Start with a 1/4 length substring at position i as a seed.\r\n    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));\r\n    var j = -1;\r\n    var best_common = '';\r\n    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;\r\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\r\n      var prefixLength = dmp.diff_commonPrefix(longtext.substring(i),\r\n                                               shorttext.substring(j));\r\n      var suffixLength = dmp.diff_commonSuffix(longtext.substring(0, i),\r\n                                               shorttext.substring(0, j));\r\n      if (best_common.length < suffixLength + prefixLength) {\r\n        best_common = shorttext.substring(j - suffixLength, j) +\r\n            shorttext.substring(j, j + prefixLength);\r\n        best_longtext_a = longtext.substring(0, i - suffixLength);\r\n        best_longtext_b = longtext.substring(i + prefixLength);\r\n        best_shorttext_a = shorttext.substring(0, j - suffixLength);\r\n        best_shorttext_b = shorttext.substring(j + prefixLength);\r\n      }\r\n    }\r\n    if (best_common.length * 2 >= longtext.length) {\r\n      return [best_longtext_a, best_longtext_b,\r\n              best_shorttext_a, best_shorttext_b, best_common];\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  // First check if the second quarter is the seed for a half-match.\r\n  var hm1 = diff_halfMatchI_(longtext, shorttext,\r\n                             Math.ceil(longtext.length / 4));\r\n  // Check again based on the third quarter.\r\n  var hm2 = diff_halfMatchI_(longtext, shorttext,\r\n                             Math.ceil(longtext.length / 2));\r\n  var hm;\r\n  if (!hm1 && !hm2) {\r\n    return null;\r\n  } else if (!hm2) {\r\n    hm = hm1;\r\n  } else if (!hm1) {\r\n    hm = hm2;\r\n  } else {\r\n    // Both matched.  Select the longest.\r\n    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;\r\n  }\r\n\r\n  // A half-match was found, sort out the return data.\r\n  var text1_a, text1_b, text2_a, text2_b;\r\n  if (text1.length > text2.length) {\r\n    text1_a = hm[0];\r\n    text1_b = hm[1];\r\n    text2_a = hm[2];\r\n    text2_b = hm[3];\r\n  } else {\r\n    text2_a = hm[0];\r\n    text2_b = hm[1];\r\n    text1_a = hm[2];\r\n    text1_b = hm[3];\r\n  }\r\n  var mid_common = hm[4];\r\n  return [text1_a, text1_b, text2_a, text2_b, mid_common];\r\n};\r\n\r\n\r\n/**\r\n * Reduce the number of edits by eliminating semantically trivial equalities.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {\r\n  var changes = false;\r\n  var equalities = [];  // Stack of indices where equalities are found.\r\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\r\n  /** @type {?string} */\r\n  var lastequality = null;\r\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n  var pointer = 0;  // Index of current position.\r\n  // Number of characters that changed prior to the equality.\r\n  var length_insertions1 = 0;\r\n  var length_deletions1 = 0;\r\n  // Number of characters that changed after the equality.\r\n  var length_insertions2 = 0;\r\n  var length_deletions2 = 0;\r\n  while (pointer < diffs.length) {\r\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\r\n      equalities[equalitiesLength++] = pointer;\r\n      length_insertions1 = length_insertions2;\r\n      length_deletions1 = length_deletions2;\r\n      length_insertions2 = 0;\r\n      length_deletions2 = 0;\r\n      lastequality = diffs[pointer][1];\r\n    } else {  // An insertion or deletion.\r\n      if (diffs[pointer][0] == DIFF_INSERT) {\r\n        length_insertions2 += diffs[pointer][1].length;\r\n      } else {\r\n        length_deletions2 += diffs[pointer][1].length;\r\n      }\r\n      // Eliminate an equality that is smaller or equal to the edits on both\r\n      // sides of it.\r\n      if (lastequality && (lastequality.length <=\r\n          Math.max(length_insertions1, length_deletions1)) &&\r\n          (lastequality.length <= Math.max(length_insertions2,\r\n                                           length_deletions2))) {\r\n        // Duplicate record.\r\n        diffs.splice(equalities[equalitiesLength - 1], 0,\r\n                     [DIFF_DELETE, lastequality]);\r\n        // Change second copy to insert.\r\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\r\n        // Throw away the equality we just deleted.\r\n        equalitiesLength--;\r\n        // Throw away the previous equality (it needs to be reevaluated).\r\n        equalitiesLength--;\r\n        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;\r\n        length_insertions1 = 0;  // Reset the counters.\r\n        length_deletions1 = 0;\r\n        length_insertions2 = 0;\r\n        length_deletions2 = 0;\r\n        lastequality = null;\r\n        changes = true;\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n\r\n  // Normalize the diff.\r\n  if (changes) {\r\n    this.diff_cleanupMerge(diffs);\r\n  }\r\n  this.diff_cleanupSemanticLossless(diffs);\r\n\r\n  // Find any overlaps between deletions and insertions.\r\n  // e.g: <del>abcxxx</del><ins>xxxdef</ins>\r\n  //   -> <del>abc</del>xxx<ins>def</ins>\r\n  // e.g: <del>xxxabc</del><ins>defxxx</ins>\r\n  //   -> <ins>def</ins>xxx<del>abc</del>\r\n  // Only extract an overlap if it is as big as the edit ahead or behind it.\r\n  pointer = 1;\r\n  while (pointer < diffs.length) {\r\n    if (diffs[pointer - 1][0] == DIFF_DELETE &&\r\n        diffs[pointer][0] == DIFF_INSERT) {\r\n      var deletion = diffs[pointer - 1][1];\r\n      var insertion = diffs[pointer][1];\r\n      var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);\r\n      var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);\r\n      if (overlap_length1 >= overlap_length2) {\r\n        if (overlap_length1 >= deletion.length / 2 ||\r\n            overlap_length1 >= insertion.length / 2) {\r\n          // Overlap found.  Insert an equality and trim the surrounding edits.\r\n          diffs.splice(pointer, 0,\r\n              [DIFF_EQUAL, insertion.substring(0, overlap_length1)]);\r\n          diffs[pointer - 1][1] =\r\n              deletion.substring(0, deletion.length - overlap_length1);\r\n          diffs[pointer + 1][1] = insertion.substring(overlap_length1);\r\n          pointer++;\r\n        }\r\n      } else {\r\n        if (overlap_length2 >= deletion.length / 2 ||\r\n            overlap_length2 >= insertion.length / 2) {\r\n          // Reverse overlap found.\r\n          // Insert an equality and swap and trim the surrounding edits.\r\n          diffs.splice(pointer, 0,\r\n              [DIFF_EQUAL, deletion.substring(0, overlap_length2)]);\r\n          diffs[pointer - 1][0] = DIFF_INSERT;\r\n          diffs[pointer - 1][1] =\r\n              insertion.substring(0, insertion.length - overlap_length2);\r\n          diffs[pointer + 1][0] = DIFF_DELETE;\r\n          diffs[pointer + 1][1] =\r\n              deletion.substring(overlap_length2);\r\n          pointer++;\r\n        }\r\n      }\r\n      pointer++;\r\n    }\r\n    pointer++;\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Look for single edits surrounded on both sides by equalities\r\n * which can be shifted sideways to align the edit to a word boundary.\r\n * e.g: The c<ins>at c</ins>ame. -> The <ins>cat </ins>came.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {\r\n  /**\r\n   * Given two strings, compute a score representing whether the internal\r\n   * boundary falls on logical boundaries.\r\n   * Scores range from 6 (best) to 0 (worst).\r\n   * Closure, but does not reference any external variables.\r\n   * @param {string} one First string.\r\n   * @param {string} two Second string.\r\n   * @return {number} The score.\r\n   * @private\r\n   */\r\n  function diff_cleanupSemanticScore_(one, two) {\r\n    if (!one || !two) {\r\n      // Edges are the best.\r\n      return 6;\r\n    }\r\n\r\n    // Each port of this function behaves slightly differently due to\r\n    // subtle differences in each language's definition of things like\r\n    // 'whitespace'.  Since this function's purpose is largely cosmetic,\r\n    // the choice has been made to use each language's native features\r\n    // rather than force total conformity.\r\n    var char1 = one.charAt(one.length - 1);\r\n    var char2 = two.charAt(0);\r\n    var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);\r\n    var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);\r\n    var whitespace1 = nonAlphaNumeric1 &&\r\n        char1.match(diff_match_patch.whitespaceRegex_);\r\n    var whitespace2 = nonAlphaNumeric2 &&\r\n        char2.match(diff_match_patch.whitespaceRegex_);\r\n    var lineBreak1 = whitespace1 &&\r\n        char1.match(diff_match_patch.linebreakRegex_);\r\n    var lineBreak2 = whitespace2 &&\r\n        char2.match(diff_match_patch.linebreakRegex_);\r\n    var blankLine1 = lineBreak1 &&\r\n        one.match(diff_match_patch.blanklineEndRegex_);\r\n    var blankLine2 = lineBreak2 &&\r\n        two.match(diff_match_patch.blanklineStartRegex_);\r\n\r\n    if (blankLine1 || blankLine2) {\r\n      // Five points for blank lines.\r\n      return 5;\r\n    } else if (lineBreak1 || lineBreak2) {\r\n      // Four points for line breaks.\r\n      return 4;\r\n    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {\r\n      // Three points for end of sentences.\r\n      return 3;\r\n    } else if (whitespace1 || whitespace2) {\r\n      // Two points for whitespace.\r\n      return 2;\r\n    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {\r\n      // One point for non-alphanumeric.\r\n      return 1;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  var pointer = 1;\r\n  // Intentionally ignore the first and last element (don't need checking).\r\n  while (pointer < diffs.length - 1) {\r\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\r\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\r\n      // This is a single edit surrounded by equalities.\r\n      var equality1 = diffs[pointer - 1][1];\r\n      var edit = diffs[pointer][1];\r\n      var equality2 = diffs[pointer + 1][1];\r\n\r\n      // First, shift the edit as far left as possible.\r\n      var commonOffset = this.diff_commonSuffix(equality1, edit);\r\n      if (commonOffset) {\r\n        var commonString = edit.substring(edit.length - commonOffset);\r\n        equality1 = equality1.substring(0, equality1.length - commonOffset);\r\n        edit = commonString + edit.substring(0, edit.length - commonOffset);\r\n        equality2 = commonString + equality2;\r\n      }\r\n\r\n      // Second, step character by character right, looking for the best fit.\r\n      var bestEquality1 = equality1;\r\n      var bestEdit = edit;\r\n      var bestEquality2 = equality2;\r\n      var bestScore = diff_cleanupSemanticScore_(equality1, edit) +\r\n          diff_cleanupSemanticScore_(edit, equality2);\r\n      while (edit.charAt(0) === equality2.charAt(0)) {\r\n        equality1 += edit.charAt(0);\r\n        edit = edit.substring(1) + equality2.charAt(0);\r\n        equality2 = equality2.substring(1);\r\n        var score = diff_cleanupSemanticScore_(equality1, edit) +\r\n            diff_cleanupSemanticScore_(edit, equality2);\r\n        // The >= encourages trailing rather than leading whitespace on edits.\r\n        if (score >= bestScore) {\r\n          bestScore = score;\r\n          bestEquality1 = equality1;\r\n          bestEdit = edit;\r\n          bestEquality2 = equality2;\r\n        }\r\n      }\r\n\r\n      if (diffs[pointer - 1][1] != bestEquality1) {\r\n        // We have an improvement, save it back to the diff.\r\n        if (bestEquality1) {\r\n          diffs[pointer - 1][1] = bestEquality1;\r\n        } else {\r\n          diffs.splice(pointer - 1, 1);\r\n          pointer--;\r\n        }\r\n        diffs[pointer][1] = bestEdit;\r\n        if (bestEquality2) {\r\n          diffs[pointer + 1][1] = bestEquality2;\r\n        } else {\r\n          diffs.splice(pointer + 1, 1);\r\n          pointer--;\r\n        }\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n};\r\n\r\n// Define some regex patterns for matching boundaries.\r\ndiff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;\r\ndiff_match_patch.whitespaceRegex_ = /\\s/;\r\ndiff_match_patch.linebreakRegex_ = /[\\r\\n]/;\r\ndiff_match_patch.blanklineEndRegex_ = /\\n\\r?\\n$/;\r\ndiff_match_patch.blanklineStartRegex_ = /^\\r?\\n\\r?\\n/;\r\n\r\n/**\r\n * Reduce the number of edits by eliminating operationally trivial equalities.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {\r\n  var changes = false;\r\n  var equalities = [];  // Stack of indices where equalities are found.\r\n  var equalitiesLength = 0;  // Keeping our own length var is faster in JS.\r\n  /** @type {?string} */\r\n  var lastequality = null;\r\n  // Always equal to diffs[equalities[equalitiesLength - 1]][1]\r\n  var pointer = 0;  // Index of current position.\r\n  // Is there an insertion operation before the last equality.\r\n  var pre_ins = false;\r\n  // Is there a deletion operation before the last equality.\r\n  var pre_del = false;\r\n  // Is there an insertion operation after the last equality.\r\n  var post_ins = false;\r\n  // Is there a deletion operation after the last equality.\r\n  var post_del = false;\r\n  while (pointer < diffs.length) {\r\n    if (diffs[pointer][0] == DIFF_EQUAL) {  // Equality found.\r\n      if (diffs[pointer][1].length < this.Diff_EditCost &&\r\n          (post_ins || post_del)) {\r\n        // Candidate found.\r\n        equalities[equalitiesLength++] = pointer;\r\n        pre_ins = post_ins;\r\n        pre_del = post_del;\r\n        lastequality = diffs[pointer][1];\r\n      } else {\r\n        // Not a candidate, and can never become one.\r\n        equalitiesLength = 0;\r\n        lastequality = null;\r\n      }\r\n      post_ins = post_del = false;\r\n    } else {  // An insertion or deletion.\r\n      if (diffs[pointer][0] == DIFF_DELETE) {\r\n        post_del = true;\r\n      } else {\r\n        post_ins = true;\r\n      }\r\n      /*\r\n       * Five types to be split:\r\n       * <ins>A</ins><del>B</del>XY<ins>C</ins><del>D</del>\r\n       * <ins>A</ins>X<ins>C</ins><del>D</del>\r\n       * <ins>A</ins><del>B</del>X<ins>C</ins>\r\n       * <ins>A</del>X<ins>C</ins><del>D</del>\r\n       * <ins>A</ins><del>B</del>X<del>C</del>\r\n       */\r\n      if (lastequality && ((pre_ins && pre_del && post_ins && post_del) ||\r\n                           ((lastequality.length < this.Diff_EditCost / 2) &&\r\n                            (pre_ins + pre_del + post_ins + post_del) == 3))) {\r\n        // Duplicate record.\r\n        diffs.splice(equalities[equalitiesLength - 1], 0,\r\n                     [DIFF_DELETE, lastequality]);\r\n        // Change second copy to insert.\r\n        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;\r\n        equalitiesLength--;  // Throw away the equality we just deleted;\r\n        lastequality = null;\r\n        if (pre_ins && pre_del) {\r\n          // No changes made which could affect previous entry, keep going.\r\n          post_ins = post_del = true;\r\n          equalitiesLength = 0;\r\n        } else {\r\n          equalitiesLength--;  // Throw away the previous equality.\r\n          pointer = equalitiesLength > 0 ?\r\n              equalities[equalitiesLength - 1] : -1;\r\n          post_ins = post_del = false;\r\n        }\r\n        changes = true;\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n\r\n  if (changes) {\r\n    this.diff_cleanupMerge(diffs);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Reorder and merge like edit sections.  Merge equalities.\r\n * Any edit section can move as long as it doesn't cross an equality.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n */\r\ndiff_match_patch.prototype.diff_cleanupMerge = function(diffs) {\r\n  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.\r\n  var pointer = 0;\r\n  var count_delete = 0;\r\n  var count_insert = 0;\r\n  var text_delete = '';\r\n  var text_insert = '';\r\n  var commonlength;\r\n  while (pointer < diffs.length) {\r\n    switch (diffs[pointer][0]) {\r\n      case DIFF_INSERT:\r\n        count_insert++;\r\n        text_insert += diffs[pointer][1];\r\n        pointer++;\r\n        break;\r\n      case DIFF_DELETE:\r\n        count_delete++;\r\n        text_delete += diffs[pointer][1];\r\n        pointer++;\r\n        break;\r\n      case DIFF_EQUAL:\r\n        // Upon reaching an equality, check for prior redundancies.\r\n        if (count_delete + count_insert > 1) {\r\n          if (count_delete !== 0 && count_insert !== 0) {\r\n            // Factor out any common prefixies.\r\n            commonlength = this.diff_commonPrefix(text_insert, text_delete);\r\n            if (commonlength !== 0) {\r\n              if ((pointer - count_delete - count_insert) > 0 &&\r\n                  diffs[pointer - count_delete - count_insert - 1][0] ==\r\n                  DIFF_EQUAL) {\r\n                diffs[pointer - count_delete - count_insert - 1][1] +=\r\n                    text_insert.substring(0, commonlength);\r\n              } else {\r\n                diffs.splice(0, 0, [DIFF_EQUAL,\r\n                                    text_insert.substring(0, commonlength)]);\r\n                pointer++;\r\n              }\r\n              text_insert = text_insert.substring(commonlength);\r\n              text_delete = text_delete.substring(commonlength);\r\n            }\r\n            // Factor out any common suffixies.\r\n            commonlength = this.diff_commonSuffix(text_insert, text_delete);\r\n            if (commonlength !== 0) {\r\n              diffs[pointer][1] = text_insert.substring(text_insert.length -\r\n                  commonlength) + diffs[pointer][1];\r\n              text_insert = text_insert.substring(0, text_insert.length -\r\n                  commonlength);\r\n              text_delete = text_delete.substring(0, text_delete.length -\r\n                  commonlength);\r\n            }\r\n          }\r\n          // Delete the offending records and add the merged ones.\r\n          if (count_delete === 0) {\r\n            diffs.splice(pointer - count_insert,\r\n                count_delete + count_insert, [DIFF_INSERT, text_insert]);\r\n          } else if (count_insert === 0) {\r\n            diffs.splice(pointer - count_delete,\r\n                count_delete + count_insert, [DIFF_DELETE, text_delete]);\r\n          } else {\r\n            diffs.splice(pointer - count_delete - count_insert,\r\n                count_delete + count_insert, [DIFF_DELETE, text_delete],\r\n                [DIFF_INSERT, text_insert]);\r\n          }\r\n          pointer = pointer - count_delete - count_insert +\r\n                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;\r\n        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {\r\n          // Merge this equality with the previous one.\r\n          diffs[pointer - 1][1] += diffs[pointer][1];\r\n          diffs.splice(pointer, 1);\r\n        } else {\r\n          pointer++;\r\n        }\r\n        count_insert = 0;\r\n        count_delete = 0;\r\n        text_delete = '';\r\n        text_insert = '';\r\n        break;\r\n    }\r\n  }\r\n  if (diffs[diffs.length - 1][1] === '') {\r\n    diffs.pop();  // Remove the dummy entry at the end.\r\n  }\r\n\r\n  // Second pass: look for single edits surrounded on both sides by equalities\r\n  // which can be shifted sideways to eliminate an equality.\r\n  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC\r\n  var changes = false;\r\n  pointer = 1;\r\n  // Intentionally ignore the first and last element (don't need checking).\r\n  while (pointer < diffs.length - 1) {\r\n    if (diffs[pointer - 1][0] == DIFF_EQUAL &&\r\n        diffs[pointer + 1][0] == DIFF_EQUAL) {\r\n      // This is a single edit surrounded by equalities.\r\n      if (diffs[pointer][1].substring(diffs[pointer][1].length -\r\n          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {\r\n        // Shift the edit over the previous equality.\r\n        diffs[pointer][1] = diffs[pointer - 1][1] +\r\n            diffs[pointer][1].substring(0, diffs[pointer][1].length -\r\n                                        diffs[pointer - 1][1].length);\r\n        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];\r\n        diffs.splice(pointer - 1, 1);\r\n        changes = true;\r\n      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==\r\n          diffs[pointer + 1][1]) {\r\n        // Shift the edit over the next equality.\r\n        diffs[pointer - 1][1] += diffs[pointer + 1][1];\r\n        diffs[pointer][1] =\r\n            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +\r\n            diffs[pointer + 1][1];\r\n        diffs.splice(pointer + 1, 1);\r\n        changes = true;\r\n      }\r\n    }\r\n    pointer++;\r\n  }\r\n  // If shifts were made, the diff needs reordering and another shift sweep.\r\n  if (changes) {\r\n    this.diff_cleanupMerge(diffs);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * loc is a location in text1, compute and return the equivalent location in\r\n * text2.\r\n * e.g. 'The cat' vs 'The big cat', 1->1, 5->8\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @param {number} loc Location within text1.\r\n * @return {number} Location within text2.\r\n */\r\ndiff_match_patch.prototype.diff_xIndex = function(diffs, loc) {\r\n  var chars1 = 0;\r\n  var chars2 = 0;\r\n  var last_chars1 = 0;\r\n  var last_chars2 = 0;\r\n  var x;\r\n  for (x = 0; x < diffs.length; x++) {\r\n    if (diffs[x][0] !== DIFF_INSERT) {  // Equality or deletion.\r\n      chars1 += diffs[x][1].length;\r\n    }\r\n    if (diffs[x][0] !== DIFF_DELETE) {  // Equality or insertion.\r\n      chars2 += diffs[x][1].length;\r\n    }\r\n    if (chars1 > loc) {  // Overshot the location.\r\n      break;\r\n    }\r\n    last_chars1 = chars1;\r\n    last_chars2 = chars2;\r\n  }\r\n  // Was the location was deleted?\r\n  if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {\r\n    return last_chars2;\r\n  }\r\n  // Add the remaining character length.\r\n  return last_chars2 + (loc - last_chars1);\r\n};\r\n\r\n\r\n/**\r\n * Convert a diff array into a pretty HTML report.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} HTML representation.\r\n */\r\ndiff_match_patch.prototype.diff_prettyHtml = function(diffs) {\r\n  var html = [];\r\n  var pattern_amp = /&/g;\r\n  var pattern_lt = /</g;\r\n  var pattern_gt = />/g;\r\n  var pattern_para = /\\n/g;\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var op = diffs[x][0];    // Operation (insert, delete, equal)\r\n    var data = diffs[x][1];  // Text of change.\r\n    var text = data.replace(pattern_amp, '&amp;').replace(pattern_lt, '&lt;')\r\n        .replace(pattern_gt, '&gt;').replace(pattern_para, '&para;<br>');\r\n    switch (op) {\r\n      case DIFF_INSERT:\r\n        html[x] = '<ins style=\"background:#e6ffe6;\">' + text + '</ins>';\r\n        break;\r\n      case DIFF_DELETE:\r\n        html[x] = '<del style=\"background:#ffe6e6;\">' + text + '</del>';\r\n        break;\r\n      case DIFF_EQUAL:\r\n        html[x] = '<span>' + text + '</span>';\r\n        break;\r\n    }\r\n  }\r\n  return html.join('');\r\n};\r\n\r\n\r\n/**\r\n * Compute and return the source text (all equalities and deletions).\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} Source text.\r\n */\r\ndiff_match_patch.prototype.diff_text1 = function(diffs) {\r\n  var text = [];\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    if (diffs[x][0] !== DIFF_INSERT) {\r\n      text[x] = diffs[x][1];\r\n    }\r\n  }\r\n  return text.join('');\r\n};\r\n\r\n\r\n/**\r\n * Compute and return the destination text (all equalities and insertions).\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} Destination text.\r\n */\r\ndiff_match_patch.prototype.diff_text2 = function(diffs) {\r\n  var text = [];\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    if (diffs[x][0] !== DIFF_DELETE) {\r\n      text[x] = diffs[x][1];\r\n    }\r\n  }\r\n  return text.join('');\r\n};\r\n\r\n\r\n/**\r\n * Compute the Levenshtein distance; the number of inserted, deleted or\r\n * substituted characters.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {number} Number of changes.\r\n */\r\ndiff_match_patch.prototype.diff_levenshtein = function(diffs) {\r\n  var levenshtein = 0;\r\n  var insertions = 0;\r\n  var deletions = 0;\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var op = diffs[x][0];\r\n    var data = diffs[x][1];\r\n    switch (op) {\r\n      case DIFF_INSERT:\r\n        insertions += data.length;\r\n        break;\r\n      case DIFF_DELETE:\r\n        deletions += data.length;\r\n        break;\r\n      case DIFF_EQUAL:\r\n        // A deletion and an insertion is one substitution.\r\n        levenshtein += Math.max(insertions, deletions);\r\n        insertions = 0;\r\n        deletions = 0;\r\n        break;\r\n    }\r\n  }\r\n  levenshtein += Math.max(insertions, deletions);\r\n  return levenshtein;\r\n};\r\n\r\n\r\n/**\r\n * Crush the diff into an encoded string which describes the operations\r\n * required to transform text1 into text2.\r\n * E.g. =3\\t-2\\t+ing  -> Keep 3 chars, delete 2 chars, insert 'ing'.\r\n * Operations are tab-separated.  Inserted text is escaped using %xx notation.\r\n * @param {!Array.<!diff_match_patch.Diff>} diffs Array of diff tuples.\r\n * @return {string} Delta text.\r\n */\r\ndiff_match_patch.prototype.diff_toDelta = function(diffs) {\r\n  var text = [];\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    switch (diffs[x][0]) {\r\n      case DIFF_INSERT:\r\n        text[x] = '+' + encodeURI(diffs[x][1]);\r\n        break;\r\n      case DIFF_DELETE:\r\n        text[x] = '-' + diffs[x][1].length;\r\n        break;\r\n      case DIFF_EQUAL:\r\n        text[x] = '=' + diffs[x][1].length;\r\n        break;\r\n    }\r\n  }\r\n  return text.join('\\t').replace(/%20/g, ' ');\r\n};\r\n\r\n\r\n/**\r\n * Given the original text1, and an encoded string which describes the\r\n * operations required to transform text1 into text2, compute the full diff.\r\n * @param {string} text1 Source string for the diff.\r\n * @param {string} delta Delta text.\r\n * @return {!Array.<!diff_match_patch.Diff>} Array of diff tuples.\r\n * @throws {!Error} If invalid input.\r\n */\r\ndiff_match_patch.prototype.diff_fromDelta = function(text1, delta) {\r\n  var diffs = [];\r\n  var diffsLength = 0;  // Keeping our own length var is faster in JS.\r\n  var pointer = 0;  // Cursor in text1\r\n  var tokens = delta.split(/\\t/g);\r\n  for (var x = 0; x < tokens.length; x++) {\r\n    // Each token begins with a one character parameter which specifies the\r\n    // operation of this token (delete, insert, equality).\r\n    var param = tokens[x].substring(1);\r\n    switch (tokens[x].charAt(0)) {\r\n      case '+':\r\n        try {\r\n          diffs[diffsLength++] = [DIFF_INSERT, decodeURI(param)];\r\n        } catch (ex) {\r\n          // Malformed URI sequence.\r\n          throw new Error('Illegal escape in diff_fromDelta: ' + param);\r\n        }\r\n        break;\r\n      case '-':\r\n        // Fall through.\r\n      case '=':\r\n        var n = parseInt(param, 10);\r\n        if (isNaN(n) || n < 0) {\r\n          throw new Error('Invalid number in diff_fromDelta: ' + param);\r\n        }\r\n        var text = text1.substring(pointer, pointer += n);\r\n        if (tokens[x].charAt(0) == '=') {\r\n          diffs[diffsLength++] = [DIFF_EQUAL, text];\r\n        } else {\r\n          diffs[diffsLength++] = [DIFF_DELETE, text];\r\n        }\r\n        break;\r\n      default:\r\n        // Blank tokens are ok (from a trailing \\t).\r\n        // Anything else is an error.\r\n        if (tokens[x]) {\r\n          throw new Error('Invalid diff operation in diff_fromDelta: ' +\r\n                          tokens[x]);\r\n        }\r\n    }\r\n  }\r\n  if (pointer != text1.length) {\r\n    throw new Error('Delta length (' + pointer +\r\n        ') does not equal source text length (' + text1.length + ').');\r\n  }\r\n  return diffs;\r\n};\r\n\r\n\r\n//  MATCH FUNCTIONS\r\n\r\n\r\n/**\r\n * Locate the best instance of 'pattern' in 'text' near 'loc'.\r\n * @param {string} text The text to search.\r\n * @param {string} pattern The pattern to search for.\r\n * @param {number} loc The location to search around.\r\n * @return {number} Best match index or -1.\r\n */\r\ndiff_match_patch.prototype.match_main = function(text, pattern, loc) {\r\n  // Check for null inputs.\r\n  if (text == null || pattern == null || loc == null) {\r\n    throw new Error('Null input. (match_main)');\r\n  }\r\n\r\n  loc = Math.max(0, Math.min(loc, text.length));\r\n  if (text == pattern) {\r\n    // Shortcut (potentially not guaranteed by the algorithm)\r\n    return 0;\r\n  } else if (!text.length) {\r\n    // Nothing to match.\r\n    return -1;\r\n  } else if (text.substring(loc, loc + pattern.length) == pattern) {\r\n    // Perfect match at the perfect spot!  (Includes case of null pattern)\r\n    return loc;\r\n  } else {\r\n    // Do a fuzzy compare.\r\n    return this.match_bitap_(text, pattern, loc);\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Locate the best instance of 'pattern' in 'text' near 'loc' using the\r\n * Bitap algorithm.\r\n * @param {string} text The text to search.\r\n * @param {string} pattern The pattern to search for.\r\n * @param {number} loc The location to search around.\r\n * @return {number} Best match index or -1.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {\r\n  if (pattern.length > this.Match_MaxBits) {\r\n    throw new Error('Pattern too long for this browser.');\r\n  }\r\n\r\n  // Initialise the alphabet.\r\n  var s = this.match_alphabet_(pattern);\r\n\r\n  var dmp = this;  // 'this' becomes 'window' in a closure.\r\n\r\n  /**\r\n   * Compute and return the score for a match with e errors and x location.\r\n   * Accesses loc and pattern through being a closure.\r\n   * @param {number} e Number of errors in match.\r\n   * @param {number} x Location of match.\r\n   * @return {number} Overall score for match (0.0 = good, 1.0 = bad).\r\n   * @private\r\n   */\r\n  function match_bitapScore_(e, x) {\r\n    var accuracy = e / pattern.length;\r\n    var proximity = Math.abs(loc - x);\r\n    if (!dmp.Match_Distance) {\r\n      // Dodge divide by zero error.\r\n      return proximity ? 1.0 : accuracy;\r\n    }\r\n    return accuracy + (proximity / dmp.Match_Distance);\r\n  }\r\n\r\n  // Highest score beyond which we give up.\r\n  var score_threshold = this.Match_Threshold;\r\n  // Is there a nearby exact match? (speedup)\r\n  var best_loc = text.indexOf(pattern, loc);\r\n  if (best_loc != -1) {\r\n    score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);\r\n    // What about in the other direction? (speedup)\r\n    best_loc = text.lastIndexOf(pattern, loc + pattern.length);\r\n    if (best_loc != -1) {\r\n      score_threshold =\r\n          Math.min(match_bitapScore_(0, best_loc), score_threshold);\r\n    }\r\n  }\r\n\r\n  // Initialise the bit arrays.\r\n  var matchmask = 1 << (pattern.length - 1);\r\n  best_loc = -1;\r\n\r\n  var bin_min, bin_mid;\r\n  var bin_max = pattern.length + text.length;\r\n  var last_rd;\r\n  for (var d = 0; d < pattern.length; d++) {\r\n    // Scan for the best match; each iteration allows for one more error.\r\n    // Run a binary search to determine how far from 'loc' we can stray at this\r\n    // error level.\r\n    bin_min = 0;\r\n    bin_mid = bin_max;\r\n    while (bin_min < bin_mid) {\r\n      if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {\r\n        bin_min = bin_mid;\r\n      } else {\r\n        bin_max = bin_mid;\r\n      }\r\n      bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);\r\n    }\r\n    // Use the result from this iteration as the maximum for the next.\r\n    bin_max = bin_mid;\r\n    var start = Math.max(1, loc - bin_mid + 1);\r\n    var finish = Math.min(loc + bin_mid, text.length) + pattern.length;\r\n\r\n    var rd = Array(finish + 2);\r\n    rd[finish + 1] = (1 << d) - 1;\r\n    for (var j = finish; j >= start; j--) {\r\n      // The alphabet (s) is a sparse hash, so the following line generates\r\n      // warnings.\r\n      var charMatch = s[text.charAt(j - 1)];\r\n      if (d === 0) {  // First pass: exact match.\r\n        rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;\r\n      } else {  // Subsequent passes: fuzzy match.\r\n        rd[j] = (((rd[j + 1] << 1) | 1) & charMatch) |\r\n                (((last_rd[j + 1] | last_rd[j]) << 1) | 1) |\r\n                last_rd[j + 1];\r\n      }\r\n      if (rd[j] & matchmask) {\r\n        var score = match_bitapScore_(d, j - 1);\r\n        // This match will almost certainly be better than any existing match.\r\n        // But check anyway.\r\n        if (score <= score_threshold) {\r\n          // Told you so.\r\n          score_threshold = score;\r\n          best_loc = j - 1;\r\n          if (best_loc > loc) {\r\n            // When passing loc, don't exceed our current distance from loc.\r\n            start = Math.max(1, 2 * loc - best_loc);\r\n          } else {\r\n            // Already passed loc, downhill from here on in.\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // No hope for a (better) match at greater error levels.\r\n    if (match_bitapScore_(d + 1, loc) > score_threshold) {\r\n      break;\r\n    }\r\n    last_rd = rd;\r\n  }\r\n  return best_loc;\r\n};\r\n\r\n\r\n/**\r\n * Initialise the alphabet for the Bitap algorithm.\r\n * @param {string} pattern The text to encode.\r\n * @return {!Object} Hash of character locations.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.match_alphabet_ = function(pattern) {\r\n  var s = {};\r\n  for (var i = 0; i < pattern.length; i++) {\r\n    s[pattern.charAt(i)] = 0;\r\n  }\r\n  for (var i = 0; i < pattern.length; i++) {\r\n    s[pattern.charAt(i)] |= 1 << (pattern.length - i - 1);\r\n  }\r\n  return s;\r\n};\r\n\r\n\r\n//  PATCH FUNCTIONS\r\n\r\n\r\n/**\r\n * Increase the context until it is unique,\r\n * but don't let the pattern expand beyond Match_MaxBits.\r\n * @param {!diff_match_patch.patch_obj} patch The patch to grow.\r\n * @param {string} text Source text.\r\n * @private\r\n */\r\ndiff_match_patch.prototype.patch_addContext_ = function(patch, text) {\r\n  if (text.length == 0) {\r\n    return;\r\n  }\r\n  var pattern = text.substring(patch.start2, patch.start2 + patch.length1);\r\n  var padding = 0;\r\n\r\n  // Look for the first and last matches of pattern in text.  If two different\r\n  // matches are found, increase the pattern length.\r\n  while (text.indexOf(pattern) != text.lastIndexOf(pattern) &&\r\n         pattern.length < this.Match_MaxBits - this.Patch_Margin -\r\n         this.Patch_Margin) {\r\n    padding += this.Patch_Margin;\r\n    pattern = text.substring(patch.start2 - padding,\r\n                             patch.start2 + patch.length1 + padding);\r\n  }\r\n  // Add one chunk for good luck.\r\n  padding += this.Patch_Margin;\r\n\r\n  // Add the prefix.\r\n  var prefix = text.substring(patch.start2 - padding, patch.start2);\r\n  if (prefix) {\r\n    patch.diffs.unshift([DIFF_EQUAL, prefix]);\r\n  }\r\n  // Add the suffix.\r\n  var suffix = text.substring(patch.start2 + patch.length1,\r\n                              patch.start2 + patch.length1 + padding);\r\n  if (suffix) {\r\n    patch.diffs.push([DIFF_EQUAL, suffix]);\r\n  }\r\n\r\n  // Roll back the start points.\r\n  patch.start1 -= prefix.length;\r\n  patch.start2 -= prefix.length;\r\n  // Extend the lengths.\r\n  patch.length1 += prefix.length + suffix.length;\r\n  patch.length2 += prefix.length + suffix.length;\r\n};\r\n\r\n\r\n/**\r\n * Compute a list of patches to turn text1 into text2.\r\n * Use diffs if provided, otherwise compute it ourselves.\r\n * There are four ways to call this function, depending on what data is\r\n * available to the caller:\r\n * Method 1:\r\n * a = text1, b = text2\r\n * Method 2:\r\n * a = diffs\r\n * Method 3 (optimal):\r\n * a = text1, b = diffs\r\n * Method 4 (deprecated, use method 3):\r\n * a = text1, b = text2, c = diffs\r\n *\r\n * @param {string|!Array.<!diff_match_patch.Diff>} a text1 (methods 1,3,4) or\r\n * Array of diff tuples for text1 to text2 (method 2).\r\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_b text2 (methods 1,4) or\r\n * Array of diff tuples for text1 to text2 (method 3) or undefined (method 2).\r\n * @param {string|!Array.<!diff_match_patch.Diff>} opt_c Array of diff tuples\r\n * for text1 to text2 (method 4) or undefined (methods 1,2,3).\r\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n */\r\ndiff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {\r\n  var text1, diffs;\r\n  if (typeof a == 'string' && typeof opt_b == 'string' &&\r\n      typeof opt_c == 'undefined') {\r\n    // Method 1: text1, text2\r\n    // Compute diffs from text1 and text2.\r\n    text1 = /** @type {string} */(a);\r\n    diffs = this.diff_main(text1, /** @type {string} */(opt_b), true);\r\n    if (diffs.length > 2) {\r\n      this.diff_cleanupSemantic(diffs);\r\n      this.diff_cleanupEfficiency(diffs);\r\n    }\r\n  } else if (a && typeof a == 'object' && typeof opt_b == 'undefined' &&\r\n      typeof opt_c == 'undefined') {\r\n    // Method 2: diffs\r\n    // Compute text1 from diffs.\r\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(a);\r\n    text1 = this.diff_text1(diffs);\r\n  } else if (typeof a == 'string' && opt_b && typeof opt_b == 'object' &&\r\n      typeof opt_c == 'undefined') {\r\n    // Method 3: text1, diffs\r\n    text1 = /** @type {string} */(a);\r\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_b);\r\n  } else if (typeof a == 'string' && typeof opt_b == 'string' &&\r\n      opt_c && typeof opt_c == 'object') {\r\n    // Method 4: text1, text2, diffs\r\n    // text2 is not used.\r\n    text1 = /** @type {string} */(a);\r\n    diffs = /** @type {!Array.<!diff_match_patch.Diff>} */(opt_c);\r\n  } else {\r\n    throw new Error('Unknown call format to patch_make.');\r\n  }\r\n\r\n  if (diffs.length === 0) {\r\n    return [];  // Get rid of the null case.\r\n  }\r\n  var patches = [];\r\n  var patch = new diff_match_patch.patch_obj();\r\n  var patchDiffLength = 0;  // Keeping our own length var is faster in JS.\r\n  var char_count1 = 0;  // Number of characters into the text1 string.\r\n  var char_count2 = 0;  // Number of characters into the text2 string.\r\n  // Start with text1 (prepatch_text) and apply the diffs until we arrive at\r\n  // text2 (postpatch_text).  We recreate the patches one by one to determine\r\n  // context info.\r\n  var prepatch_text = text1;\r\n  var postpatch_text = text1;\r\n  for (var x = 0; x < diffs.length; x++) {\r\n    var diff_type = diffs[x][0];\r\n    var diff_text = diffs[x][1];\r\n\r\n    if (!patchDiffLength && diff_type !== DIFF_EQUAL) {\r\n      // A new patch starts here.\r\n      patch.start1 = char_count1;\r\n      patch.start2 = char_count2;\r\n    }\r\n\r\n    switch (diff_type) {\r\n      case DIFF_INSERT:\r\n        patch.diffs[patchDiffLength++] = diffs[x];\r\n        patch.length2 += diff_text.length;\r\n        postpatch_text = postpatch_text.substring(0, char_count2) + diff_text +\r\n                         postpatch_text.substring(char_count2);\r\n        break;\r\n      case DIFF_DELETE:\r\n        patch.length1 += diff_text.length;\r\n        patch.diffs[patchDiffLength++] = diffs[x];\r\n        postpatch_text = postpatch_text.substring(0, char_count2) +\r\n                         postpatch_text.substring(char_count2 +\r\n                             diff_text.length);\r\n        break;\r\n      case DIFF_EQUAL:\r\n        if (diff_text.length <= 2 * this.Patch_Margin &&\r\n            patchDiffLength && diffs.length != x + 1) {\r\n          // Small equality inside a patch.\r\n          patch.diffs[patchDiffLength++] = diffs[x];\r\n          patch.length1 += diff_text.length;\r\n          patch.length2 += diff_text.length;\r\n        } else if (diff_text.length >= 2 * this.Patch_Margin) {\r\n          // Time for a new patch.\r\n          if (patchDiffLength) {\r\n            this.patch_addContext_(patch, prepatch_text);\r\n            patches.push(patch);\r\n            patch = new diff_match_patch.patch_obj();\r\n            patchDiffLength = 0;\r\n            // Unlike Unidiff, our patch lists have a rolling context.\r\n            // http://code.google.com/p/google-diff-match-patch/wiki/Unidiff\r\n            // Update prepatch text & pos to reflect the application of the\r\n            // just completed patch.\r\n            prepatch_text = postpatch_text;\r\n            char_count1 = char_count2;\r\n          }\r\n        }\r\n        break;\r\n    }\r\n\r\n    // Update the current character count.\r\n    if (diff_type !== DIFF_INSERT) {\r\n      char_count1 += diff_text.length;\r\n    }\r\n    if (diff_type !== DIFF_DELETE) {\r\n      char_count2 += diff_text.length;\r\n    }\r\n  }\r\n  // Pick up the leftover patch if not empty.\r\n  if (patchDiffLength) {\r\n    this.patch_addContext_(patch, prepatch_text);\r\n    patches.push(patch);\r\n  }\r\n\r\n  return patches;\r\n};\r\n\r\n\r\n/**\r\n * Given an array of patches, return another array that is identical.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n */\r\ndiff_match_patch.prototype.patch_deepCopy = function(patches) {\r\n  // Making deep copies is hard in JavaScript.\r\n  var patchesCopy = [];\r\n  for (var x = 0; x < patches.length; x++) {\r\n    var patch = patches[x];\r\n    var patchCopy = new diff_match_patch.patch_obj();\r\n    patchCopy.diffs = [];\r\n    for (var y = 0; y < patch.diffs.length; y++) {\r\n      patchCopy.diffs[y] = patch.diffs[y].slice();\r\n    }\r\n    patchCopy.start1 = patch.start1;\r\n    patchCopy.start2 = patch.start2;\r\n    patchCopy.length1 = patch.length1;\r\n    patchCopy.length2 = patch.length2;\r\n    patchesCopy[x] = patchCopy;\r\n  }\r\n  return patchesCopy;\r\n};\r\n\r\n\r\n/**\r\n * Merge a set of patches onto the text.  Return a patched text, as well\r\n * as a list of true/false values indicating which patches were applied.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @param {string} text Old text.\r\n * @return {!Array.<string|!Array.<boolean>>} Two element Array, containing the\r\n *      new text and an array of boolean values.\r\n */\r\ndiff_match_patch.prototype.patch_apply = function(patches, text) {\r\n  if (patches.length == 0) {\r\n    return [text, []];\r\n  }\r\n\r\n  // Deep copy the patches so that no changes are made to originals.\r\n  patches = this.patch_deepCopy(patches);\r\n\r\n  var nullPadding = this.patch_addPadding(patches);\r\n  text = nullPadding + text + nullPadding;\r\n\r\n  this.patch_splitMax(patches);\r\n  // delta keeps track of the offset between the expected and actual location\r\n  // of the previous patch.  If there are patches expected at positions 10 and\r\n  // 20, but the first patch was found at 12, delta is 2 and the second patch\r\n  // has an effective expected position of 22.\r\n  var delta = 0;\r\n  var results = [];\r\n  for (var x = 0; x < patches.length; x++) {\r\n    var expected_loc = patches[x].start2 + delta;\r\n    var text1 = this.diff_text1(patches[x].diffs);\r\n    var start_loc;\r\n    var end_loc = -1;\r\n    if (text1.length > this.Match_MaxBits) {\r\n      // patch_splitMax will only provide an oversized pattern in the case of\r\n      // a monster delete.\r\n      start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits),\r\n                                  expected_loc);\r\n      if (start_loc != -1) {\r\n        end_loc = this.match_main(text,\r\n            text1.substring(text1.length - this.Match_MaxBits),\r\n            expected_loc + text1.length - this.Match_MaxBits);\r\n        if (end_loc == -1 || start_loc >= end_loc) {\r\n          // Can't find valid trailing context.  Drop this patch.\r\n          start_loc = -1;\r\n        }\r\n      }\r\n    } else {\r\n      start_loc = this.match_main(text, text1, expected_loc);\r\n    }\r\n    if (start_loc == -1) {\r\n      // No match found.  :(\r\n      results[x] = false;\r\n      // Subtract the delta for this failed patch from subsequent patches.\r\n      delta -= patches[x].length2 - patches[x].length1;\r\n    } else {\r\n      // Found a match.  :)\r\n      results[x] = true;\r\n      delta = start_loc - expected_loc;\r\n      var text2;\r\n      if (end_loc == -1) {\r\n        text2 = text.substring(start_loc, start_loc + text1.length);\r\n      } else {\r\n        text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);\r\n      }\r\n      if (text1 == text2) {\r\n        // Perfect match, just shove the replacement text in.\r\n        text = text.substring(0, start_loc) +\r\n               this.diff_text2(patches[x].diffs) +\r\n               text.substring(start_loc + text1.length);\r\n      } else {\r\n        // Imperfect match.  Run a diff to get a framework of equivalent\r\n        // indices.\r\n        var diffs = this.diff_main(text1, text2, false);\r\n        if (text1.length > this.Match_MaxBits &&\r\n            this.diff_levenshtein(diffs) / text1.length >\r\n            this.Patch_DeleteThreshold) {\r\n          // The end points match, but the content is unacceptably bad.\r\n          results[x] = false;\r\n        } else {\r\n          this.diff_cleanupSemanticLossless(diffs);\r\n          var index1 = 0;\r\n          var index2;\r\n          for (var y = 0; y < patches[x].diffs.length; y++) {\r\n            var mod = patches[x].diffs[y];\r\n            if (mod[0] !== DIFF_EQUAL) {\r\n              index2 = this.diff_xIndex(diffs, index1);\r\n            }\r\n            if (mod[0] === DIFF_INSERT) {  // Insertion\r\n              text = text.substring(0, start_loc + index2) + mod[1] +\r\n                     text.substring(start_loc + index2);\r\n            } else if (mod[0] === DIFF_DELETE) {  // Deletion\r\n              text = text.substring(0, start_loc + index2) +\r\n                     text.substring(start_loc + this.diff_xIndex(diffs,\r\n                         index1 + mod[1].length));\r\n            }\r\n            if (mod[0] !== DIFF_DELETE) {\r\n              index1 += mod[1].length;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Strip the padding off.\r\n  text = text.substring(nullPadding.length, text.length - nullPadding.length);\r\n  return [text, results];\r\n};\r\n\r\n\r\n/**\r\n * Add some padding on text start and end so that edges can match something.\r\n * Intended to be called only from within patch_apply.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @return {string} The padding string added to each side.\r\n */\r\ndiff_match_patch.prototype.patch_addPadding = function(patches) {\r\n  var paddingLength = this.Patch_Margin;\r\n  var nullPadding = '';\r\n  for (var x = 1; x <= paddingLength; x++) {\r\n    nullPadding += String.fromCharCode(x);\r\n  }\r\n\r\n  // Bump all the patches forward.\r\n  for (var x = 0; x < patches.length; x++) {\r\n    patches[x].start1 += paddingLength;\r\n    patches[x].start2 += paddingLength;\r\n  }\r\n\r\n  // Add some padding on start of first diff.\r\n  var patch = patches[0];\r\n  var diffs = patch.diffs;\r\n  if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {\r\n    // Add nullPadding equality.\r\n    diffs.unshift([DIFF_EQUAL, nullPadding]);\r\n    patch.start1 -= paddingLength;  // Should be 0.\r\n    patch.start2 -= paddingLength;  // Should be 0.\r\n    patch.length1 += paddingLength;\r\n    patch.length2 += paddingLength;\r\n  } else if (paddingLength > diffs[0][1].length) {\r\n    // Grow first equality.\r\n    var extraLength = paddingLength - diffs[0][1].length;\r\n    diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];\r\n    patch.start1 -= extraLength;\r\n    patch.start2 -= extraLength;\r\n    patch.length1 += extraLength;\r\n    patch.length2 += extraLength;\r\n  }\r\n\r\n  // Add some padding on end of last diff.\r\n  patch = patches[patches.length - 1];\r\n  diffs = patch.diffs;\r\n  if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {\r\n    // Add nullPadding equality.\r\n    diffs.push([DIFF_EQUAL, nullPadding]);\r\n    patch.length1 += paddingLength;\r\n    patch.length2 += paddingLength;\r\n  } else if (paddingLength > diffs[diffs.length - 1][1].length) {\r\n    // Grow last equality.\r\n    var extraLength = paddingLength - diffs[diffs.length - 1][1].length;\r\n    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);\r\n    patch.length1 += extraLength;\r\n    patch.length2 += extraLength;\r\n  }\r\n\r\n  return nullPadding;\r\n};\r\n\r\n\r\n/**\r\n * Look through the patches and break up any which are longer than the maximum\r\n * limit of the match algorithm.\r\n * Intended to be called only from within patch_apply.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n */\r\ndiff_match_patch.prototype.patch_splitMax = function(patches) {\r\n  var patch_size = this.Match_MaxBits;\r\n  for (var x = 0; x < patches.length; x++) {\r\n    if (patches[x].length1 <= patch_size) {\r\n      continue;\r\n    }\r\n    var bigpatch = patches[x];\r\n    // Remove the big old patch.\r\n    patches.splice(x--, 1);\r\n    var start1 = bigpatch.start1;\r\n    var start2 = bigpatch.start2;\r\n    var precontext = '';\r\n    while (bigpatch.diffs.length !== 0) {\r\n      // Create one of several smaller patches.\r\n      var patch = new diff_match_patch.patch_obj();\r\n      var empty = true;\r\n      patch.start1 = start1 - precontext.length;\r\n      patch.start2 = start2 - precontext.length;\r\n      if (precontext !== '') {\r\n        patch.length1 = patch.length2 = precontext.length;\r\n        patch.diffs.push([DIFF_EQUAL, precontext]);\r\n      }\r\n      while (bigpatch.diffs.length !== 0 &&\r\n             patch.length1 < patch_size - this.Patch_Margin) {\r\n        var diff_type = bigpatch.diffs[0][0];\r\n        var diff_text = bigpatch.diffs[0][1];\r\n        if (diff_type === DIFF_INSERT) {\r\n          // Insertions are harmless.\r\n          patch.length2 += diff_text.length;\r\n          start2 += diff_text.length;\r\n          patch.diffs.push(bigpatch.diffs.shift());\r\n          empty = false;\r\n        } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 &&\r\n                   patch.diffs[0][0] == DIFF_EQUAL &&\r\n                   diff_text.length > 2 * patch_size) {\r\n          // This is a large deletion.  Let it pass in one chunk.\r\n          patch.length1 += diff_text.length;\r\n          start1 += diff_text.length;\r\n          empty = false;\r\n          patch.diffs.push([diff_type, diff_text]);\r\n          bigpatch.diffs.shift();\r\n        } else {\r\n          // Deletion or equality.  Only take as much as we can stomach.\r\n          diff_text = diff_text.substring(0,\r\n              patch_size - patch.length1 - this.Patch_Margin);\r\n          patch.length1 += diff_text.length;\r\n          start1 += diff_text.length;\r\n          if (diff_type === DIFF_EQUAL) {\r\n            patch.length2 += diff_text.length;\r\n            start2 += diff_text.length;\r\n          } else {\r\n            empty = false;\r\n          }\r\n          patch.diffs.push([diff_type, diff_text]);\r\n          if (diff_text == bigpatch.diffs[0][1]) {\r\n            bigpatch.diffs.shift();\r\n          } else {\r\n            bigpatch.diffs[0][1] =\r\n                bigpatch.diffs[0][1].substring(diff_text.length);\r\n          }\r\n        }\r\n      }\r\n      // Compute the head context for the next patch.\r\n      precontext = this.diff_text2(patch.diffs);\r\n      precontext =\r\n          precontext.substring(precontext.length - this.Patch_Margin);\r\n      // Append the end context for this patch.\r\n      var postcontext = this.diff_text1(bigpatch.diffs)\r\n                            .substring(0, this.Patch_Margin);\r\n      if (postcontext !== '') {\r\n        patch.length1 += postcontext.length;\r\n        patch.length2 += postcontext.length;\r\n        if (patch.diffs.length !== 0 &&\r\n            patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {\r\n          patch.diffs[patch.diffs.length - 1][1] += postcontext;\r\n        } else {\r\n          patch.diffs.push([DIFF_EQUAL, postcontext]);\r\n        }\r\n      }\r\n      if (!empty) {\r\n        patches.splice(++x, 0, patch);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n\r\n/**\r\n * Take a list of patches and return a textual representation.\r\n * @param {!Array.<!diff_match_patch.patch_obj>} patches Array of Patch objects.\r\n * @return {string} Text representation of patches.\r\n */\r\ndiff_match_patch.prototype.patch_toText = function(patches) {\r\n  var text = [];\r\n  for (var x = 0; x < patches.length; x++) {\r\n    text[x] = patches[x];\r\n  }\r\n  return text.join('');\r\n};\r\n\r\n\r\n/**\r\n * Parse a textual representation of patches and return a list of Patch objects.\r\n * @param {string} textline Text representation of patches.\r\n * @return {!Array.<!diff_match_patch.patch_obj>} Array of Patch objects.\r\n * @throws {!Error} If invalid input.\r\n */\r\ndiff_match_patch.prototype.patch_fromText = function(textline) {\r\n  var patches = [];\r\n  if (!textline) {\r\n    return patches;\r\n  }\r\n  var text = textline.split('\\n');\r\n  var textPointer = 0;\r\n  var patchHeader = /^@@ -(\\d+),?(\\d*) \\+(\\d+),?(\\d*) @@$/;\r\n  while (textPointer < text.length) {\r\n    var m = text[textPointer].match(patchHeader);\r\n    if (!m) {\r\n      throw new Error('Invalid patch string: ' + text[textPointer]);\r\n    }\r\n    var patch = new diff_match_patch.patch_obj();\r\n    patches.push(patch);\r\n    patch.start1 = parseInt(m[1], 10);\r\n    if (m[2] === '') {\r\n      patch.start1--;\r\n      patch.length1 = 1;\r\n    } else if (m[2] == '0') {\r\n      patch.length1 = 0;\r\n    } else {\r\n      patch.start1--;\r\n      patch.length1 = parseInt(m[2], 10);\r\n    }\r\n\r\n    patch.start2 = parseInt(m[3], 10);\r\n    if (m[4] === '') {\r\n      patch.start2--;\r\n      patch.length2 = 1;\r\n    } else if (m[4] == '0') {\r\n      patch.length2 = 0;\r\n    } else {\r\n      patch.start2--;\r\n      patch.length2 = parseInt(m[4], 10);\r\n    }\r\n    textPointer++;\r\n\r\n    while (textPointer < text.length) {\r\n      var sign = text[textPointer].charAt(0);\r\n      try {\r\n        var line = decodeURI(text[textPointer].substring(1));\r\n      } catch (ex) {\r\n        // Malformed URI sequence.\r\n        throw new Error('Illegal escape in patch_fromText: ' + line);\r\n      }\r\n      if (sign == '-') {\r\n        // Deletion.\r\n        patch.diffs.push([DIFF_DELETE, line]);\r\n      } else if (sign == '+') {\r\n        // Insertion.\r\n        patch.diffs.push([DIFF_INSERT, line]);\r\n      } else if (sign == ' ') {\r\n        // Minor equality.\r\n        patch.diffs.push([DIFF_EQUAL, line]);\r\n      } else if (sign == '@') {\r\n        // Start of next patch.\r\n        break;\r\n      } else if (sign === '') {\r\n        // Blank line?  Whatever.\r\n      } else {\r\n        // WTF?\r\n        throw new Error('Invalid patch mode \"' + sign + '\" in: ' + line);\r\n      }\r\n      textPointer++;\r\n    }\r\n  }\r\n  return patches;\r\n};\r\n\r\n\r\n/**\r\n * Class representing one patch operation.\r\n * @constructor\r\n */\r\ndiff_match_patch.patch_obj = function() {\r\n  /** @type {!Array.<!diff_match_patch.Diff>} */\r\n  this.diffs = [];\r\n  /** @type {?number} */\r\n  this.start1 = null;\r\n  /** @type {?number} */\r\n  this.start2 = null;\r\n  /** @type {number} */\r\n  this.length1 = 0;\r\n  /** @type {number} */\r\n  this.length2 = 0;\r\n};\r\n\r\n\r\n/**\r\n * Emmulate GNU diff's format.\r\n * Header: @@ -382,8 +481,9 @@\r\n * Indicies are printed as 1-based, not 0-based.\r\n * @return {string} The GNU diff string.\r\n */\r\ndiff_match_patch.patch_obj.prototype.toString = function() {\r\n  var coords1, coords2;\r\n  if (this.length1 === 0) {\r\n    coords1 = this.start1 + ',0';\r\n  } else if (this.length1 == 1) {\r\n    coords1 = this.start1 + 1;\r\n  } else {\r\n    coords1 = (this.start1 + 1) + ',' + this.length1;\r\n  }\r\n  if (this.length2 === 0) {\r\n    coords2 = this.start2 + ',0';\r\n  } else if (this.length2 == 1) {\r\n    coords2 = this.start2 + 1;\r\n  } else {\r\n    coords2 = (this.start2 + 1) + ',' + this.length2;\r\n  }\r\n  var text = ['@@ -' + coords1 + ' +' + coords2 + ' @@\\n'];\r\n  var op;\r\n  // Escape the body of the patch with %xx notation.\r\n  for (var x = 0; x < this.diffs.length; x++) {\r\n    switch (this.diffs[x][0]) {\r\n      case DIFF_INSERT:\r\n        op = '+';\r\n        break;\r\n      case DIFF_DELETE:\r\n        op = '-';\r\n        break;\r\n      case DIFF_EQUAL:\r\n        op = ' ';\r\n        break;\r\n    }\r\n    text[x + 1] = op + encodeURI(this.diffs[x][1]) + '\\n';\r\n  }\r\n  return text.join('').replace(/%20/g, ' ');\r\n};\r\n\r\n\r\n// The following export code was added by @ForbesLindesay\r\nmodule.exports = diff_match_patch;\r\nmodule.exports['diff_match_patch'] = diff_match_patch;\r\nmodule.exports['DIFF_DELETE'] = DIFF_DELETE;\r\nmodule.exports['DIFF_INSERT'] = DIFF_INSERT;\r\nmodule.exports['DIFF_EQUAL'] = DIFF_EQUAL;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/diff-match-patch/index.js\n// module id = 38\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/events/events.js\n// module id = 39\n// module chunks = 0","// ISC @ Julien Fontanet\n\n'use strict'\n\n// ===================================================================\n\nvar defineProperty = Object.defineProperty\n\n// -------------------------------------------------------------------\n\nvar captureStackTrace = Error.captureStackTrace\nif (!captureStackTrace) {\n  captureStackTrace = function captureStackTrace (error) {\n    var container = new Error()\n\n    defineProperty(error, 'stack', {\n      configurable: true,\n      get: function getStack () {\n        var stack = container.stack\n\n        // Replace property with value for faster future accesses.\n        defineProperty(this, 'stack', {\n          value: stack\n        })\n\n        return stack\n      },\n      set: function setStack (stack) {\n        defineProperty(error, 'stack', {\n          configurable: true,\n          value: stack,\n          writable: true\n        })\n      }\n    })\n  }\n}\n\n// -------------------------------------------------------------------\n\nfunction BaseError (message) {\n  if (message) {\n    defineProperty(this, 'message', {\n      configurable: true,\n      value: message,\n      writable: true\n    })\n  }\n\n  var cname = this.constructor.name\n  if (\n    cname &&\n    cname !== this.name\n  ) {\n    defineProperty(this, 'name', {\n      configurable: true,\n      value: cname,\n      writable: true\n    })\n  }\n\n  captureStackTrace(this, this.constructor)\n}\n\nBaseError.prototype = Object.create(Error.prototype, {\n  // See: https://github.com/JsCommunity/make-error/issues/4\n  constructor: {\n    configurable: true,\n    value: BaseError,\n    writable: true\n  }\n})\n\n// -------------------------------------------------------------------\n\n// Sets the name of a function if possible (depends of the JS engine).\nvar setFunctionName = (function () {\n  function setFunctionName (fn, name) {\n    return defineProperty(fn, 'name', {\n      configurable: true,\n      value: name\n    })\n  }\n  try {\n    var f = function () {}\n    setFunctionName(f, 'foo')\n    if (f.name === 'foo') {\n      return setFunctionName\n    }\n  } catch (_) {}\n})()\n\n// -------------------------------------------------------------------\n\nfunction makeError (constructor, super_) {\n  if (super_ == null || super_ === Error) {\n    super_ = BaseError\n  } else if (typeof super_ !== 'function') {\n    throw new TypeError('super_ should be a function')\n  }\n\n  var name\n  if (typeof constructor === 'string') {\n    name = constructor\n    constructor = function () { super_.apply(this, arguments) }\n\n    // If the name can be set, do it once and for all.\n    if (setFunctionName) {\n      setFunctionName(constructor, name)\n      name = null\n    }\n  } else if (typeof constructor !== 'function') {\n    throw new TypeError('constructor should be either a string or a function')\n  }\n\n  // Also register the super constructor also as `constructor.super_` just\n  // like Node's `util.inherits()`.\n  constructor.super_ = constructor['super'] = super_\n\n  var properties = {\n    constructor: {\n      configurable: true,\n      value: constructor,\n      writable: true\n    }\n  }\n\n  // If the name could not be set on the constructor, set it on the\n  // prototype.\n  if (name != null) {\n    properties.name = {\n      configurable: true,\n      value: name,\n      writable: true\n    }\n  }\n  constructor.prototype = Object.create(super_.prototype, properties)\n\n  return constructor\n}\nexports = module.exports = makeError\nexports.BaseError = BaseError\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/make-error/index.js\n// module id = 40\n// module chunks = 0","// Only the JSON type is exported, because the text type is deprecated\n// otherwise. (If you want to use it somewhere, you're welcome to pull it out\n// into a separate module that json0 can depend on).\n\nmodule.exports = {\n  type: require('./json0')\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ot-json0/lib/index.js\n// module id = 41\n// module chunks = 0","/*\n This is the implementation of the JSON OT type.\n\n Spec is here: https://github.com/josephg/ShareJS/wiki/JSON-Operations\n\n Note: This is being made obsolete. It will soon be replaced by the JSON2 type.\n*/\n\n/**\n * UTILITY FUNCTIONS\n */\n\n/**\n * Checks if the passed object is an Array instance. Can't use Array.isArray\n * yet because its not supported on IE8.\n *\n * @param obj\n * @returns {boolean}\n */\nvar isArray = function(obj) {\n  return Object.prototype.toString.call(obj) == '[object Array]';\n};\n\n/**\n * Checks if the passed object is an Object instance.\n * No function call (fast) version\n *\n * @param obj\n * @returns {boolean}\n */\nvar isObject = function(obj) {\n  return (!!obj) && (obj.constructor === Object);\n};\n\n/**\n * Clones the passed object using JSON serialization (which is slow).\n *\n * hax, copied from test/types/json. Apparently this is still the fastest way\n * to deep clone an object, assuming we have browser support for JSON.  @see\n * http://jsperf.com/cloning-an-object/12\n */\nvar clone = function(o) {\n  return JSON.parse(JSON.stringify(o));\n};\n\n/**\n * JSON OT Type\n * @type {*}\n */\nvar json = {\n  name: 'json0',\n  uri: 'http://sharejs.org/types/JSONv0'\n};\n\n// You can register another OT type as a subtype in a JSON document using\n// the following function. This allows another type to handle certain\n// operations instead of the builtin JSON type.\nvar subtypes = {};\njson.registerSubtype = function(subtype) {\n  subtypes[subtype.name] = subtype;\n};\n\njson.create = function(data) {\n  // Null instead of undefined if you don't pass an argument.\n  return data === undefined ? null : clone(data);\n};\n\njson.invertComponent = function(c) {\n  var c_ = {p: c.p};\n\n  // handle subtype ops\n  if (c.t && subtypes[c.t]) {\n    c_.t = c.t;\n    c_.o = subtypes[c.t].invert(c.o);\n  }\n\n  if (c.si !== void 0) c_.sd = c.si;\n  if (c.sd !== void 0) c_.si = c.sd;\n  if (c.oi !== void 0) c_.od = c.oi;\n  if (c.od !== void 0) c_.oi = c.od;\n  if (c.li !== void 0) c_.ld = c.li;\n  if (c.ld !== void 0) c_.li = c.ld;\n  if (c.na !== void 0) c_.na = -c.na;\n\n  if (c.lm !== void 0) {\n    c_.lm = c.p[c.p.length-1];\n    c_.p = c.p.slice(0,c.p.length-1).concat([c.lm]);\n  }\n\n  return c_;\n};\n\njson.invert = function(op) {\n  var op_ = op.slice().reverse();\n  var iop = [];\n  for (var i = 0; i < op_.length; i++) {\n    iop.push(json.invertComponent(op_[i]));\n  }\n  return iop;\n};\n\njson.checkValidOp = function(op) {\n  for (var i = 0; i < op.length; i++) {\n    if (!isArray(op[i].p)) throw new Error('Missing path');\n  }\n};\n\njson.checkList = function(elem) {\n  if (!isArray(elem))\n    throw new Error('Referenced element not a list');\n};\n\njson.checkObj = function(elem) {\n  if (!isObject(elem)) {\n    throw new Error(\"Referenced element not an object (it was \" + JSON.stringify(elem) + \")\");\n  }\n};\n\n// helper functions to convert old string ops to and from subtype ops\nfunction convertFromText(c) {\n  c.t = 'text0';\n  var o = {p: c.p.pop()};\n  if (c.si != null) o.i = c.si;\n  if (c.sd != null) o.d = c.sd;\n  c.o = [o];\n}\n\nfunction convertToText(c) {\n  c.p.push(c.o[0].p);\n  if (c.o[0].i != null) c.si = c.o[0].i;\n  if (c.o[0].d != null) c.sd = c.o[0].d;\n  delete c.t;\n  delete c.o;\n}\n\njson.apply = function(snapshot, op) {\n  json.checkValidOp(op);\n\n  op = clone(op);\n\n  var container = {\n    data: snapshot\n  };\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n\n    // convert old string ops to use subtype for backwards compatibility\n    if (c.si != null || c.sd != null)\n      convertFromText(c);\n\n    var parent = null;\n    var parentKey = null;\n    var elem = container;\n    var key = 'data';\n\n    for (var j = 0; j < c.p.length; j++) {\n      var p = c.p[j];\n\n      parent = elem;\n      parentKey = key;\n      elem = elem[key];\n      key = p;\n\n      if (parent == null)\n        throw new Error('Path invalid');\n    }\n\n    // handle subtype ops\n    if (c.t && c.o !== void 0 && subtypes[c.t]) {\n      elem[key] = subtypes[c.t].apply(elem[key], c.o);\n\n    // Number add\n    } else if (c.na !== void 0) {\n      if (typeof elem[key] != 'number')\n        throw new Error('Referenced element not a number');\n\n      elem[key] += c.na;\n    }\n\n    // List replace\n    else if (c.li !== void 0 && c.ld !== void 0) {\n      json.checkList(elem);\n      // Should check the list element matches c.ld\n      elem[key] = c.li;\n    }\n\n    // List insert\n    else if (c.li !== void 0) {\n      json.checkList(elem);\n      elem.splice(key,0, c.li);\n    }\n\n    // List delete\n    else if (c.ld !== void 0) {\n      json.checkList(elem);\n      // Should check the list element matches c.ld here too.\n      elem.splice(key,1);\n    }\n\n    // List move\n    else if (c.lm !== void 0) {\n      json.checkList(elem);\n      if (c.lm != key) {\n        var e = elem[key];\n        // Remove it...\n        elem.splice(key,1);\n        // And insert it back.\n        elem.splice(c.lm,0,e);\n      }\n    }\n\n    // Object insert / replace\n    else if (c.oi !== void 0) {\n      json.checkObj(elem);\n\n      // Should check that elem[key] == c.od\n      elem[key] = c.oi;\n    }\n\n    // Object delete\n    else if (c.od !== void 0) {\n      json.checkObj(elem);\n\n      // Should check that elem[key] == c.od\n      delete elem[key];\n    }\n\n    else {\n      throw new Error('invalid / missing instruction in op');\n    }\n  }\n\n  return container.data;\n};\n\n// Helper to break an operation up into a bunch of small ops.\njson.shatter = function(op) {\n  var results = [];\n  for (var i = 0; i < op.length; i++) {\n    results.push([op[i]]);\n  }\n  return results;\n};\n\n// Helper for incrementally applying an operation to a snapshot. Calls yield\n// after each op component has been applied.\njson.incrementalApply = function(snapshot, op, _yield) {\n  for (var i = 0; i < op.length; i++) {\n    var smallOp = [op[i]];\n    snapshot = json.apply(snapshot, smallOp);\n    // I'd just call this yield, but thats a reserved keyword. Bah!\n    _yield(smallOp, snapshot);\n  }\n\n  return snapshot;\n};\n\n// Checks if two paths, p1 and p2 match.\nvar pathMatches = json.pathMatches = function(p1, p2, ignoreLast) {\n  if (p1.length != p2.length)\n    return false;\n\n  for (var i = 0; i < p1.length; i++) {\n    if (p1[i] !== p2[i] && (!ignoreLast || i !== p1.length - 1))\n      return false;\n  }\n\n  return true;\n};\n\njson.append = function(dest,c) {\n  c = clone(c);\n\n  if (dest.length === 0) {\n    dest.push(c);\n    return;\n  }\n\n  var last = dest[dest.length - 1];\n\n  // convert old string ops to use subtype for backwards compatibility\n  if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n    convertFromText(c);\n    convertFromText(last);\n  }\n\n  if (pathMatches(c.p, last.p)) {\n    // handle subtype ops\n    if (c.t && last.t && c.t === last.t && subtypes[c.t]) {\n      last.o = subtypes[c.t].compose(last.o, c.o);\n\n      // convert back to old string ops\n      if (c.si != null || c.sd != null) {\n        var p = c.p;\n        for (var i = 0; i < last.o.length - 1; i++) {\n          c.o = [last.o.pop()];\n          c.p = p.slice();\n          convertToText(c);\n          dest.push(c);\n        }\n\n        convertToText(last);\n      }\n    } else if (last.na != null && c.na != null) {\n      dest[dest.length - 1] = {p: last.p, na: last.na + c.na};\n    } else if (last.li !== undefined && c.li === undefined && c.ld === last.li) {\n      // insert immediately followed by delete becomes a noop.\n      if (last.ld !== undefined) {\n        // leave the delete part of the replace\n        delete last.li;\n      } else {\n        dest.pop();\n      }\n    } else if (last.od !== undefined && last.oi === undefined && c.oi !== undefined && c.od === undefined) {\n      last.oi = c.oi;\n    } else if (last.oi !== undefined && c.od !== undefined) {\n      // The last path component inserted something that the new component deletes (or replaces).\n      // Just merge them.\n      if (c.oi !== undefined) {\n        last.oi = c.oi;\n      } else if (last.od !== undefined) {\n        delete last.oi;\n      } else {\n        // An insert directly followed by a delete turns into a no-op and can be removed.\n        dest.pop();\n      }\n    } else if (c.lm !== undefined && c.p[c.p.length - 1] === c.lm) {\n      // don't do anything\n    } else {\n      dest.push(c);\n    }\n  } else {\n    // convert string ops back\n    if ((c.si != null || c.sd != null) && (last.si != null || last.sd != null)) {\n      convertToText(c);\n      convertToText(last);\n    }\n\n    dest.push(c);\n  }\n};\n\njson.compose = function(op1,op2) {\n  json.checkValidOp(op1);\n  json.checkValidOp(op2);\n\n  var newOp = clone(op1);\n\n  for (var i = 0; i < op2.length; i++) {\n    json.append(newOp,op2[i]);\n  }\n\n  return newOp;\n};\n\njson.normalize = function(op) {\n  var newOp = [];\n\n  op = isArray(op) ? op : [op];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p == null) c.p = [];\n\n    json.append(newOp,c);\n  }\n\n  return newOp;\n};\n\n// Returns the common length of the paths of ops a and b\njson.commonLengthForOps = function(a, b) {\n  var alen = a.p.length;\n  var blen = b.p.length;\n  if (a.na != null || a.t)\n    alen++;\n\n  if (b.na != null || b.t)\n    blen++;\n\n  if (alen === 0) return -1;\n  if (blen === 0) return null;\n\n  alen--;\n  blen--;\n\n  for (var i = 0; i < alen; i++) {\n    var p = a.p[i];\n    if (i >= blen || p !== b.p[i])\n      return null;\n  }\n\n  return alen;\n};\n\n// Returns true if an op can affect the given path\njson.canOpAffectPath = function(op, path) {\n  return json.commonLengthForOps({p:path}, op) != null;\n};\n\n// transform c so it applies to a document with otherC applied.\njson.transformComponent = function(dest, c, otherC, type) {\n  c = clone(c);\n\n  var common = json.commonLengthForOps(otherC, c);\n  var common2 = json.commonLengthForOps(c, otherC);\n  var cplength = c.p.length;\n  var otherCplength = otherC.p.length;\n\n  if (c.na != null || c.t)\n    cplength++;\n\n  if (otherC.na != null || otherC.t)\n    otherCplength++;\n\n  // if c is deleting something, and that thing is changed by otherC, we need to\n  // update c to reflect that change for invertibility.\n  if (common2 != null && otherCplength > cplength && c.p[common2] == otherC.p[common2]) {\n    if (c.ld !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.ld = json.apply(clone(c.ld),[oc]);\n    } else if (c.od !== void 0) {\n      var oc = clone(otherC);\n      oc.p = oc.p.slice(cplength);\n      c.od = json.apply(clone(c.od),[oc]);\n    }\n  }\n\n  if (common != null) {\n    var commonOperand = cplength == otherCplength;\n\n    // backward compatibility for old string ops\n    var oc = otherC;\n    if ((c.si != null || c.sd != null) && (otherC.si != null || otherC.sd != null)) {\n      convertFromText(c);\n      oc = clone(otherC);\n      convertFromText(oc);\n    }\n\n    // handle subtype ops\n    if (oc.t && subtypes[oc.t]) {\n      if (c.t && c.t === oc.t) {\n        var res = subtypes[c.t].transform(c.o, oc.o, type);\n\n        if (res.length > 0) {\n          // convert back to old string ops\n          if (c.si != null || c.sd != null) {\n            var p = c.p;\n            for (var i = 0; i < res.length; i++) {\n              c.o = [res[i]];\n              c.p = p.slice();\n              convertToText(c);\n              json.append(dest, c);\n            }\n          } else {\n            c.o = res;\n            json.append(dest, c);\n          }\n        }\n\n        return dest;\n      }\n    }\n\n    // transform based on otherC\n    else if (otherC.na !== void 0) {\n      // this case is handled below\n    } else if (otherC.li !== void 0 && otherC.ld !== void 0) {\n      if (otherC.p[common] === c.p[common]) {\n        // noop\n\n        if (!commonOperand) {\n          return dest;\n        } else if (c.ld !== void 0) {\n          // we're trying to delete the same element, -> noop\n          if (c.li !== void 0 && type === 'left') {\n            // we're both replacing one element with another. only one can survive\n            c.ld = clone(otherC.li);\n          } else {\n            return dest;\n          }\n        }\n      }\n    } else if (otherC.li !== void 0) {\n      if (c.li !== void 0 && c.ld === undefined && commonOperand && c.p[common] === otherC.p[common]) {\n        // in li vs. li, left wins.\n        if (type === 'right')\n          c.p[common]++;\n      } else if (otherC.p[common] <= c.p[common]) {\n        c.p[common]++;\n      }\n\n      if (c.lm !== void 0) {\n        if (commonOperand) {\n          // otherC edits the same list we edit\n          if (otherC.p[common] <= c.lm)\n            c.lm++;\n          // changing c.from is handled above.\n        }\n      }\n    } else if (otherC.ld !== void 0) {\n      if (c.lm !== void 0) {\n        if (commonOperand) {\n          if (otherC.p[common] === c.p[common]) {\n            // they deleted the thing we're trying to move\n            return dest;\n          }\n          // otherC edits the same list we edit\n          var p = otherC.p[common];\n          var from = c.p[common];\n          var to = c.lm;\n          if (p < to || (p === to && from < to))\n            c.lm--;\n\n        }\n      }\n\n      if (otherC.p[common] < c.p[common]) {\n        c.p[common]--;\n      } else if (otherC.p[common] === c.p[common]) {\n        if (otherCplength < cplength) {\n          // we're below the deleted element, so -> noop\n          return dest;\n        } else if (c.ld !== void 0) {\n          if (c.li !== void 0) {\n            // we're replacing, they're deleting. we become an insert.\n            delete c.ld;\n          } else {\n            // we're trying to delete the same element, -> noop\n            return dest;\n          }\n        }\n      }\n\n    } else if (otherC.lm !== void 0) {\n      if (c.lm !== void 0 && cplength === otherCplength) {\n        // lm vs lm, here we go!\n        var from = c.p[common];\n        var to = c.lm;\n        var otherFrom = otherC.p[common];\n        var otherTo = otherC.lm;\n        if (otherFrom !== otherTo) {\n          // if otherFrom == otherTo, we don't need to change our op.\n\n          // where did my thing go?\n          if (from === otherFrom) {\n            // they moved it! tie break.\n            if (type === 'left') {\n              c.p[common] = otherTo;\n              if (from === to) // ugh\n                c.lm = otherTo;\n            } else {\n              return dest;\n            }\n          } else {\n            // they moved around it\n            if (from > otherFrom) c.p[common]--;\n            if (from > otherTo) c.p[common]++;\n            else if (from === otherTo) {\n              if (otherFrom > otherTo) {\n                c.p[common]++;\n                if (from === to) // ugh, again\n                  c.lm++;\n              }\n            }\n\n            // step 2: where am i going to put it?\n            if (to > otherFrom) {\n              c.lm--;\n            } else if (to === otherFrom) {\n              if (to > from)\n                c.lm--;\n            }\n            if (to > otherTo) {\n              c.lm++;\n            } else if (to === otherTo) {\n              // if we're both moving in the same direction, tie break\n              if ((otherTo > otherFrom && to > from) ||\n                  (otherTo < otherFrom && to < from)) {\n                if (type === 'right') c.lm++;\n              } else {\n                if (to > from) c.lm++;\n                else if (to === otherFrom) c.lm--;\n              }\n            }\n          }\n        }\n      } else if (c.li !== void 0 && c.ld === undefined && commonOperand) {\n        // li\n        var from = otherC.p[common];\n        var to = otherC.lm;\n        p = c.p[common];\n        if (p > from) c.p[common]--;\n        if (p > to) c.p[common]++;\n      } else {\n        // ld, ld+li, si, sd, na, oi, od, oi+od, any li on an element beneath\n        // the lm\n        //\n        // i.e. things care about where their item is after the move.\n        var from = otherC.p[common];\n        var to = otherC.lm;\n        p = c.p[common];\n        if (p === from) {\n          c.p[common] = to;\n        } else {\n          if (p > from) c.p[common]--;\n          if (p > to) c.p[common]++;\n          else if (p === to && from > to) c.p[common]++;\n        }\n      }\n    }\n    else if (otherC.oi !== void 0 && otherC.od !== void 0) {\n      if (c.p[common] === otherC.p[common]) {\n        if (c.oi !== void 0 && commonOperand) {\n          // we inserted where someone else replaced\n          if (type === 'right') {\n            // left wins\n            return dest;\n          } else {\n            // we win, make our op replace what they inserted\n            c.od = otherC.oi;\n          }\n        } else {\n          // -> noop if the other component is deleting the same object (or any parent)\n          return dest;\n        }\n      }\n    } else if (otherC.oi !== void 0) {\n      if (c.oi !== void 0 && c.p[common] === otherC.p[common]) {\n        // left wins if we try to insert at the same place\n        if (type === 'left') {\n          json.append(dest,{p: c.p, od:otherC.oi});\n        } else {\n          return dest;\n        }\n      }\n    } else if (otherC.od !== void 0) {\n      if (c.p[common] == otherC.p[common]) {\n        if (!commonOperand)\n          return dest;\n        if (c.oi !== void 0) {\n          delete c.od;\n        } else {\n          return dest;\n        }\n      }\n    }\n  }\n\n  json.append(dest,c);\n  return dest;\n};\n\nrequire('./bootstrapTransform')(json, json.transformComponent, json.checkValidOp, json.append);\n\n/**\n * Register a subtype for string operations, using the text0 type.\n */\nvar text = require('./text0');\n\njson.registerSubtype(text);\nmodule.exports = json;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ot-json0/lib/json0.js\n// module id = 42\n// module chunks = 0","// DEPRECATED!\n//\n// This type works, but is not exported. Its included here because the JSON0\n// embedded string operations use this library.\n\n\n// A simple text implementation\n//\n// Operations are lists of components. Each component either inserts or deletes\n// at a specified position in the document.\n//\n// Components are either:\n//  {i:'str', p:100}: Insert 'str' at position 100 in the document\n//  {d:'str', p:100}: Delete 'str' at position 100 in the document\n//\n// Components in an operation are executed sequentially, so the position of components\n// assumes previous components have already executed.\n//\n// Eg: This op:\n//   [{i:'abc', p:0}]\n// is equivalent to this op:\n//   [{i:'a', p:0}, {i:'b', p:1}, {i:'c', p:2}]\n\nvar text = module.exports = {\n  name: 'text0',\n  uri: 'http://sharejs.org/types/textv0',\n  create: function(initial) {\n    if ((initial != null) && typeof initial !== 'string') {\n      throw new Error('Initial data must be a string');\n    }\n    return initial || '';\n  }\n};\n\n/** Insert s2 into s1 at pos. */\nvar strInject = function(s1, pos, s2) {\n  return s1.slice(0, pos) + s2 + s1.slice(pos);\n};\n\n/** Check that an operation component is valid. Throws if its invalid. */\nvar checkValidComponent = function(c) {\n  if (typeof c.p !== 'number')\n    throw new Error('component missing position field');\n\n  if ((typeof c.i === 'string') === (typeof c.d === 'string'))\n    throw new Error('component needs an i or d field');\n\n  if (c.p < 0)\n    throw new Error('position cannot be negative');\n};\n\n/** Check that an operation is valid */\nvar checkValidOp = function(op) {\n  for (var i = 0; i < op.length; i++) {\n    checkValidComponent(op[i]);\n  }\n};\n\n/** Apply op to snapshot */\ntext.apply = function(snapshot, op) {\n  var deleted;\n\n  checkValidOp(op);\n  for (var i = 0; i < op.length; i++) {\n    var component = op[i];\n    if (component.i != null) {\n      snapshot = strInject(snapshot, component.p, component.i);\n    } else {\n      deleted = snapshot.slice(component.p, component.p + component.d.length);\n      if (component.d !== deleted)\n        throw new Error(\"Delete component '\" + component.d + \"' does not match deleted text '\" + deleted + \"'\");\n\n      snapshot = snapshot.slice(0, component.p) + snapshot.slice(component.p + component.d.length);\n    }\n  }\n  return snapshot;\n};\n\n/**\n * Append a component to the end of newOp. Exported for use by the random op\n * generator and the JSON0 type.\n */\nvar append = text._append = function(newOp, c) {\n  if (c.i === '' || c.d === '') return;\n\n  if (newOp.length === 0) {\n    newOp.push(c);\n  } else {\n    var last = newOp[newOp.length - 1];\n\n    if (last.i != null && c.i != null && last.p <= c.p && c.p <= last.p + last.i.length) {\n      // Compose the insert into the previous insert\n      newOp[newOp.length - 1] = {i:strInject(last.i, c.p - last.p, c.i), p:last.p};\n\n    } else if (last.d != null && c.d != null && c.p <= last.p && last.p <= c.p + c.d.length) {\n      // Compose the deletes together\n      newOp[newOp.length - 1] = {d:strInject(c.d, last.p - c.p, last.d), p:c.p};\n\n    } else {\n      newOp.push(c);\n    }\n  }\n};\n\n/** Compose op1 and op2 together */\ntext.compose = function(op1, op2) {\n  checkValidOp(op1);\n  checkValidOp(op2);\n  var newOp = op1.slice();\n  for (var i = 0; i < op2.length; i++) {\n    append(newOp, op2[i]);\n  }\n  return newOp;\n};\n\n/** Clean up an op */\ntext.normalize = function(op) {\n  var newOp = [];\n\n  // Normalize should allow ops which are a single (unwrapped) component:\n  // {i:'asdf', p:23}.\n  // There's no good way to test if something is an array:\n  // http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/\n  // so this is probably the least bad solution.\n  if (op.i != null || op.p != null) op = [op];\n\n  for (var i = 0; i < op.length; i++) {\n    var c = op[i];\n    if (c.p == null) c.p = 0;\n\n    append(newOp, c);\n  }\n\n  return newOp;\n};\n\n// This helper method transforms a position by an op component.\n//\n// If c is an insert, insertAfter specifies whether the transform\n// is pushed after the insert (true) or before it (false).\n//\n// insertAfter is optional for deletes.\nvar transformPosition = function(pos, c, insertAfter) {\n  // This will get collapsed into a giant ternary by uglify.\n  if (c.i != null) {\n    if (c.p < pos || (c.p === pos && insertAfter)) {\n      return pos + c.i.length;\n    } else {\n      return pos;\n    }\n  } else {\n    // I think this could also be written as: Math.min(c.p, Math.min(c.p -\n    // otherC.p, otherC.d.length)) but I think its harder to read that way, and\n    // it compiles using ternary operators anyway so its no slower written like\n    // this.\n    if (pos <= c.p) {\n      return pos;\n    } else if (pos <= c.p + c.d.length) {\n      return c.p;\n    } else {\n      return pos - c.d.length;\n    }\n  }\n};\n\n// Helper method to transform a cursor position as a result of an op.\n//\n// Like transformPosition above, if c is an insert, insertAfter specifies\n// whether the cursor position is pushed after an insert (true) or before it\n// (false).\ntext.transformCursor = function(position, op, side) {\n  var insertAfter = side === 'right';\n  for (var i = 0; i < op.length; i++) {\n    position = transformPosition(position, op[i], insertAfter);\n  }\n\n  return position;\n};\n\n// Transform an op component by another op component. Asymmetric.\n// The result will be appended to destination.\n//\n// exported for use in JSON type\nvar transformComponent = text._tc = function(dest, c, otherC, side) {\n  //var cIntersect, intersectEnd, intersectStart, newC, otherIntersect, s;\n\n  checkValidComponent(c);\n  checkValidComponent(otherC);\n\n  if (c.i != null) {\n    // Insert.\n    append(dest, {i:c.i, p:transformPosition(c.p, otherC, side === 'right')});\n  } else {\n    // Delete\n    if (otherC.i != null) {\n      // Delete vs insert\n      var s = c.d;\n      if (c.p < otherC.p) {\n        append(dest, {d:s.slice(0, otherC.p - c.p), p:c.p});\n        s = s.slice(otherC.p - c.p);\n      }\n      if (s !== '')\n        append(dest, {d: s, p: c.p + otherC.i.length});\n\n    } else {\n      // Delete vs delete\n      if (c.p >= otherC.p + otherC.d.length)\n        append(dest, {d: c.d, p: c.p - otherC.d.length});\n      else if (c.p + c.d.length <= otherC.p)\n        append(dest, c);\n      else {\n        // They overlap somewhere.\n        var newC = {d: '', p: c.p};\n\n        if (c.p < otherC.p)\n          newC.d = c.d.slice(0, otherC.p - c.p);\n\n        if (c.p + c.d.length > otherC.p + otherC.d.length)\n          newC.d += c.d.slice(otherC.p + otherC.d.length - c.p);\n\n        // This is entirely optional - I'm just checking the deleted text in\n        // the two ops matches\n        var intersectStart = Math.max(c.p, otherC.p);\n        var intersectEnd = Math.min(c.p + c.d.length, otherC.p + otherC.d.length);\n        var cIntersect = c.d.slice(intersectStart - c.p, intersectEnd - c.p);\n        var otherIntersect = otherC.d.slice(intersectStart - otherC.p, intersectEnd - otherC.p);\n        if (cIntersect !== otherIntersect)\n          throw new Error('Delete ops delete different text in the same region of the document');\n\n        if (newC.d !== '') {\n          newC.p = transformPosition(newC.p, otherC);\n          append(dest, newC);\n        }\n      }\n    }\n  }\n\n  return dest;\n};\n\nvar invertComponent = function(c) {\n  return (c.i != null) ? {d:c.i, p:c.p} : {i:c.d, p:c.p};\n};\n\n// No need to use append for invert, because the components won't be able to\n// cancel one another.\ntext.invert = function(op) {\n  // Shallow copy & reverse that sucka.\n  op = op.slice().reverse();\n  for (var i = 0; i < op.length; i++) {\n    op[i] = invertComponent(op[i]);\n  }\n  return op;\n};\n\nrequire('./bootstrapTransform')(text, transformComponent, checkValidOp, append);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/ot-json0/lib/text0.js\n// module id = 43\n// module chunks = 0","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/setimmediate/setImmediate.js\n// module id = 44\n// module chunks = 0","var Doc = require('./doc');\nvar Query = require('./query');\nvar emitter = require('../emitter');\nvar ShareDBError = require('../error');\nvar types = require('../types');\nvar util = require('../util');\n\n/**\n * Handles communication with the sharejs server and provides queries and\n * documents.\n *\n * We create a connection with a socket object\n *   connection = new sharejs.Connection(sockset)\n * The socket may be any object handling the websocket protocol. See the\n * documentation of bindToSocket() for details. We then wait for the connection\n * to connect\n *   connection.on('connected', ...)\n * and are finally able to work with shared documents\n *   connection.get('food', 'steak') // Doc\n *\n * @param socket @see bindToSocket\n */\nmodule.exports = Connection;\nfunction Connection(socket) {\n  emitter.EventEmitter.call(this);\n\n  // Map of collection -> id -> doc object for created documents.\n  // (created documents MUST BE UNIQUE)\n  this.collections = {};\n\n  // Each query is created with an id that the server uses when it sends us\n  // info about the query (updates, etc)\n  this.nextQueryId = 1;\n\n  // Map from query ID -> query object.\n  this.queries = {};\n\n  // A unique message number for the given id\n  this.seq = 1;\n\n  // Equals agent.clientId on the server\n  this.id = null;\n\n  // This direct reference from connection to agent is not used internal to\n  // ShareDB, but it is handy for server-side only user code that may cache\n  // state on the agent and read it in middleware\n  this.agent = null;\n\n  this.debug = false;\n\n  this.bindToSocket(socket);\n}\nemitter.mixin(Connection);\n\n\n/**\n * Use socket to communicate with server\n *\n * Socket is an object that can handle the websocket protocol. This method\n * installs the onopen, onclose, onmessage and onerror handlers on the socket to\n * handle communication and sends messages by calling socket.send(message). The\n * sockets `readyState` property is used to determine the initaial state.\n *\n * @param socket Handles the websocket protocol\n * @param socket.readyState\n * @param socket.close\n * @param socket.send\n * @param socket.onopen\n * @param socket.onclose\n * @param socket.onmessage\n * @param socket.onerror\n */\nConnection.prototype.bindToSocket = function(socket) {\n  if (this.socket) {\n    this.socket.close();\n    this.socket.onmessage = null;\n    this.socket.onopen = null;\n    this.socket.onerror = null;\n    this.socket.onclose = null;\n  }\n\n  this.socket = socket;\n\n  // State of the connection. The correspoding events are emmited when this changes\n  //\n  // - 'connecting'   The connection is still being established, or we are still\n  //                    waiting on the server to send us the initialization message\n  // - 'connected'    The connection is open and we have connected to a server\n  //                    and recieved the initialization message\n  // - 'disconnected' Connection is closed, but it will reconnect automatically\n  // - 'closed'       The connection was closed by the client, and will not reconnect\n  // - 'stopped'      The connection was closed by the server, and will not reconnect\n  this.state = (socket.readyState === 0 || socket.readyState === 1) ? 'connecting' : 'disconnected';\n\n  // This is a helper variable the document uses to see whether we're\n  // currently in a 'live' state. It is true if and only if we're connected\n  this.canSend = false;\n\n  var connection = this;\n\n  socket.onmessage = function(event) {\n    try {\n      var data = (typeof event.data === 'string') ?\n        JSON.parse(event.data) : event.data;\n    } catch (err) {\n      console.warn('Failed to parse message', event);\n      return;\n    }\n\n    if (connection.debug) console.log('RECV', JSON.stringify(data));\n\n    var request = {data: data};\n    connection.emit('receive', request);\n    if (!request.data) return;\n\n    try {\n      connection.handleMessage(request.data);\n    } catch (err) {\n      process.nextTick(function() {\n        connection.emit('error', err);\n      });\n    }\n  };\n\n  socket.onopen = function() {\n    connection._setState('connecting');\n  };\n\n  socket.onerror = function(err) {\n    // This isn't the same as a regular error, because it will happen normally\n    // from time to time. Your connection should probably automatically\n    // reconnect anyway, but that should be triggered off onclose not onerror.\n    // (onclose happens when onerror gets called anyway).\n    connection.emit('connection error', err);\n  };\n\n  socket.onclose = function(reason) {\n    // node-browserchannel reason values:\n    //   'Closed' - The socket was manually closed by calling socket.close()\n    //   'Stopped by server' - The server sent the stop message to tell the client not to try connecting\n    //   'Request failed' - Server didn't respond to request (temporary, usually offline)\n    //   'Unknown session ID' - Server session for client is missing (temporary, will immediately reestablish)\n\n    if (reason === 'closed' || reason === 'Closed') {\n      connection._setState('closed', reason);\n\n    } else if (reason === 'stopped' || reason === 'Stopped by server') {\n      connection._setState('stopped', reason);\n\n    } else {\n      connection._setState('disconnected', reason);\n    }\n  };\n};\n\n/**\n * @param {object} message\n * @param {String} message.a action\n */\nConnection.prototype.handleMessage = function(message) {\n  var err = null;\n  if (message.error) {\n    // wrap in Error object so can be passed through event emitters\n    err = new Error(message.error.message);\n    err.code = message.error.code;\n    // Add the message data to the error object for more context\n    err.data = message;\n    delete message.error;\n  }\n  // Switch on the message action. Most messages are for documents and are\n  // handled in the doc class.\n  switch (message.a) {\n    case 'init':\n      // Client initialization packet\n      if (message.protocol !== 1) {\n        err = new ShareDBError(4019, 'Invalid protocol version');\n        return this.emit('error', err);\n      }\n      if (types.map[message.type] !== types.defaultType) {\n        err = new ShareDBError(4020, 'Invalid default type');\n        return this.emit('error', err);\n      }\n      if (typeof message.id !== 'string') {\n        err = new ShareDBError(4021, 'Invalid client id');\n        return this.emit('error', err);\n      }\n      this.id = message.id;\n\n      this._setState('connected');\n      return;\n\n    case 'qf':\n      var query = this.queries[message.id];\n      if (query) query._handleFetch(err, message.data, message.extra);\n      return;\n    case 'qs':\n      var query = this.queries[message.id];\n      if (query) query._handleSubscribe(err, message.data, message.extra);\n      return;\n    case 'qu':\n      // Queries are removed immediately on calls to destroy, so we ignore\n      // replies to query unsubscribes. Perhaps there should be a callback for\n      // destroy, but this is currently unimplemented\n      return;\n    case 'q':\n      // Query message. Pass this to the appropriate query object.\n      var query = this.queries[message.id];\n      if (!query) return;\n      if (err) return query._handleError(err);\n      if (message.diff) query._handleDiff(message.diff);\n      if (message.hasOwnProperty('extra')) query._handleExtra(message.extra);\n      return;\n\n    case 'bf':\n      return this._handleBulkMessage(message, '_handleFetch');\n    case 'bs':\n      return this._handleBulkMessage(message, '_handleSubscribe');\n    case 'bu':\n      return this._handleBulkMessage(message, '_handleUnsubscribe');\n\n    case 'f':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleFetch(err, message.data);\n      return;\n    case 's':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleSubscribe(err, message.data);\n      return;\n    case 'u':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleUnsubscribe(err);\n      return;\n    case 'op':\n      var doc = this.getExisting(message.c, message.d);\n      if (doc) doc._handleOp(err, message);\n      return;\n\n    default:\n      console.warn('Ignorning unrecognized message', message);\n  }\n};\n\nConnection.prototype._handleBulkMessage = function(message, method) {\n  if (message.data) {\n    for (var id in message.data) {\n      var doc = this.getExisting(message.c, id);\n      if (doc) doc[method](message.error, message.data[id]);\n    }\n  } else if (Array.isArray(message.b)) {\n    for (var i = 0; i < message.b.length; i++) {\n      var id = message.b[i];\n      var doc = this.getExisting(message.c, id);\n      if (doc) doc[method](message.error);\n    }\n  } else if (message.b) {\n    for (var id in message.b) {\n      var doc = this.getExisting(message.c, id);\n      if (doc) doc[method](message.error);\n    }\n  } else {\n    console.error('Invalid bulk message', message);\n  }\n};\n\nConnection.prototype._reset = function() {\n  this.seq = 1;\n  this.id = null;\n  this.agent = null;\n};\n\n// Set the connection's state. The connection is basically a state machine.\nConnection.prototype._setState = function(newState, reason) {\n  if (this.state === newState) return;\n\n  // I made a state diagram. The only invalid transitions are getting to\n  // 'connecting' from anywhere other than 'disconnected' and getting to\n  // 'connected' from anywhere other than 'connecting'.\n  if (\n    (newState === 'connecting' && this.state !== 'disconnected' && this.state !== 'stopped' && this.state !== 'closed') ||\n    (newState === 'connected' && this.state !== 'connecting')\n  ) {\n    var err = new ShareDBError(5007, 'Cannot transition directly from ' + this.state + ' to ' + newState);\n    return this.emit('error', err);\n  }\n\n  this.state = newState;\n  this.canSend = (newState === 'connected');\n\n  if (newState === 'disconnected' || newState === 'stopped' || newState === 'closed') this._reset();\n\n  // Group subscribes together to help server make more efficient calls\n  this.startBulk();\n  // Emit the event to all queries\n  for (var id in this.queries) {\n    var query = this.queries[id];\n    query._onConnectionStateChanged();\n  }\n  // Emit the event to all documents\n  for (var collection in this.collections) {\n    var docs = this.collections[collection];\n    for (var id in docs) {\n      docs[id]._onConnectionStateChanged();\n    }\n  }\n  this.endBulk();\n\n  this.emit(newState, reason);\n  this.emit('state', newState, reason);\n};\n\nConnection.prototype.startBulk = function() {\n  if (!this.bulk) this.bulk = {};\n};\n\nConnection.prototype.endBulk = function() {\n  if (this.bulk) {\n    for (var collection in this.bulk) {\n      var actions = this.bulk[collection];\n      this._sendBulk('f', collection, actions.f);\n      this._sendBulk('s', collection, actions.s);\n      this._sendBulk('u', collection, actions.u);\n    }\n  }\n  this.bulk = null;\n};\n\nConnection.prototype._sendBulk = function(action, collection, values) {\n  if (!values) return;\n  var ids = [];\n  var versions = {};\n  var versionsCount = 0;\n  var versionId;\n  for (var id in values) {\n    var value = values[id];\n    if (value == null) {\n      ids.push(id);\n    } else {\n      versions[id] = value;\n      versionId = id;\n      versionsCount++;\n    }\n  }\n  if (ids.length === 1) {\n    var id = ids[0];\n    this.send({a: action, c: collection, d: id});\n  } else if (ids.length) {\n    this.send({a: 'b' + action, c: collection, b: ids});\n  }\n  if (versionsCount === 1) {\n    var version = versions[versionId];\n    this.send({a: action, c: collection, d: versionId, v: version});\n  } else if (versionsCount) {\n    this.send({a: 'b' + action, c: collection, b: versions});\n  }\n};\n\nConnection.prototype._sendAction = function(action, doc, version) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  if (this.bulk) {\n    // Bulk subscribe\n    var actions = this.bulk[doc.collection] || (this.bulk[doc.collection] = {});\n    var versions = actions[action] || (actions[action] = {});\n    var isDuplicate = versions.hasOwnProperty(doc.id);\n    versions[doc.id] = version;\n    return isDuplicate;\n  } else {\n    // Send single doc subscribe message\n    var message = {a: action, c: doc.collection, d: doc.id, v: version};\n    this.send(message);\n  }\n};\n\nConnection.prototype.sendFetch = function(doc) {\n  return this._sendAction('f', doc, doc.version);\n};\n\nConnection.prototype.sendSubscribe = function(doc) {\n  return this._sendAction('s', doc, doc.version);\n};\n\nConnection.prototype.sendUnsubscribe = function(doc) {\n  return this._sendAction('u', doc);\n};\n\nConnection.prototype.sendOp = function(doc, op) {\n  // Ensure the doc is registered so that it receives the reply message\n  this._addDoc(doc);\n  var message = {\n    a: 'op',\n    c: doc.collection,\n    d: doc.id,\n    v: doc.version,\n    src: op.src,\n    seq: op.seq\n  };\n  if (op.op) message.op = op.op;\n  if (op.create) message.create = op.create;\n  if (op.del) message.del = op.del;\n  this.send(message);\n};\n\n\n/**\n * Sends a message down the socket\n */\nConnection.prototype.send = function(message) {\n  if (this.debug) console.log('SEND', JSON.stringify(message));\n\n  this.emit('send', message);\n  this.socket.send(JSON.stringify(message));\n};\n\n\n/**\n * Closes the socket and emits 'closed'\n */\nConnection.prototype.close = function() {\n  this.socket.close();\n};\n\nConnection.prototype.getExisting = function(collection, id) {\n  if (this.collections[collection]) return this.collections[collection][id];\n};\n\n\n/**\n * Get or create a document.\n *\n * @param collection\n * @param id\n * @return {Doc}\n */\nConnection.prototype.get = function(collection, id) {\n  var docs = this.collections[collection] ||\n    (this.collections[collection] = {});\n\n  var doc = docs[id];\n  if (!doc) {\n    doc = docs[id] = new Doc(this, collection, id);\n    this.emit('doc', doc);\n  }\n\n  return doc;\n};\n\n\n/**\n * Remove document from this.collections\n *\n * @private\n */\nConnection.prototype._destroyDoc = function(doc) {\n  var docs = this.collections[doc.collection];\n  if (!docs) return;\n\n  delete docs[doc.id];\n\n  // Delete the collection container if its empty. This could be a source of\n  // memory leaks if you slowly make a billion collections, which you probably\n  // won't do anyway, but whatever.\n  if (!util.hasKeys(docs)) {\n    delete this.collections[doc.collection];\n  }\n};\n\nConnection.prototype._addDoc = function(doc) {\n  var docs = this.collections[doc.collection];\n  if (!docs) {\n    docs = this.collections[doc.collection] = {};\n  }\n  if (docs[doc.id] !== doc) {\n    docs[doc.id] = doc;\n  }\n};\n\n// Helper for createFetchQuery and createSubscribeQuery, below.\nConnection.prototype._createQuery = function(action, collection, q, options, callback) {\n  var id = this.nextQueryId++;\n  var query = new Query(action, this, id, collection, q, options, callback);\n  this.queries[id] = query;\n  query.send();\n  return query;\n};\n\n// Internal function. Use query.destroy() to remove queries.\nConnection.prototype._destroyQuery = function(query) {\n  delete this.queries[query.id];\n};\n\n// The query options object can contain the following fields:\n//\n// db: Name of the db for the query. You can attach extraDbs to ShareDB and\n//   pick which one the query should hit using this parameter.\n\n// Create a fetch query. Fetch queries are only issued once, returning the\n// results directly into the callback.\n//\n// The callback should have the signature function(error, results, extra)\n// where results is a list of Doc objects.\nConnection.prototype.createFetchQuery = function(collection, q, options, callback) {\n  return this._createQuery('qf', collection, q, options, callback);\n};\n\n// Create a subscribe query. Subscribe queries return with the initial data\n// through the callback, then update themselves whenever the query result set\n// changes via their own event emitter.\n//\n// If present, the callback should have the signature function(error, results, extra)\n// where results is a list of Doc objects.\nConnection.prototype.createSubscribeQuery = function(collection, q, options, callback) {\n  return this._createQuery('qs', collection, q, options, callback);\n};\n\nConnection.prototype.hasPending = function() {\n  return !!(\n    this._firstDoc(hasPending) ||\n    this._firstQuery(hasPending)\n  );\n};\nfunction hasPending(object) {\n  return object.hasPending();\n}\n\nConnection.prototype.hasWritePending = function() {\n  return !!this._firstDoc(hasWritePending);\n};\nfunction hasWritePending(object) {\n  return object.hasWritePending();\n}\n\nConnection.prototype.whenNothingPending = function(callback) {\n  var doc = this._firstDoc(hasPending);\n  if (doc) {\n    // If a document is found with a pending operation, wait for it to emit\n    // that nothing is pending anymore, and then recheck all documents again.\n    // We have to recheck all documents, just in case another mutation has\n    // been made in the meantime as a result of an event callback\n    doc.once('nothing pending', this._nothingPendingRetry(callback));\n    return;\n  }\n  var query = this._firstQuery(hasPending);\n  if (query) {\n    query.once('ready', this._nothingPendingRetry(callback));\n    return;\n  }\n  // Call back when no pending operations\n  process.nextTick(callback);\n};\nConnection.prototype._nothingPendingRetry = function(callback) {\n  var connection = this;\n  return function() {\n    process.nextTick(function() {\n      connection.whenNothingPending(callback);\n    });\n  };\n};\n\nConnection.prototype._firstDoc = function(fn) {\n  for (var collection in this.collections) {\n    var docs = this.collections[collection];\n    for (var id in docs) {\n      var doc = docs[id];\n      if (fn(doc)) {\n        return doc;\n      }\n    }\n  }\n};\n\nConnection.prototype._firstQuery = function(fn) {\n  for (var id in this.queries) {\n    var query = this.queries[id];\n    if (fn(query)) {\n      return query;\n    }\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/client/connection.js\n// module id = 45\n// module chunks = 0","\nexports.doNothing = doNothing;\nfunction doNothing() {}\n\nexports.hasKeys = function(object) {\n  for (var key in object) return true;\n  return false;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/sharedb/lib/util.js\n// module id = 46\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 47\n// module chunks = 0"],"sourceRoot":""}